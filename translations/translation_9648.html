
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    macros: {
      bm: ["\\boldsymbol{#1}", 1]
    }
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/9648">Naive Bayes is all you need ?</a></h1>

<p>By 苏剑林 | June 08, 2023</p>

<p>I apologize for choosing such a clickbait-style title. After writing <a href="translation_9617.html">"NBCE: Using Naive Bayes to Extend the Context Length of LLMs"</a>, I felt that the Naive Bayes mechanism shares many characteristics with the Attention mechanism. Later, after doing some derivation, I discovered that the Attention mechanism can actually be viewed as a generalized, parameterized version of Naive Bayes. If that is the case, doesn't "<a href="translation_4765.html">Attention is All You Need</a>" also imply that "Naive Bayes is all you need"? This is the reason behind the title of this article.</p>

<p>Next, I will introduce my thought process and analyze how to understand the Attention mechanism from the perspective of Naive Bayes.</p>

<h2>Naive Bayes</h2>

<p>This article primarily considers language models, which aim to model $p(x_t|x_1,\cdots,x_{t-1})$. According to Bayes' theorem, we have:</p>

\begin{equation}p(x_t|x_1,\cdots,x_{t-1}) = \frac{p(x_1,\cdots,x_{t-1}|x_t)p(x_t)}{p(x_1,\cdots,x_{t-1})}\propto p(x_1,\cdots,x_{t-1}|x_t)p(x_t)\end{equation}

<p>Based on the independence assumption $p(x_1,\cdots,x_{t-1}|x_t) = \prod\limits_{j=1}^{t-1} p(x_j|x_t)$, we get:</p>

\begin{equation}p(x_t|x_1,\cdots,x_{t-1}) \propto \prod_{j=1}^{t-1} p(x_j|x_t)p(x_t)\end{equation}

<p>Applying Bayes' theorem again, $p(x_j|x_t)=\frac{p(x_t|x_j)p(x_j)}{p(x_t)}\propto\frac{p(x_t|x_j)}{p(x_t)}$, we obtain:</p>

\begin{equation}p(x_t|x_1,\cdots,x_{t-1}) \propto \frac{1}{[p(x_t)]^{t-2}}\prod_{j=1}^{t-1} p(x_t|x_j)\end{equation}

<p>Taking the logarithm of both sides, we get:</p>

\begin{equation}\log p(x_t|x_1,\cdots,x_{t-1}) = \sum_{j=1}^{t-1}\log p(x_t|x_j) - (t - 2) \log p(x_t) + \text{constant}\end{equation}

<h2>Generalized Results</h2>

<p>We performed the same derivation in <a href="translation_9617.html">"NBCE: Using Naive Bayes to Extend the Context Length of LLMs"</a>. Similar to that article, we generalize the above equation as:</p>

\begin{equation}\log p(x_t|x_1,\cdots,x_{t-1}) = (1 + \beta)\mathcal{P}[\log p(x_t|x_j)] - \beta \log p(x_t) + \text{constant}\end{equation}

<p>Here, $\beta$ acts as a hyperparameter to be tuned, and $\mathcal{P}$ represents some form of Pooling. Next, we primarily look at the case where $\beta=0$ and the Pooling method is a weighted average:</p>

\begin{equation}\log p(x_t|x_1,\cdots,x_{t-1}) = \sum_j a_{t,j} \log p(x_t|x_j) + \text{constant}\label{eq:nb-core}\end{equation}

<p>where $a_{t,j}$ is a function of $x_{t-1}$ and $x_j$.</p>

<p>Some readers might wonder if this generalized equation can still be considered Naive Bayes? I believe it can be treated as a generalized Naive Bayes, because standard Naive Bayes can be seen as an equal-weighted average of each $\log p(x_t|x_j)$, whereas here we replace it with a more general weighted average. However, by selecting $a_{t,j}$ as a function of $x_{t-1}$ and $x_j$, we highlight the role of $x_{t-1}$, which addresses the drawback of Naive Bayes' lack of sequence awareness. Therefore, more precisely, Equation $\eqref{eq:nb-core}$ is a combination of a 2-gram language model and Naive Bayes.</p>

<h2>The Emergence of Attention</h2>

<p>Next, by further parameterizing $\log p(x_t|x_j)$, we can see the form of Attention. It is not hard to find that $p(x_t|x_j)$ is essentially the Skip-Gram model from the old Word2Vec. Its conventional modeling method is "Embedding + Inner Product + Softmax", namely:</p>

\begin{equation}p(x_t|x_j) = \frac{e^{v(x_j)\cdot w(x_t)}}{Z(x_j)},\quad Z(x_j) = \sum_{x_t\in Vocab}e^{v(x_j)\cdot w(x_t)}\end{equation}

<p>Therefore, we can simply assume that:</p>

\begin{equation}\log p(x_t|x_j) = v(x_j)\cdot w(x_t) + \text{constant}\end{equation}

<p>Substituting this into Equation $\eqref{eq:nb-core}$, we get:</p>

\begin{equation}\log p(x_t|x_1,\cdots,x_{t-1}) = \left(\sum_j a_{t,j} v(x_j)\right)\cdot w(x_t) + \text{constant}\label{eq:nb-core-2}\end{equation}

<p>Taking the term inside the parentheses as a standard operation for feature fusion, it is actually the regular Attention mechanism. Thus, using a single layer of Attention to perform language modeling is essentially generalized Naive Bayes.</p>

<p>Of course, we have not yet determined $a_{t,j}$. In the previous section, we said $a_{t,j}$ is a function of $x_{t-1}$ and $x_j$, which also needs to be normalized (for the weighted average). A simple way is to use "Embedding + Inner Product + Softmax," just like Skip-Gram:</p>

\begin{equation}a_{t,j} = \frac{e^{q(x_{t-1})\cdot k(x_j)}}{Z_t},\quad Z_t = \sum_{j=1}^{t-1} e^{q(x_{t-1})\cdot k(x_j)}\end{equation}

<p>Substituting this into Equation $\eqref{eq:nb-core-2}$ yields the most commonly used Dot-Product Attention today. Of course, this is not the only way; there is also additive Attention, etc. The primary reason for choosing Dot-Product is that it can be implemented in parallel with relatively low memory consumption.</p>

<h2>Stacking and Residuals</h2>

<p>No matter how it is parameterized, the capability of a single-layer Naive Bayes model is always limited, so we need to further increase the complexity of the model. From the perspective of neural networks, the primary way to increase model complexity is to increase depth, which means stacking layer upon layer. So, how do we understand this stacking from the perspective of probability distributions? The answer is latent variable models.</p>

<p>A latent variable model introduces hidden variables $z_1, z_2, \cdots, z_{t-1}$ such that:</p>

\begin{equation}p(x_t|x_1,\cdots,x_{t-1}) = \int p(x_t|z_1,\cdots,z_{t-1})p(z_1,\cdots,z_{t-1}|x_1,\cdots,x_{t-1})dz_1 \cdots dz_{t-1}\end{equation}

<p>Simply put, this involves superimposing simple distributions to fit more complex ones, which is consistent with the idea of GMM (Gaussian Mixture Models). Based on previous discussions, we also model $p(x_t|z_1,\cdots,z_{t-1})$ using Naive Bayes, which means it is a single layer of Attention at the feature level. For $p(z_1,\cdots,z_{t-1}|x_1,\cdots,x_{t-1})$, following the characteristics of autoregressive models, we decompose it as:</p>

\begin{equation}p(z_1,\cdots,z_{t-1}|x_1,\cdots,x_{t-1}) = \prod_{k=1}^{t-1} p(z_k|x_1,\cdots,x_k)\end{equation}

<p>In this way, each $p(z_k|x_1,\cdots,x_k)$ has the same form as $p(x_t|z_1,\cdots,z_{t-1})$, so it can also be modeled using Naive Bayes. For simplicity, we define $z_k$ as a continuous variable, and $p(z_k|x_1,\cdots,x_k)$ as a <a href="translation_1870.html">Dirac distribution</a>. Consequently, the integral can be calculated directly, and the result is the stacking of two layers of Attention.</p>

<p>Finally, another key component in Transformer is the residual connection. In fact, it generalizes Equation $\eqref{eq:nb-core}$ as:</p>

\begin{equation}\log p(x_t|x_1,\cdots,x_{t-1}) = \log p(x_t|x_{t-1}) + \sum_j a_{t,j} \log p(x_t|x_j) + \text{constant}\end{equation}

<p>This can be understood as a type of Pooling that emphasizes the status of the 2-gram, acting as a kind of prior. Finally, the remaining components like FeedForward layers and LayerNorm layers do not involve interactions between tokens and can be understood as more complexly parameterized Naive Bayes.</p>

<p>Admittedly, such a broad explanation might seem a bit forced. However, my original intention was not to perfectly explain Transformer or Attention, but to gain new insights regarding context length extrapolation from the Naive Bayes perspective. Unfortunately, I have not yet achieved the expected results. Nevertheless, even if it seems like blind narcissism, I still believe the aforementioned perspective of Naive Bayes and latent variable models has further potential for exploration. For instance, it seems we can use the Naive Bayes perspective to explain why In-Context Learning in Attention-based language models works.</p>

<h2>Summary</h2>

<p>This article explains the connection between Naive Bayes and the Attention mechanism, showing that Attention can be viewed as a generalized form of Naive Bayes. From this perspective, we can further understand concepts such as stacking and residuals in Attention.</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/9648" style="color: #005fcc;">https://kexue.fm/archives/9648</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
