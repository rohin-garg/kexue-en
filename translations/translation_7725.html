
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      tags: 'ams',
      packages: {'[+]': ['ams']}
    }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/7725">Variational Autoencoder (VI): An Attempt to Understand VAE from a Geometric Perspective</a></h1>

<p>By 苏剑林 | September 10, 2020</p>

<p>Some time ago, during a technical sharing session at the company, it was the author's turn to present. Everyone hoped I would talk about VAE. Given that I have previously written a <a href="https://kexue.fm/search/%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/">Variational Autoencoder series</a>, I thought it wouldn't be particularly difficult, so I agreed. However, on second thought, I found myself in a dilemma: how should I present it?</p>

<p>Regarding VAE, I previously wrote two systematic introductions: <a href="translation_5253.html">"Variational Autoencoder (I): So That's How It Is"</a> and <a href="translation_5343.html">"Variational Autoencoder (II): From a Bayesian Perspective"</a>. The latter is pure probabilistic derivation, which might not be meaningful or easily understood by those not doing theoretical research. While the former is simpler, it is also somewhat inadequate because it explains things from the perspective of generative models without clearly explaining "why VAE is needed" (to put it plainly, VAE can result in a generative model, but VAE is not necessarily just for generative models), and the overall style is not particularly friendly.</p>

<p>I thought about it, and for most readers who don't understand VAE but want to use it, they probably only want a rough understanding of the form of VAE and want to know the answers to questions like "What is the role of VAE?", "What is the difference between VAE and AE?", and "In what scenarios is VAE needed?". The above two articles cannot satisfy these needs well. Therefore, I tried to conceive a geometric picture of VAE, attempting to describe the key characteristics of VAE from a geometric perspective, which I would like to share with everyone here.</p>

<h2>Autoencoder</h2>

<p>We start with the Autoencoder (AE). The original intention of the autoencoder was for data dimension reduction. Suppose the original feature $x$ has too high a dimension; we hope to encode it into a low-dimensional feature vector $z=E(x)$ through an encoder $E$. The principle of encoding is to retain original information as much as possible, so we train a decoder $D$, hoping to reconstruct the original information through $z$, i.e., $x \approx D(E(x))$. The optimization objective is generally:</p>

\[E,D = \text{argmin}_{E,D} \mathbb{E}_{x \sim \mathcal{D}} [\|x - D(E(x))\|^2]\]

<p>The corresponding schematic diagram is as follows:</p>

<p><a href="https://kexue.fm/usr/uploads/2020/09/2808850132.png"><img src="https://kexue.fm/usr/uploads/2020/09/2808850132.png" alt="Autoencoder Schematic" title="Click to view original image"></a></p>
<p style="text-align: center;">Autoencoder Schematic</p>

<h2>Coding Space</h2>

<p>If every sample can be reconstructed well, then we can consider $z$ as an equivalent representation of $x$. In other words, studying $z$ well is equivalent to studying $x$ well. Now we encode each $x$ into a corresponding feature vector $z$, and then we are concerned with a question: what does the space covered by these $z$ "look like"?</p>

<p><a href="https://kexue.fm/usr/uploads/2020/09/3960764387.png"><img src="https://kexue.fm/usr/uploads/2020/09/3960764387.png" alt="After Autoencoder, sample corresponds to a point in latent space" title="Click to view original image"></a></p>
<p style="text-align: center;">After an autoencoder, each original sample corresponds to a point in the coding space.</p>

<p>Why care about this question? Because we can have many different encoding methods, and the feature vectors obtained by different encoding methods vary in quality. From "what the coding space looks like," we can roughly see the quality of the feature vectors. For example, below are four simulation diagrams of the distribution shapes of different encoding vectors:</p>

<p><a href="https://kexue.fm/usr/uploads/2020/09/2840260916.png"><img src="https://kexue.fm/usr/uploads/2020/09/2840260916.png" alt="Four different coding space shapes" title="Click to view original image"></a></p>
<p style="text-align: center;">Four simulation diagrams of different coding space shapes, representing irregular, linear, ring-like, and circular distributions respectively.</p>

<p>The vector distribution in the first image has no special shape and is quite scattered, indicating that the coding space is not particularly regular. The vectors in the second image are concentrated on a line, indicating redundancy between the dimensions of the encoding vectors. The third image is a ring, indicating that there are no corresponding real samples near the center of the circle. The fourth image is a circle, indicating that it regularly covers a continuous space. Looking at the four images, we believe the vector distribution shape depicted in the last image is the most ideal: regular, non-redundant, and continuous. This means that if we learn a portion of the samples from it, it is easy to generalize to unknown new samples, because we know the coding space is regular and continuous. Therefore, we know that the "gaps" between the encoding vectors of training samples (the blank parts between two points in the figure) actually also correspond to unknown real samples. Thus, by handling the known ones well, it is likely that the unknown ones are also handled well.</p>

<h2>From Point to Area</h2>

<p>In general, we are concerned about the following questions regarding the coding space:</p>

<blockquote>
    1. What kind of region do all encoding vectors cover?<br>
    2. Are there unknown real samples corresponding to the vectors in the blank spaces?<br>
    3. Are there any vectors that have "lost touch with the crowd"?<br>
    4. Is there a way to make the coding space more regular?
</blockquote>

<p>A conventional autoencoder has no special constraints, so it is difficult to answer the above questions. Thus, the Variational Autoencoder (VAE) emerged. From an encoding perspective, its purpose is to: <b>1. Make the coding space more regular; 2. Make the encoding vectors more compact.</b> To achieve this goal, the Variational Autoencoder first introduces a posterior distribution $p(z|x)$.</p>

<p>For readers who do not want to delve into probabilistic language, how should they understand the posterior distribution $p(z|x)$? Intuitively, we can understand the posterior distribution as an "ellipse." Originally, each sample corresponded to an encoding vector, which is a point in the coding space; after introducing the posterior distribution, it is equivalent to saying that now each sample $x$ corresponds to an "ellipse." We just mentioned that we hope the encoding vectors are more "compact," but theoretically speaking, no matter how many "points" there are, they cannot cover a "surface." However, if we use "surfaces" to cover a "surface," it is easy to cover the target. This is one of the main changes made by the Variational Autoencoder.</p>

<p><a href="https://kexue.fm/usr/uploads/2020/09/2603393496.png"><img src="https://kexue.fm/usr/uploads/2020/09/2603393496.png" alt="From point to ellipse" title="Click to view original image"></a></p>
<p style="text-align: center;">The coding of each sample changes from a point to an area (ellipse), so the coding space originally covered by points becomes covered by areas.</p>

<p>Readers might ask, why must it be an ellipse? Can it be a rectangle or other shapes? Returning to probabilistic language, an ellipse corresponds to the "assumption that the components of $p(z|x)$ are independent Gaussian distributions." From a probabilistic point of view, the Gaussian distribution is a relatively easy class of probability distributions to handle, so we use the Gaussian distribution, which corresponds to an ellipse. Other shapes would correspond to other distributions; for example, a rectangle could correspond to a uniform distribution, but it would be more troublesome when calculating KL divergence later, so it is generally not used.</p>

<h2>Sampling Reconstruction</h2>

<p>Now each sample $x$ corresponds to an "ellipse," and determining an "ellipse" requires two pieces of information: the center of the ellipse and the axial lengths. They each constitute a vector, and these vectors depend on the sample $x$, which we denote as $\mu(x), \sigma(x)$. Since the entire ellipse corresponds to sample $x$, we require that any point within the ellipse can reconstruct $x$, so the training target is:</p>

\[\mu,\sigma,D = \text{argmin}_{\mu,\sigma,D} \mathbb{E}_{x \sim \mathcal{D}} [\|x - D(\mu(x) + \epsilon \otimes \sigma(x))\|^2], \quad \epsilon \sim \mathcal{N}(0, I)\]

<p>Where $\mathcal{D}$ is the training data, and $\mathcal{N}(0, I)$ is the standard normal distribution. We can understand it as a unit circle. In other words, we first sample $\epsilon$ from the unit circle, and then transform it into a point inside an ellipse with "center $\mu(x)$ and axial length $\sigma(x)$" through the translation and scaling transformation $\mu(x) + \epsilon \otimes \sigma(x)$. This process is the so-called "Reparameterization."</p>

<p>Here, $\mu(x)$ actually corresponds to the encoder $E(x)$ in the autoencoder, and $\sigma(x)$ corresponds to the range it can generalize to.</p>

<h2>Space Regularization</h2>

<p>Finally, while the "ellipse" can "make the encoding vectors more compact," it cannot yet "make the coding space more regular." Now we want the encoding vectors to satisfy the standard normal distribution (which can be understood as a unit circle), i.e., the space covered by all ellipses together forms a unit circle.</p>

<p>To this end, we hope that each ellipse can move closer to the unit circle. The center of the unit circle is 0 and the radius is 1, so a basic idea is to introduce a regularization term:</p>

\[\mathbb{E}_{x \sim \mathcal{D}} [\|\mu(x) - 0\|^2 + \|\sigma(x) - 1\|^2]\]

<p>In fact, combining these two loss terms already makes it very close to the standard Variational Autoencoder. The standard Variational Autoencoder uses a slightly more complex regularization term with similar functionality:</p>

\[\mathbb{E}_{x \sim \mathcal{D}} \left[ \sum_{i=1}^d \frac{1}{2}(\mu_i^2(x) + \sigma_i^2(x) - \log \sigma_i^2(x) - 1) \right]\]

<p>This regularization term originates from the KL divergence between two Gaussian distributions, so it is also commonly called the "KL divergence term."</p>

<p><a href="https://kexue.fm/usr/uploads/2020/09/783775597.png"><img src="https://kexue.fm/usr/uploads/2020/09/783775597.png" alt="VAE Schematic" title="Click to view original image"></a></p>
<p style="text-align: center;">Variational Autoencoder Schematic</p>

<p>Combining the two targets yields the final Variational Autoencoder:</p>

\[\|x - D(\mu(x) + \epsilon \otimes \sigma(x))\|^2 + \sum_{i=1}^d \frac{1}{2}(\mu_i^2(x) + \sigma_i^2(x) - \log \sigma_i^2(x) - 1), \quad \epsilon \sim \mathcal{N}(0, I)\]

<h2>Article Summary</h2>

<p>This article introduced an understanding of the Variational Autoencoder (VAE) from the perspective of geometric analogy. From this viewpoint, the goal of the Variational Autoencoder is to make the encoding vectors more compact and regulate the encoding distribution to be a standard normal distribution (unit circle).</p>

<p>In this way, VAE can achieve two effects: 1. By randomly sampling a vector from the standard Gaussian distribution (unit circle), one can obtain a real sample through the decoder, thus realizing a generative model; 2. Due to the compactness of the coding space and the noise added to the encoding vectors during training, the components of the encoding vector can achieve a certain degree of decoupling and be endowed with certain linear operation properties.</p>

<p>The geometric perspective allows us to quickly grasp the key characteristics of the Variational Autoencoder and reduces the difficulty of entry, but it also has certain inaccuracies. If there are any inappropriate parts, I hope readers can understand and point them out.</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="translation_7725.html" style="color: #005fcc;">https://kexue.fm/archives/7725</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
