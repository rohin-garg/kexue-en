
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    packages: {'[+]': ['ams']}
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
    <nav style="margin-bottom: 1.5em;">
    <a href="../index.html" style="display: inline-flex; align-items: center; color: #555; text-decoration: none; font-size: 0.95em;">
        <span style="margin-right: 0.3em;">&larr;</span> Back to Index
    </a>
</nav>

    <h1><a href="https://kexue.fm/archives/7980">Optimization Algorithms from a Dynamic Perspective (VI): Why Doesn't SimSiam Collapse?</a></h1>
    <p>By 苏剑林 | December 11, 2020</p>

    <p>Since <a href="https://papers.cool/arxiv/2002.05709">SimCLR</a>, work on unsupervised feature learning in CV (Computer Vision) has emerged endlessly, making it hard to keep up. Most of these works are based on contrastive learning, which involves categorical learning by constructing positive and negative samples in appropriate ways. However, among many similar works, there are always some unique ones, such as Google's <a href="https://papers.cool/arxiv/2006.07733">BYOL</a> and the more recent <a href="https://papers.cool/arxiv/2011.10556">SimSiam</a>. They propose schemes that can complete feature learning relying only on positive samples, which feels refreshing. But without the support of negative samples, why doesn't the model collapse to a meaningless constant model? This is the most thought-provoking question in these two papers.</p>

    <p>SimSiam provides an answer that many have praised, but I feel that SimSiam only changes the way the question is phrased without truly solving it. I believe the success of models like SimSiam and GAN is largely due to the use of gradient-based optimizers (rather than other stronger or weaker optimizers). Therefore, any answer that doesn't integrate optimization dynamics is incomplete. Here, I try to analyze the reason why SimSiam does not collapse by combining it with dynamics.</p>

    <h2>SimSiam</h2>

    <p>Before looking at SimSiam, we can first look at BYOL from the paper <a href="https://papers.cool/arxiv/2006.07733">"Bootstrap your own latent: A new approach to self-supervised Learning"</a>. Its learning process is simple: maintain two encoders, Student and Teacher, where the Teacher is an exponential moving average (EMA) of the Student, and the Student in turn learns from the Teacher. It feels like "stepping on your left foot with your right foot to fly up." The schematic is as follows:</p>

    <p style="text-align:center;"><img src="https://kexue.fm/usr/uploads/2020/12/3252086111.png" alt="BYOL Schematic"></p>

    <p>SimSiam, from the paper <a href="https://papers.cool/arxiv/2011.10566">"Exploring Simple Siamese Representation Learning"</a>, is even simpler. It directly removes the moving average of BYOL:</p>

    <p style="text-align:center;"><img src="https://kexue.fm/usr/uploads/2020/12/4113333306.png" alt="SimSiam Schematic"></p>

    <p>In fact, SimSiam is equivalent to setting the moving average parameter $\tau$ of BYOL to 0, which shows that the moving average is not strictly necessary. To find the key parts of the algorithm, SimSiam also conducted many comparative experiments, confirming that the <code>stop_gradient</code> operator and the predictor module $h_{\varphi}(z)$ are key to SimSiam's non-collapse. To explain this phenomenon, SimSiam proposed that the optimization process is actually equivalent to alternating optimization of:
    \begin{equation}\mathcal{L}(\theta, \eta)=\mathbb{E}_{x, \mathcal{T}}\left[\left\|\mathcal{F}_{\theta}(\mathcal{T}(x))-\eta_{x}\right\|^2\right]\label{eq:simsiam}\end{equation}
    where $x$ represents the training samples and $\mathcal{T}$ represents data augmentation. There are already many interpretations of this part online, and reading the original paper is not difficult, so I won't expand on it in detail.</p>

    <h2>Dynamic Analysis</h2>

    <p>However, I believe that translating the understanding of the SimSiam algorithm into an understanding of the alternating optimization of $\mathcal{L}(\theta, \eta)$ is merely a change of terminology and does not provide a substantive answer. This is because, clearly, $\mathcal{L}(\theta, \eta)$ also has a collapsed solution: the model could simply let all $\eta_{x}$ equal the same vector and then have $\mathcal{F}_{\theta}$ output the same constant vector. If we don't answer why the alternating optimization of $\mathcal{L}(\theta, \eta)$ doesn't collapse, we haven't answered the question.</p>

    <p>Below, I will list what I consider to be the key factors in SimSiam's non-collapse and demonstrate through a simple example that answering the reason for non-collapse needs to be combined with dynamics. Of course, my discourse in this part is also incomplete and perhaps not even rigorous; it's simply offering a new perspective to "cast a brick to attract jade."</p>

    <h3>Deep Image Prior</h3>

    <p>First, people discovered long ago that a randomly initialized CNN model can be directly used to extract visual features, and the effect is not particularly bad. This conclusion can be traced back to the 2009 paper <a href="https://ieeexplore.ieee.org/document/5459469">"What is the best multi-stage architecture for object recognition?"</a>. This can be understood as CNNs having an innate ability to process images. Later, this characteristic was given a high-sounding name called "Deep Image Prior," from the paper <a href="https://papers.cool/arxiv/1711.10925">"Deep Image Prior"</a>. It performed some experiments showing that starting from a randomly initialized CNN model, tasks like image completion and denoising can be accomplished without any supervised learning, further confirming the property that CNNs naturally possess the ability to process images.</p>

    <p>According to my understanding, the "Deep Image Prior" stems from three points:</p>

    <blockquote>
        1. <b>Continuity of images</b>: This means that images themselves can be directly viewed as continuous vectors without needing to learn an Embedding layer like in NLP. This means we can perform many tasks using simple methods like "original image + K-nearest neighbors";<br>
        2. <b>CNN architectural prior</b>: This refers to the local receptive field design of CNNs, which well simulates the visual processing of the human eye. Since the visual classification results we provide are based on our own vision, the two are consistent;<br>
        3. <b>Good initialization</b>: This is not hard to understand. Even the best model won't work with zero initialization. My previous article <a href="translation_7180.html">"Understanding Model Parameter Initialization Strategies from a Geometric Perspective"</a> also briefly discussed initialization methods. From a geometric perspective, mainstream initialization methods are a type of approximate "orthogonal transformation," which can preserve the information of input features as much as possible.
    </blockquote>

    <h3>The Dynamics of Non-Collapse</h3>

    <p>Again, the Deep Image Prior means that a randomized CNN model is a "not-so-bad" encoder from the start. Thus, what we need to do next can be summarized into two points: learn in a better direction, and don't collapse toward a constant.</p>

    <p>Learning in a better direction involves designing certain prior signals to better integrate prior knowledge into the model. SimSiam, BYOL, etc., use two different data augmentations for the same image and make their corresponding feature vectors as similar as possible. This is a good signal guidance, telling the model that simple transformations should not affect our visual understanding. In fact, this is one of the designs used by all contrastive learning methods.</p>

    <p>The difference lies in "not collapsing toward a constant." General contrastive learning methods use negative samples to tell the model which images' features should not be similar, thereby preventing collapse. However, SimSiam and BYOL are different; they have no negative samples. In reality, they prevent collapse by decomposing the model's optimization process into two synchronous but differently paced modules. Taking SimSiam as an example, its optimization objective can be written as:
    \begin{equation}\mathcal{L}(\varphi, \theta)=\mathbb{E}_{x, \mathcal{T}_1,\mathcal{T}_2}\Big[l\left(h_{\varphi}(f_{\theta}(\mathcal{T}_1(x))), f_{\theta}(\mathcal{T}_2(x))\right)\Big]\end{equation}
    Then, using gradient descent for optimization, the corresponding dynamic equations are:
    \begin{equation}\begin{aligned}
    \frac{d\varphi}{dt} = - \frac{\partial\mathcal{L}}{\partial \varphi} =& -\mathbb{E}_{x, \mathcal{T}_1,\mathcal{T}_2}\bigg[\frac{\partial l}{\partial h}\frac{\partial h}{\partial \varphi}\bigg]\\
    \frac{d\theta}{dt} = - \frac{\partial\mathcal{L}}{\partial \theta} =& -\mathbb{E}_{x, \mathcal{T}_1,\mathcal{T}_2}\bigg[\frac{\partial l}{\partial h}\frac{\partial h}{\partial f}\frac{\partial f}{\partial \theta} \color{skyblue}{\,+\underbrace{\frac{\partial l}{\partial f}\frac{\partial f}{\partial \theta}}_{\substack{\text{SimSiam}\\\\text{removed this}}}}\bigg]
    \end{aligned}\end{equation}
    The above formula indicates the difference brought by the presence or absence of the <code>stop_gradient</code> operator. Simply put, if the <code>stop_gradient</code> operator is added, then $\frac{d\theta}{dt}$ loses the second term. In this case, $\frac{d\varphi}{dt}$ and $\frac{d\theta}{dt}$ both share the factor $\frac{\partial l}{\partial h}$. Since $h_{\varphi}$ is closer to the output layer and the initialized $f_{\theta}$ is already a good encoder, at the start of learning, $h_{\varphi}$ will be optimized faster, while the parts closer to the input optimize slower. In other words, $\frac{d\varphi}{dt}$ is the fast dynamic component, while $\frac{d\theta}{dt}$ is the slow dynamic component. Relatively speaking, $\frac{d\varphi}{dt}$ will converge to 0 more quickly, which means $\frac{\partial l}{\partial h}$ will become very small very fast. Since $\frac{d\theta}{dt}$ also contains the term $\frac{\partial l}{\partial h}$, $\frac{d\theta}{dt}$ also becomes small. Before it can collapse, the force driving it to collapse has become negligible, so it does not collapse. Conversely, if there were the second term $\frac{\partial l}{\partial f}\frac{\partial f}{\partial \theta}$ (whether added back or if only this term were kept), it would be equivalent to adding a "fast track," making it a fast term. Even if $\frac{\partial l}{\partial h}=0$, the presence of the second term would still continue to drive it toward collapse.</p>

    <p>To give a simple specific example, consider:
    \begin{equation}l = \frac{1}{2}(\varphi\theta - \theta)^2\end{equation}
    For simplicity, let $\varphi, \theta$ both be scalars. The corresponding dynamic equations are:
    \begin{equation}\frac{d\varphi}{dt}=-(\varphi\theta - \theta)\theta, \quad \frac{d\theta}{dt}=-(\varphi\theta - \theta) \varphi \color{skyblue}{+ \underbrace{(\varphi\theta - \theta)}_{\substack{\text{SimSiam}\\\\text{removed this}}}}\end{equation}
    Suppose $\varphi(0)=0.6, \theta(0)=0.1$ (chosen arbitrarily). The evolution of both is:</p>

    <table style="width:100%; text-align:center;">
        <tr>
            <td><img src="https://kexue.fm/usr/uploads/2020/12/1792942484.png" alt="Stop Gradient for Second Theta"><br>Stopped gradient for second $\theta$</td>
            <td><img src="https://kexue.fm/usr/uploads/2020/12/575344317.png" alt="Did not stop gradient for second Theta"><br>Did not stop gradient for second $\theta$</td>
        </tr>
    </table>

    <p>As can be seen, after stopping the gradient of the second $\theta$, the equations for $\varphi$ and $\theta$ are quite consistent; $\varphi$ quickly tends toward 1, while $\theta$ stabilizes at a non-zero value (meaning no collapse). Conversely, if the second term in $\frac{d\theta}{dt}$ is added, or even if only the second term is kept, the result is that $\theta$ quickly tends toward 0 and $\varphi$ fails to tend toward 1. This means the dominance is taken by $\theta$.</p>

    <p>This example itself may not be very persuasive, but it simply reveals the changes in the dynamics:</p>

    <blockquote>
        The introduction of the predictor ($\varphi$) splits the model's dynamics into two major parts, and the inclusion of the <code>stop_gradient</code> operator makes the encoder part ($\theta$)'s dynamics slower and enhances the synchronization between the encoder and predictor. In this way, the predictor fits the target with "lightning speed," such that the optimization process stops before the encoder has time to collapse.
    </blockquote>

    <h2>Looking at Approximate Expansion</h2>

    <p>Of course, there are a thousand interpretations, and they are all "hindsight." The ones who are truly great are the discoverers; at most, we are just riding the coattails. Here, I'll ride a bit more by sharing another perspective on SimSiam. As mentioned at the beginning, the SimSiam paper proposed explaining SimSiam through the alternating optimization of the objective in $\eqref{eq:simsiam}$. This perspective starts from the objective in $\eqref{eq:simsiam}$ and further investigates the reason for its non-collapse.</p>

    <p>If $\theta$ is fixed, for the objective $\eqref{eq:simsiam}$, it is easy to solve for the optimal value of $\eta_x$ as:
    \begin{equation}\eta_x=\mathbb{E}_{\mathcal{T}}\left[\mathcal{F}_{\theta}(\mathcal{T}(x))\right]\end{equation}
    Substituting this back into $\eqref{eq:simsiam}$, we get the optimization objective as:
    \begin{equation}\mathcal{L}(\theta)=\mathbb{E}_{x, \mathcal{T}}\bigg[\left\|\mathcal{F}_{\theta}(\mathcal{T}(x))-\mathbb{E}_{\mathcal{T}}\left[\mathcal{F}_{\theta}(\mathcal{T}(x))\right]\right\|^2\bigg]\end{equation}
    If we assume that $\mathcal{T}(x)-x$ is a "small" vector, then performing a first-order expansion at $x$ gives:
    \begin{equation}\mathcal{L}(\theta)\approx\mathbb{E}_{x, \mathcal{T}}\bigg[\left\|\frac{\partial \mathcal{F}_{\theta}(x)}{\partial x}\big(\mathcal{T}(x)-\bar{x}\big)\right\|^2\bigg]\label{eq:em-sim}\end{equation}
    where $\bar{x}=\mathbb{E}_{\mathcal{T}}\left[\mathcal{T}(x)\right]$ is the average result of the same image under all data augmentation methods. Note that it usually does not equal $x$. Similarly, for a version of SimSiam without <code>stop_gradient</code> and without a predictor, the loss function is approximately:
    \begin{equation}\mathcal{L}(\theta)\approx\mathbb{E}_{x, \mathcal{T}_1, \mathcal{T}_2}\bigg[\left\|\frac{\partial \mathcal{F}_{\theta}(x)}{\partial x}\big(\mathcal{T}_2(x)-\mathcal{T}_1(x)\big)\right\|^2\bigg]\label{eq:em-sim-2}\end{equation}
    In equation $\eqref{eq:em-sim}$, each $\mathcal{T}(x)$ is subtracted by $\bar{x}$, and it can be proven that this choice minimizes the loss function. In equation $\eqref{eq:em-sim-2}$, each $\mathcal{T}_1(x)$ is subtracted by another augmented result $\mathcal{T}_2(x)$, which causes both the loss function itself and the variance of its estimate to increase significantly.</p>

    <p>Does this mean that the reason why not using <code>stop_gradient</code> and not using a predictor fails is because the loss function and its variance are too large? Noticing that under the first-order approximation, $\eta_x\approx \mathcal{F}_{\theta}(\bar{x})$, if the optimization objective is changed to:
    \begin{equation}\mathcal{L}(\theta)=\mathbb{E}_{x, \mathcal{T}}\bigg[\left\|\mathcal{F}_{\theta}(\mathcal{T}(x))-\mathcal{F}_{\theta}(\bar{x})\right\|^2\bigg]\end{equation}
    would it still not collapse? I have not verified this and do not know. Readers who are currently studying related content might want to verify it. This also leads to a related question: for an encoder trained this way, is it better to use $\mathcal{F}_{\theta}(x)$ or $\mathcal{F}_{\theta}(\bar{x})$ as the feature?</p>

    <p>Of course, this part of the discussion is built on the assumption that "$\mathcal{T}(x)-x$ is a small vector." If it doesn't hold, then this section is in vain.</p>

    <h2>Summary</h2>

    <p>This article attempts to provide my understanding of why the BYOL and SimSiam algorithms do not collapse from a dynamic perspective. Unfortunately, halfway through writing, I realized that some of the analyses I had conceived could not be made self-consistent, so I deleted some content and added a new angle, trying to ensure the article didn't "end poorly." As for quality, that's another matter. I am sharing this as a note here and hope readers will be tolerant and offer corrections if there are any inadequacies.</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/7980" style="color: #005fcc;">https://kexue.fm/archives/7980</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
