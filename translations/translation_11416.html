
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    packages: {'[+]': ['base', 'ams', 'noerrors', 'noundefined']},
    tags: 'ams'
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  },
  loader: {load: ['[tex]/ams']}
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<article>
    <nav style="margin-bottom: 1.5em;">
    <a href="../index.html" style="display: inline-flex; align-items: center; color: #555; text-decoration: none; font-size: 0.95em;">
        <span style="margin-right: 0.3em;">&larr;</span> Back to Index
    </a>
</nav>

    <h1><a href="https://kexue.fm/archives/11416">Muon Optimizer Guide: Quick Start and Key Details</a></h1>
    <p>By 苏剑林 | November 19, 2025</p>

    <p>Recently, many readers have likely come across news regarding the Muon optimizer. In fact, Muon was first proposed about a year ago, around October last year, by <a href="https://x.com/kellerjordan0/status/1842300916864844014">Keller Jordan</a> on Twitter. However, within just this year, Muon has already undergone the test of training models with tens of billions, hundreds of billions, and even trillions of parameters, indicating it is a highly competitive optimizer.</p>

    <p>Nowadays, Muon has been built into training frameworks like <a href="https://docs.pytorch.org/docs/stable/generated/torch.optim.Muon.html">Torch</a> and <a href="https://keras.io/api/optimizers/muon/">Keras</a>, and even large-scale frameworks like <a href="https://github.com/NVIDIA/Megatron-LM/blob/dev/megatron/core/optimizer/muon.py">Megatron</a> are gradually starting to support it, meaning it has gained widespread industry recognition. However, for readers only familiar with Adam, how to quickly and effectively switch to Muon may still be a confusing matter. Therefore, this article attempts to provide a quick-start tutorial.</p>

    <h2>Brief Introduction</h2>
    <p>The formal proposer of Muon is <a href="https://x.com/kellerjordan0/status/1842300916864844014">Keller Jordan</a>, who currently works at OpenAI. As mentioned at the beginning, Muon was first published on Twitter, and even now, the author has only written a blog post <a href="https://kellerjordan.github.io/posts/muon/">"Muon: An optimizer for hidden layers in neural networks"</a> rather than a formal paper. The author's view is that "whether it is written as a paper has nothing to do with whether the optimizer is effective [<a href="https://x.com/kellerjordan0/status/1890178773586489716">original text</a>]".</p>

    <p>Muon is an optimizer specifically tailored for matrix parameters. There are other related works with similar characteristics, such as <a href="https://papers.cool/arxiv/1802.09568">Shampoo</a> and the earlier <a href="translation_10592.html">Stochastic Spectral Descent</a>, etc. Many works can more or less be associated with Muon, but none completely cover Muon, so in my view, Muon is a brand-new work.</p>

    <p>In China, the first article to popularize Muon was likely my blog post <a href="translation_10592.html">"Muon Optimizer Appreciation: A Fundamental Leap from Vectors to Matrices"</a>, and the first verification of Muon on a relatively large scale was likely the <a href="https://papers.cool/arxiv/2502.16982">Moonlight</a> we released in February. The Muon variant proposed in Moonlight was later used in the trillion-parameter <a href="https://papers.cool/arxiv/2507.20534">K2</a>. Following K2, <a href="https://papers.cool/arxiv/2508.06471">GLM-4.5</a> also utilized this Muon variant.</p>

    <p>Consistent with what Jeremy Bernstein, one of the authors of Muon, said in his blog <a href="https://jeremybernste.in/writing/deriving-muon">"Deriving Muon"</a>, the uniqueness of Muon for me lies in the fact that it can be derived from more fundamental optimization principles and is effective in practice. In contrast, while Adam is also very effective, it feels more like a heuristic solution.</p>

    <h2>Four Versions</h2>
    <p>This article does not intend to introduce the mathematical details of Muon, nor its implementation, but rather focuses on the technical details and precautions for switching from Adam to Muon. As stated, Muon is dedicated to matrix parameter optimization and uses a non-element-wise update rule, which can be confusing for new users.</p>

    <p>Furthermore, as far as I know, there are currently at least four slightly different versions of Muon, and this multi-version phenomenon contributes to the confusion. If users do not understand the details, they might achieve poor results due to incorrect hyperparameter tuning (especially the learning rate). Below, I will clarify these contents. First, for a matrix $\boldsymbol{W} \in \mathbb{R}^{d_{in} \times d_{out}}$, where $\boldsymbol{G}$ is its gradient, the four Muon variants are:</p>

    \begin{align}\newcommand{\msign}{\mathop{\text{msign}}}
    \boldsymbol{M}_t =&\, \beta \boldsymbol{M}_{t-1} + \boldsymbol{G}_t \\[7pt]
    \boldsymbol{W}_t =&\, \boldsymbol{W}_{t-1} - \eta_t \left(\msign(\boldsymbol{M}_t) + \lambda \boldsymbol{W}_{t-1}\right) \quad &\color{skyblue}{(\text{Naive Version})} \\[5pt]
    \boldsymbol{W}_t =&\, \boldsymbol{W}_{t-1} - \eta_t \left(\sqrt{\max(1, d_{out}/d_{in})}\msign(\boldsymbol{M}_t) + \lambda \boldsymbol{W}_{t-1}\right) \quad &\color{skyblue}{(\text{KellerJordan Version})} \\[5pt]
    \boldsymbol{W}_t =&\, \boldsymbol{W}_{t-1} - \eta_t \left(\sqrt{ d_{out}/d_{in}}\msign(\boldsymbol{M}_t) + \lambda \boldsymbol{W}_{t-1}\right) \quad &\color{skyblue}{(\text{MuP Version})} \\[5pt]
    \boldsymbol{W}_t =&\, \boldsymbol{W}_{t-1} - \eta_t \left(0.2\times\sqrt{\max(d_{out},d_{in})}\msign(\boldsymbol{M}_t) + \lambda \boldsymbol{W}_{t-1}\right) \quad &\color{skyblue}{(\text{Moonlight Version})}
    \end{align}

    <p>If Nesterov momentum is used, $\msign(\boldsymbol{M}_t)$ is replaced by $\msign(\beta\boldsymbol{M}_t + \boldsymbol{G}_t)$. The $\msign$ is usually named <code>zeropower_via_newtonschulz</code> in implementations; ordinary users do not need to worry about the specific implementation details.</p>

    <p>The only difference between the four versions is the scaling factor before $\msign$. The "KellerJordan Version" and "MuP Version" are largely similar, while the "Moonlight Version" is slightly more special. Keras only implements the "KellerJordan Version," while Torch implements both the "KellerJordan Version" and the "Moonlight Version." The Naive version is currently rare, and for me, I often use my own "MuP Version."</p>

    <h2>Two Dimensions</h2>
    <p>An important detail to note here is that the "KellerJordan Version" and "MuP Version" are sensitive to the order of $d_{in}, d_{out}$. The first task is to clarify the meaning of $d_{in}, d_{out}$; it is not the case that the first dimension of a matrix is always $d_{in}$ and the second is always $d_{out}$.</p>

    <p>The meanings of $d_{in}$ and $d_{out}$ are the input and output dimensions of the linear layer, respectively. Which is $d_{in}$ and which is $d_{out}$ depends on the specific implementation of the linear layer. For example, Keras's Dense layer implementation is $\boldsymbol{x}\boldsymbol{W}$, so the first dimension of the matrix $\boldsymbol{W}$ is $d_{in}$ and the second is $d_{out}$. However, Torch's Linear layer implements $\boldsymbol{x}\boldsymbol{W}^{\top}$, so the second dimension of the matrix $\boldsymbol{W}$ is $d_{in}$ and the first dimension is $d_{out}$.</p>

    <p>Therefore, if implementing the "KellerJordan Version" of Muon for Torch's Linear layer, the scaling factor should be <code>max(1, W.shape[0]/W.shape[1])**0.5</code>, while for Keras, it should be <code>max(1, W.shape[1]/W.shape[0])**0.5</code>. Consequently, the current Keras implementation of Muon is actually incorrect because it copied the Torch scaling factor implementation verbatim (<a href="https://github.com/keras-team/keras/blob/v3.12.0/keras/src/optimizers/muon.py#L198">source code</a>).</p>

    <p>If you have written your own model, you need to judge carefully based on your writing style. For instance, it's possible in Torch to mix built-in Linear layers with hand-written <code>x @ W</code>, so one cannot generalize whether it is <code>W.shape[0]/W.shape[1]</code> or <code>W.shape[1]/W.shape[0]</code>. Of course, if you find it too troublesome to figure these out, you can consider using the "Moonlight Version," as its scaling factor is symmetric with respect to $d_{in}$ and $d_{out}$.</p>

    <h2>Hyperparameter Settings</h2>
    <p>Once $d_{in}, d_{out}$ are clarified, the remaining questions are how to set the learning rate $\eta_t$ and the weight decay coefficient $\lambda$. The assumption here is that the user already has experience tuning Adam and has obtained good results, and wants to quickly migrate to Muon to experience it.</p>

    <p>Let's look at the "Moonlight Version" first. Its scaling factor was obtained by aligning with Adam's Update RMS. For more details, you can refer to <a href="translation_10739.html">"Muon Sequel: Why Do We Choose to Try Muon?"</a>. Regarding the "Magic Number" $0.2$, you can refer to <a href="translation_11267.html">"Why is Adam's Update RMS 0.2?"</a>. In simple terms, the "Moonlight Version" of Muon aligns with Adam's update magnitude, so the simplest approach when migrating from Adam is: <strong>change nothing</strong>, just use Adam's $\eta_t$ and $\lambda$.</p>

    <p>Now look at the remaining three versions. We know that mainstream models usually have a hidden_size (denoted as $d$), and the matrix shapes of most models do not deviate significantly from $d \times d$. Therefore, we can approximate this with $d_{in}=d_{out}=d$, in which case these three versions are identical. Compared to the "Moonlight Version," they lack the $0.2\sqrt{d}$ factor. Since the "Moonlight Version" aligns with Adam's update magnitude and doesn't require changing hyperparameters, the learning rates of these three versions should be scaled up by $0.2\sqrt{d}$ to align with Adam's update magnitude; correspondingly, $\lambda$ should be divided by $0.2\sqrt{d}$.</p>

    <p>Substituting $d=1024, 2048, 4096$, the results are $6.4, 9, 12.8$, respectively. If you can't remember $0.2\sqrt{d}$, you can simply remember that if we use the other three versions of Muon, we <strong>directly multiply the Adam learning rate by 10</strong> to use as the Muon learning rate. If you directly plug Adam's learning rate into Muon, you will conclude that Muon is far inferior to Adam due to underfitting. As far as I know, some negative reviews of Muon stem from this.</p>

    <p>Does this mean the "Moonlight Version" is easier to use? The "Moonlight Version" indeed has good practical results, but saying it's better is evaluating it from the perspective of Adam. The benefit of the "MuP Version" or "KellerJordan Version" is that the learning rate is transferable; that is, after tuning the learning rate on a small model, applying it directly to a large model often yields good results. You can refer to Jeremy Bernstein's blog <a href="https://jeremybernste.in/writing/deriving-muon">"Deriving Muon"</a> or my blog <a href="translation_10795.html">"Higher-order MuP: Simpler but Smarter Spectral Condition Scaling"</a> for more on this.</p>

    <h2>Other Parameters</h2>
    <p>If Muon only handles matrix parameters, what happens to the rest? For example, the Bias terms of linear layers and the gamma terms of RMSNorm are 1D parameters; or perhaps 3D and 4D array parameters in convolutional layers.</p>

    <p>First, let me correct this: Muon does not handle all matrix parameters; Muon only handles "<strong>matrix parameters of linear layers with dense inputs</strong>." If this sounds confusing, just remember that the matrix parameters for the Embedding layer and the final classification layer (including GPT's LM Head) cannot use Muon, otherwise, the results will be significantly worse. For these matrix parameters that cannot use Muon, as well as 1D, 3D, and higher-dimensional parameters, if you don't want to overthink it, just use Adam. Basically, all Muon implementations are hybrid with Adam, allowing users to choose Adam for certain layers.</p>

    <p>If readers are willing to experiment, 3D and 4D parameters such as those in convolutional layers can also use Muon. Taking Conv2D as an example, the kernel shape is usually $(w, h, d_{in}, d_{out})$. Its equivalent implementation actually flattens the patch input of $(w, h, d_{in})$ into a vector of $w \times h \times d_{in}$, and the kernel is also reshaped to $(w \times h \times d_{in}, d_{out})$, followed by matrix multiplication. So, if it wants to use Muon, it must first reshape the momentum to $(w \times h \times d_{in}, d_{out})$, calculate $\msign$, and then reshape it back for the update.</p>

    <p>Similarly, for the gamma parameter of RMSNorm, which can be seen as multiplication by a diagonal matrix, its momentum can be treated as a diagonal matrix to calculate $\msign$, which results in something equivalent to SignSGDM. The Embedding layer can be viewed as multiple $(1,d)$ matrices calculating $\msign$, which results in Normalized SGDM (refer to <a href="translation_10592.html">"Muon Optimizer Appreciation: A Fundamental Leap from Vectors to Matrices"</a>). If you still want to tinker, consider Multi-Head Attention—could each head's projection matrix be taken out separately to calculate $\msign$?</p>

    <p>Life is endless, and so is tinkering~</p>

    <h2>Expected Results</h2>
    <p>Finally, if the user correctly sets everything according to the instructions above and runs it, they can begin to pray to the goddess of luck.</p>

    <p>What kind of result should we expect? In most cases, if there are no anomalies like gradient explosions, Muon will be slightly better than Adam. Of course, it is not ruled out that in some cases Muon might be slightly worse, but in any case, the gap between them will not be very large. If one side performs much better than the other, you may need to reflect on whether there is an issue with the settings on either side.</p>

    <p>However, nothing is absolute. For instance, under some extreme settings, Muon can indeed be much better than Adam, or Adam might fail no matter how you tune it. In short, good luck. If any interesting phenomena occur, you are welcome to exchange and analyze them with us.</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/11416" style="color: #005fcc;">https://kexue.fm/archives/11416</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
