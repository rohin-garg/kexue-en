
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams'
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
    <nav style="margin-bottom: 1.5em;">
    <a href="../index.html" style="display: inline-flex; align-items: center; color: #555; text-decoration: none; font-size: 0.95em;">
        <span style="margin-right: 0.3em;">&larr;</span> Back to Index
    </a>
</nav>

    <h1><a href="https://kexue.fm/archives/4564">School Starts! Let's do Cloze Tests ~ (iFLYTEK Cup)</a></h1>
    <p>By 苏剑林 | September 03, 2017</p>

    <h2>Preface</h2>
    <p>Starting this year, the CCL conference (Chinese Computational Linguistics) plans to hold evaluation activities concurrently. I have been interning at a startup recently, and the company signed up for this evaluation. The implementation task ended up falling on me. This year's task is reading comprehension, titled "The First 'iFLYTEK Cup' Chinese Machine Reading Comprehension Evaluation." Although it is called reading comprehension, the task is actually quite simple—it belongs to the <strong>Cloze Test</strong> type. Specifically, a blank is dug out of a passage, and you must select a word from the context to fill in this blank. Ultimately, our model ranked 6th among single systems, with an accuracy of 73.55% on the validation set and 75.77% on the test set. You can <a href="http://www.hfl-tek.com/cmrc2017/leaderboard.html">view the leaderboard here</a>. ("Guangzhou Flame Information Technology Co., Ltd." is the model described in this article.)</p>
    
    <p>In fact, this dataset and task format were proposed by the Harbin Institute of Technology (HIT) last year, so this evaluation was jointly organized by HIT and iFLYTEK. HIT's paper from last year, <a href="https://papers.cool/arxiv/1607.02250">"Consensus Attention-based Neural Networks for Chinese Reading Comprehension"</a>, studied another dataset with the same format but different content using common reading comprehension models (Common reading comprehension refers to finding the answer to a question from a passage; a cloze test can be considered a very small subset of general reading comprehension).</p>
    
    <p>Although the evaluation organizers tended to guide us toward understanding this as a reading comprehension problem, I feel that reading comprehension itself is much more difficult. This is just a cloze test, so we can treat it as such. Therefore, this article merely adopts a language model-like approach. The advantage of this approach is that the thinking is simple and direct, the computational cost is low (it can run with a batch size of 160 on my GTX1060), and it is easy to experiment with.</p>

    <h2>Model</h2>
    <p>Returning to the model, our design is relatively simple and closely follows the idea of "selecting a word from the context to fill in the blank," as shown in the schematic diagram below.</p>
    
    <p align="center">
        <a href="https://kexue.fm/usr/uploads/2017/09/3723793316.png">
            <img src="https://kexue.fm/usr/uploads/2017/09/3723793316.png" alt="Cloze Model" style="max-width:100%;">
        </a>
        <br>
        <span>Cloze Model</span>
    </p>

    <h3>Preliminary Analysis</h3>
    <p>First, it should be noted that this task involves selecting a word from the context to fill a missing position. For example:</p>
    
    <blockquote>
        <p>【Passage】</p>
        <p>1 ||| The Industry and Commerce Association reported that consumer confidence rose to 78.1 in December, significantly higher than 72 in November.</p>
        <p>2 ||| Additionally, according to the Wall Street Journal, 2013 was the best-performing year for the US stock market since 1995.</p>
        <p>3 ||| In this year, the wise practice for investing in the US stock market was to chase "dumb money."</p>
        <p>4 ||| The so-called "dumb money" XXXXX , in fact, is the ordinary strategy of buying and holding US stocks.</p>
        <p>5 ||| This strategy performed much better than the more complex investment methods used by hedge funds and other professional investors.</p>
        <p>【Question - Cloze type】</p>
        <p>The so-called "dumb money" XXXXX, in fact, is the ordinary strategy of buying and holding US stocks.</p>
        <p>【Answer】</p>
        <p>strategy</p>
    </blockquote>
    
    <p>Friends familiar with Natural Language Processing (NLP) will associate this task with language modeling. In fact, the task itself is similar to a language model but perhaps even simpler. A language model predicts the next word from the previous $n$ words, requiring an iteration over all words in the vocabulary. In contrast, this cloze task only requires picking from the context, which significantly narrows the search range. Of course, the focus of the two is different: language models are concerned with probability distribution, while cloze tests are concerned with prediction accuracy.</p>

    <h3>Context Encoding</h3>
    <p>Based on experience, LSTM works best for language modeling; therefore, we also use LSTM here. To better capture global semantic information, we stacked multiple layers of bidirectional LSTMs—this is standard procedure in NLP.</p>
    
    <p>First, we split the material using "XXXXX" into a prefix and a suffix. The prefix and suffix are sequentially input into the same bidirectional LSTM (calculated twice rather than concatenated once) to obtain their respective features. In other words, the prefix and suffix LSTMs share parameters. Why? Because when we read context ourselves, we use the same brain; there is no need to treat them differently. Once there is one layer of LSTM, multiple layers can be stacked. As for how many layers are suitable, it depends on the specific dataset. For this competition task, two layers showed significant improvement over a single layer, while three layers showed no improvement or even a slight decline.</p>
    
    <p>Finally, to obtain the feature vector of the entire material (used for the matching below), we simply concatenate the final state vectors of the bidirectional LSTM to get the feature vectors for the prefix and suffix, and then average the two vectors to get the global feature vector.</p>
    
    <p>(It is worth noting that if we switch to the <a href="https://github.com/ymcui/Chinese-RC-Dataset">dataset</a> from the paper <a href="https://papers.cool/arxiv/1607.02250">"Consensus Attention-based Neural Networks for Chinese Reading Comprehension"</a>—which has the same format but content from the People's Daily—and use the same model, the number of LSTM layers needs to be 3, and the final accuracy is 0.5% higher than the best result in that paper.)</p>

    <h3>Predicting Probabilities</h3>
    <p>The next question is: how to implement "searching within the context" instead of searching through the entire vocabulary?</p>
    
    <p>Recalling when we build language models, if we want to search the entire vocabulary, we build a fully connected layer where the number of nodes is the number of words in the vocabulary, and then use softmax to predict probability. We can view the fully connected layer this way: we assign a vector with the same dimension as the output feature to every word in the vocabulary, calculate the <strong>inner product</strong>, and apply softmax. That is, the pairing of features and words is achieved through the inner product. This provides a reference idea: if we make the feature output by the LSTM have the same dimension as the word vectors, and then perform an inner product between this feature and each input word vector in the context, we can then apply softmax. This achieves searching only within the context.</p>
    
    <p>I initially used this approach, but the accuracy only reached 69%–70%. After analysis, it appeared that after the original word vectors go through multiple layers of LSTM encoding, they actually move far away from the original word vector space. Instead of "traveling a long distance" to pair with the input word vectors, why not pair them directly with the intermediate state vectors of the LSTM? At least within the same LSTM layer, the state vectors are relatively close (meaning they are in the same vector space), and matching should be easier.</p>
    
    <p>Experiments confirmed my suspicion. With the improved model, the accuracy reached about 73%–74% on the official validation set and 75%–76% on the test set. After a further period of experimentation, there was no significant improvement, so this model was submitted.</p>

    <h3>Implementation Details</h3>
    <p>In fact, I am not very good at parameter tuning, so the parameters in the code below are not necessarily optimal. I look forward to tuning experts optimizing various parameters to yield even better results. I believe that even for the model described in this article, the results we provided were not yet optimal.</p>
    
    <p>Below are some important details in the implementation of the model:</p>
    
    <ul>
        <li>1. The corpus domain for this competition is fairy tales. We pre-trained Word2Vec word vectors using the training corpus and supplementary fairy tale corpus (refer <a href="translation_4385.html">here</a> for crawling methods), which were then used as input for the LSTM.</li>
        <li>2. To handle Out-of-Vocabulary (OOV) words, we generally set a padding symbol UNK (ID is 0 in the code). Since the word vectors are pre-trained with Word2Vec but UNK is not, only the word vector corresponding to UNK is allowed to be trained.</li>
        <li>3. Use <code>bidirectional_dynamic_rnn</code> to handle variable-length sequences.</li>
        <li>4. After the inner product in the final step, a large constant ($10^{12}$ in the code) must be subtracted from the inner products at padding positions before applying softmax and calling the <code>softmax_cross_entropy_with_logits</code> loss function. The reason is simple: the softmax of the inner product is the probability. To make the probability at padding positions zero, the corresponding inner product must be a very small negative number.</li>
        <li>5. If the target word appears multiple times in the context, the probability is spread across every occurrence. That is, the cross-entropy target is not necessarily in one-hot format. During final prediction, the probabilities of repeated words are summed up before sorting for the maximum.</li>
    </ul>

    <h2>Code</h2>

    <h3>Dataset</h3>
    <p>Dataset download: <a href="https://github.com/ymcui/cmrc2017">https://github.com/ymcui/cmrc2017</a></p>
    <p>The following code can also be viewed on my Github: <a href="https://github.com/bojone/CCL_CMRC2017">https://github.com/bojone/CCL_CMRC2017</a></p>

    <h3>Training Script</h3>

<pre><code>#! -*- coding:utf-8 -*-
# Experimental environment: tensorflow 1.2

import codecs
import re
import os
import numpy as np

def split_data(text):
    words = re.split('[ \n]+', text)
    idx = words.index('XXXXX')
    return words[:idx], words[idx+1:]

print u'Reading training corpus...'
# ... (rest of the script)
</code></pre>

</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/4564" style="color: #005fcc;">https://kexue.fm/archives/4564</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
