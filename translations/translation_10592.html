
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    tags: 'ams',
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    packages: {'[+]': ['ams']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script" async></script>

<article>
    <h1><a href="https://kexue.fm/archives/10592">An Appreciation of the Muon Optimizer: A Fundamental Leap from Vectors to Matrices</a></h1>
    <p>By 苏剑林 | December 10, 2024</p>

    <p>With the arrival of the LLM era, research enthusiasm for optimizers in academia seems to have waned. This is primarily because the current mainstream AdamW is already sufficient to meet most needs, and making major changes to an optimizer involves massive verification costs. Therefore, current developments in optimizers are mostly "minor tweaks" to AdamW made by the industry based on their own training experiences.</p>

    <p>However, an optimizer named "<a href="https://github.com/KellerJordan/Muon">Muon</a>" has recently gained considerable attention on Twitter. It claims to be more efficient than AdamW and is not just a "minor adjustment" on top of Adam; rather, it reflects some profound principles regarding the differences between vectors and matrices. In this article, let us appreciate it together.</p>

    <p align="center">
        <img src="https://kexue.fm/usr/uploads/2024/12/2885408752.png" width="500" alt="Muon vs AdamW Comparison" />
        <br />
        <em>Comparison of Muon and AdamW performance (Source: Twitter @Yuchenj_UW)</em>
    </p>

    <h2>Initial Exploration of the Algorithm</h2>
    <p>Muon stands for "MomentUm Orthogonalized by Newton-schulz." It is applicable to matrix parameters $\boldsymbol{W} \in \mathbb{R}^{n \times m}$, and its update rule is:</p>
    \begin{equation}
    \begin{aligned}
    \boldsymbol{M}_t =&\, \beta\boldsymbol{M}_{t-1} + \boldsymbol{G}_t \\[5pt]
    \boldsymbol{W}_t =&\, \boldsymbol{W}_{t-1} - \eta_t [\text{msign}(\boldsymbol{M}_t) + \lambda \boldsymbol{W}_{t-1}] \\
    \end{aligned}
    \end{equation}
    <p>Here, $\text{msign}$ is the <a href="https://en.wikipedia.org/wiki/Matrix_sign_function">matrix sign function</a>. It is not simply a component-wise $\text{sign}$ operation on the matrix, but a matrix generalization of the $\text{sign}$ function. Its relationship with <a href="translation_10407.html">SVD</a> is:</p>
    \begin{equation}\boldsymbol{U},\boldsymbol{\Sigma},\boldsymbol{V}^{\top} = \text{SVD}(\boldsymbol{M}) \quad\Rightarrow\quad \text{msign}(\boldsymbol{M}) = \boldsymbol{U}_{[:,:r]}\boldsymbol{V}_{[:,:r]}^{\top}\end{equation}
    <p>where $\boldsymbol{U} \in \mathbb{R}^{n \times n}, \boldsymbol{\Sigma} \in \mathbb{R}^{n \times m}, \boldsymbol{V} \in \mathbb{R}^{m \times m}$, and $r$ is the rank of $\boldsymbol{M}$. We will dive into more theoretical details later, but for now, let’s try to intuitively perceive the following fact:</p>
    <blockquote>
        Muon is an adaptive learning rate optimizer similar to Adam.
    </blockquote>
    <p>The characteristic of adaptive learning rate optimizers like Adagrad, RMSprop, and Adam is that they adjust the update amount of each parameter by dividing by the square root of the moving average of the gradient squared. This achieves two effects: 1. Constant scaling of the loss function does not affect the optimization trajectory; 2. The update magnitude of each parameter component is as consistent as possible. Muon satisfies exactly these two properties:</p>
    <blockquote>
        <p>1. If the loss function is multiplied by $\lambda$, $\boldsymbol{M}$ will also be multiplied by $\lambda$. Consequently, $\boldsymbol{\Sigma}$ is multiplied by $\lambda$, but since Muon's final update converts $\boldsymbol{\Sigma}$ into an identity matrix, it does not affect the optimization results;</p>
        <p>2. When $\boldsymbol{M}$ is decomposed via SVD as $\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^{\top}$, the different singular values in $\boldsymbol{\Sigma}$ reflect the "anisotropy" of $\boldsymbol{M}$. Setting them all to one makes the update more "isotropic," which serves to synchronize the update magnitudes.</p>
    </blockquote>
    <p>By the way, regarding the second point, does it remind any readers of <a href="translation_8069.html">BERT-whitening</a>? It should also be noted that Muon has a Nesterov version, which simply replaces $\text{msign}(\boldsymbol{M}_t)$ with $\text{msign}(\beta\boldsymbol{M}_t + \boldsymbol{G}_t)$ in the update rule, with everything else remaining consistent. For simplicity, we won't expand on that here.</p>
    <p>(Archival note: It was later discovered that the 2015 paper <a href="https://proceedings.mlr.press/v38/carlson15.html">"Stochastic Spectral Descent for Restricted Boltzmann Machines"</a> already proposed an optimization algorithm nearly identical to Muon, then called "Stochastic Spectral Descent.")</p>

    <h2>The Sign Function</h2>
    <p>Using SVD, we can also prove the identity:</p>
    \begin{equation}\text{msign}(\boldsymbol{M}) = (\boldsymbol{M}\boldsymbol{M}^{\top})^{-1/2}\boldsymbol{M}= \boldsymbol{M}(\boldsymbol{M}^{\top}\boldsymbol{M})^{-1/2}\label{eq:msign-id}\end{equation}
    <p>where ${}^{-1/2}$ is the inverse square root of the matrix; if it is not invertible, the <a href="translation_10366.html">pseudoinverse</a> is taken. This identity helps us better understand why $\text{msign}$ is a matrix generalization of $\text{sign}$: for a scalar $x$, we have $\text{sign}(x)=x(x^2)^{-1/2}$, which is a special case of the above equation (when $\boldsymbol{M}$ is a $1 \times 1$ matrix). This special case can also be generalized to a diagonal matrix $\boldsymbol{M}=\text{diag}(\boldsymbol{m})$:</p>
    \begin{equation}\text{msign}(\boldsymbol{M}) = \text{diag}(\boldsymbol{m})[\text{diag}(\boldsymbol{m})^2]^{-1/2} = \text{diag}(\text{sign}(\boldsymbol{m}))=\text{sign}(\boldsymbol{M})\end{equation}
    <p>where $\text{sign}(\boldsymbol{m})$ and $\text{sign}(\boldsymbol{M})$ refer to taking the component-wise $\text{sign}$ of the vector/matrix. This implies that when $\boldsymbol{M}$ is a diagonal matrix, Muon degenerates into a momentum-based <a href="https://kexue.fm/archives/10542#%E8%87%AA%E9%80%82%E5%BA%94%E7%89%88">SignSGD</a> (Signum) or the <a href="translation_9512.html">Tiger</a> optimizer I proposed, both of which are classic approximations of Adam. Conversely, the difference between Muon and Signum/Tiger is that the element-wise $\text{sign}(\boldsymbol{M})$ is replaced by the matrix version $\text{msign}(\boldsymbol{M})$.</p>
    <p>For an $n$-dimensional vector, we can also view it as an $n \times 1$ matrix, in which case $\text{msign}(\boldsymbol{m}) = \boldsymbol{m}/\Vert\boldsymbol{m}\Vert_2$ is exactly $l_2$ normalization. Thus, within the Muon framework, we have two perspectives for vectors: one is as a diagonal matrix (e.g., the gamma parameter in LayerNorm), resulting in taking the $\text{sign}$ of momentum; the other is as an $n \times 1$ matrix, resulting in $l_2$ normalization of momentum. Furthermore, although input and output Embeddings are matrices, they are used sparsely, so the more reasonable approach is to treat them as multiple independent vectors.</p>
    <p>When $m=n=r$, $\text{msign}(\boldsymbol{M})$ also has the meaning of the "optimal orthogonal approximation":</p>
    \begin{equation}\text{msign}(\boldsymbol{M}) = \mathop{\text{argmin}}_{\boldsymbol{O}^{\top}\boldsymbol{O} = \boldsymbol{I}}\Vert \boldsymbol{M} - \boldsymbol{O}\Vert_F^2 \label{eq:nearest-orth}\end{equation}
    <p>Similarly, for $\text{sign}(\boldsymbol{M})$ we can write (assuming $\boldsymbol{M}$ has no zero elements):</p>
    \begin{equation}\text{sign}(\boldsymbol{M}) = \mathop{\text{argmin}}_{\boldsymbol{O}\in\{-1,1\}^{n\times m}}\Vert \boldsymbol{M} - \boldsymbol{O}\Vert_F^{2}\end{equation}
    <p>Whether $\boldsymbol{O}^{\top}\boldsymbol{O} = \boldsymbol{I}$ or $\boldsymbol{O}\in\{-1,1\}^{n\times m}$, we can view this as a regularization constraint on the update amount. Thus, Muon, Signum, and Tiger can be seen as optimizers following the same logic, building update amounts starting from momentum $\boldsymbol{M}$, just choosing different regularization methods for the update amount.</p>
    <blockquote>
        <p><strong>Proof of Equation $\eqref{eq:nearest-orth}$</strong>: For an orthogonal matrix $\boldsymbol{O}$, we have</p>
        \begin{equation}
        \begin{aligned}
        \Vert \boldsymbol{M} - \boldsymbol{O}\Vert_F^2 =&\, \Vert \boldsymbol{M}\Vert_F^2 + \Vert \boldsymbol{O}\Vert_F^2 - 2\langle\boldsymbol{M},\boldsymbol{O}\rangle_F \\[5pt]
        =&\, \Vert \boldsymbol{M}\Vert_F^2 + n - 2\text{Tr}(\boldsymbol{M}\boldsymbol{O}^{\top})\\[5pt]
        =&\, \Vert \boldsymbol{M}\Vert_F^2 + n - 2\text{Tr}(\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^{\top}\boldsymbol{O}^{\top})\\[5pt]
        =&\, \Vert \boldsymbol{M}\Vert_F^2 + n - 2\text{Tr}(\boldsymbol{\Sigma}\boldsymbol{V}^{\top}\boldsymbol{O}^{\top}\boldsymbol{U})\\
        =&\, \Vert \boldsymbol{M}\Vert_F^2 + n - 2\sum_{i=1}^n \boldsymbol{\Sigma}_{i,i}(\boldsymbol{V}^{\top}\boldsymbol{O}^{\top}\boldsymbol{U})_{i,i}
        \end{aligned}
        \end{equation}
        <p>The operational rules involved here were introduced in the <a href="translation_10366.html">pseudoinverse</a> post. Since $\boldsymbol{U},\boldsymbol{V},\boldsymbol{O}$ are all orthogonal matrices, $\boldsymbol{V}^{\top}\boldsymbol{O}^{\top}\boldsymbol{U}$ is also an orthogonal matrix. Any component of an orthogonal matrix cannot exceed 1. Since $\boldsymbol{\Sigma}_{i,i} > 0$, the minimum of the above expression corresponds to maximizing each $(\boldsymbol{V}^{\top}\boldsymbol{O}^{\top}\boldsymbol{U})_{i,i}$, i.e., $(\boldsymbol{V}^{\top}\boldsymbol{O}^{\top}\boldsymbol{U})_{i,i}=1$, which means $\boldsymbol{V}^{\top}\boldsymbol{O}^{\top}\boldsymbol{U}=\boldsymbol{I}$, or $\boldsymbol{O}=\boldsymbol{U}\boldsymbol{V}^{\top}$.</p>
        <p>This conclusion can be carefully generalized to cases where $m, n, r$ are not equal, but we won't expand further here.</p>
    </blockquote>

    <h2>Iterative Solution</h2>
    <p>In practice, performing an SVD at every step to solve for $\text{msign}(\boldsymbol{M})$ would be computationally expensive. Therefore, the authors proposed using Newton-Schulz iteration to approximate $\text{msign}(\boldsymbol{M})$.</p>
    <p>The starting point for the iteration is identity $\eqref{eq:msign-id}$. Without loss of generality, we assume $n \geq m$ and consider the Taylor expansion of $(\boldsymbol{M}^{\top}\boldsymbol{M})^{-1/2}$ at $\boldsymbol{M}^{\top}\boldsymbol{M}=\boldsymbol{I}$. The expansion method directly applies the result of the scalar function $t^{-1/2}$ to the matrix:</p>
    \begin{equation}t^{-1/2} = 1 - \frac{1}{2}(t-1) + \frac{3}{8}(t-1)^2 - \frac{5}{16}(t-1)^3 + \cdots\end{equation}
    <p>Retaining up to the second order, the result is $(15 - 10t + 3t^2)/8$, so we have</p>
    \begin{equation}\text{msign}(\boldsymbol{M}) = \boldsymbol{M}(\boldsymbol{M}^{\top}\boldsymbol{M})^{-1/2}\approx \frac{15}{8}\boldsymbol{M} - \frac{5}{4}\boldsymbol{M}(\boldsymbol{M}^{\top}\boldsymbol{M}) + \frac{3}{8}\boldsymbol{M}(\boldsymbol{M}^{\top}\boldsymbol{M})^2\end{equation}
    <p>If $\boldsymbol{X}_t$ is some approximation of $\text{msign}(\boldsymbol{M})$, we assume that substituting it into the above expression yields a better approximation, thus obtaining a usable iterative format:</p>
    \begin{equation}\boldsymbol{X}_{t+1} = \frac{15}{8}\boldsymbol{X}_t - \frac{5}{4}\boldsymbol{X}_t(\boldsymbol{X}_t^{\top}\boldsymbol{X}_t) + \frac{3}{8}\boldsymbol{X}_t(\boldsymbol{X}_t^{\top}\boldsymbol{X}_t)^2\end{equation}
    <p>However, checking Muon's official code, we find that while the Newton-Schulz iteration follows this form, the three coefficients are actually $(3.4445, -4.7750, 2.0315)$. The author did not provide a mathematical derivation, only a vague comment:</p>

    <p align="center">
        <img src="https://kexue.fm/usr/uploads/2024/12/323863458.png" width="500" alt="Muon Newton-Schulz Code" />
        <br />
        <em>Newton-Schulz iteration in the Muon optimizer</em>
    </p>

    <h2>Convergence Acceleration</h2>
    <p>To guess the origin of the official iteration algorithm, we consider a general iterative process:</p>
    \begin{equation}\boldsymbol{X}_{t+1} = a\boldsymbol{X}_t + b\boldsymbol{X}_t(\boldsymbol{X}_t^{\top}\boldsymbol{X}_t) + c\boldsymbol{X}_t(\boldsymbol{X}_t^{\top}\boldsymbol{X}_t)^2\label{eq:iteration}\end{equation}
    <p>where $a, b, c$ are three coefficients to be solved. If a higher-order iterative algorithm is desired, we could successively add terms like $\boldsymbol{X}_t(\boldsymbol{X}_t^{\top}\boldsymbol{X}_t)^3$ or $\boldsymbol{X}_t(\boldsymbol{X}_t^{\top}\boldsymbol{X}_t)^4$. The following analysis is general.</p>
    <p>We choose the initial value $\boldsymbol{X}_0=\boldsymbol{M}/\Vert\boldsymbol{M}\Vert_F$, where $\Vert\cdot\Vert_F$ is the Frobenius norm. The basis for this choice is that dividing by $\Vert\boldsymbol{M}\Vert_F$ does not change the $\boldsymbol{U}$ and $\boldsymbol{V}$ of the SVD, but ensures all singular values of $\boldsymbol{X}_0$ lie between $[0, 1]$, making the initial singular values more "standard." Now assume $\boldsymbol{X}_t$ can be decomposed via SVD as $\boldsymbol{U}\boldsymbol{\Sigma}_t\boldsymbol{V}^{\top}$. Substituting into the above equation, we get:</p>
    \begin{equation}\boldsymbol{X}_{t+1} = \boldsymbol{U}_{[:,:r]}(a \boldsymbol{\Sigma}_{t,[:r,:r]} + b \boldsymbol{\Sigma}_{t,[:r,:r]}^3 + c \boldsymbol{\Sigma}_{t,[:r,:r]}^5)\boldsymbol{V}_{[:,:r]}^{\top}\end{equation}
    <p>Therefore, Equation $\eqref{eq:iteration}$ is essentially iterating the diagonal matrix $\boldsymbol{\Sigma}_{[:r,:r]}$ of singular values. If we denote $\boldsymbol{X}_t=\boldsymbol{U}_{[:,:r]}\boldsymbol{\Sigma}_{t,[:r,:r]}\boldsymbol{V}_{[:,:r]}^{\top}$, then $\boldsymbol{\Sigma}_{t+1,[:r,:r]} = g(\boldsymbol{\Sigma}_{t,[:r,:r]})$, where $g(x) = ax + bx^3 + cx^5$. Since the power of a diagonal matrix equals the power of its diagonal elements, the problem simplifies to the iteration of a single singular value $\sigma$. Our target is to calculate $\boldsymbol{U}_{[:,:r]}\boldsymbol{V}_{[:,:r]}^{\top}$; in other words, we hope the singular values in $\boldsymbol{\Sigma}_{[:r,:r]}$ become identity via iteration, which simplifies to the iteration $\sigma_{t+1} = g(\sigma_t)$ mapping values to 1.</p>
    <p>Inspired by <a href="https://x.com/leloykun/status/1846165001746501899">@leloykun</a>, we treat the choice of $a, b, c$ as an optimization problem, aiming to make the iteration converge as quickly as possible for any initial singular value. First, we reparameterize $g(x)$ as:</p>
    \begin{equation}g(x) = x + \kappa x(x^2 - x_1^2)(x^2 - x_2^2)\end{equation}
    <p>where $x_1 \leq x_2$. This parameterization intuitively shows the 5 fixed points of the iteration: $0, \pm x_1, \pm x_2$. As our target is to converge to 1, we choose initial values $x_1 < 1, x_2 > 1$. The idea is that whether the iteration moves toward $x_1$ or $x_2$, the result remains near 1.</p>
    <p>Next, we fix the number of iterations $T$, making the iterative process a deterministic function. By specifying the matrix shape (i.e., $n, m$), we can sample a batch of matrices and calculate their singular values via SVD. Finally, we treat these singular values as inputs and the target output as 1, with the loss function being the mean squared error. This entire model is differentiable and can be solved using gradient descent (<a href="https://x.com/leloykun/status/1846165001746501899">@leloykun</a> assumed $x_1 + x_2 = 2$ and used grid search).</p>

    <p>Some calculation results:</p>
<table border="1" style="width:100%; text-align:center; border-collapse: collapse;">
<thead>
<tr>
<th>n</th>
<th>m</th>
<th>T</th>
<th>$\kappa$</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>mse</th>
<th>$\text{mse}_o$</th>
</tr>
</thead>
<tbody>
<tr>
<td>1024</td>
<td>1024</td>
<td>3</td>
<td>7.020</td>
<td>0.830</td>
<td>0.830</td>
<td>4.328</td>
<td>-9.666</td>
<td>7.020</td>
<td>0.10257</td>
<td>0.18278</td>
</tr>
<tr>
<td>1024</td>
<td>1024</td>
<td>5</td>
<td>1.724</td>
<td>0.935</td>
<td>1.235</td>
<td>3.297</td>
<td>-4.136</td>
<td>1.724</td>
<td>0.02733</td>
<td>0.04431</td>
</tr>
<tr>
<td>2048</td>
<td>1024</td>
<td>3</td>
<td>7.028</td>
<td>0.815</td>
<td>0.815</td>
<td>4.095</td>
<td>-9.327</td>
<td>7.028</td>
<td>0.01628</td>
<td>0.06171</td>
</tr>
<tr>
<td>2048</td>
<td>1024</td>
<td>5</td>
<td>1.476</td>
<td>0.983</td>
<td>1.074</td>
<td>2.644</td>
<td>-3.128</td>
<td>1.476</td>
<td>0.00038</td>
<td>0.02954</td>
</tr>
<tr>
<td>4096</td>
<td>1024</td>
<td>3</td>
<td>6.948</td>
<td>0.802</td>
<td>0.804</td>
<td>3.886</td>
<td>-8.956</td>
<td>6.948</td>
<td>0.00371</td>
<td>0.02574</td>
</tr>
<tr>
<td>4096</td>
<td>1024</td>
<td>5</td>
<td>1.214</td>
<td>1.047</td>
<td>1.048</td>
<td>2.461</td>
<td>-2.663</td>
<td>1.214</td>
<td>0.00008</td>
<td>0.02563</td>
</tr>
<tr>
<td>2048</td>
<td>2048</td>
<td>3</td>
<td>11.130</td>
<td>0.767</td>
<td>0.767</td>
<td>4.857</td>
<td>-13.103</td>
<td>11.130</td>
<td>0.10739</td>
<td>0.24410</td>
</tr>
<tr>
<td>2048</td>
<td>2048</td>
<td>5</td>
<td>1.779</td>
<td>0.921</td>
<td>1.243</td>
<td>3.333</td>
<td>-4.259</td>
<td>1.779</td>
<td>0.03516</td>
<td>0.04491</td>
</tr>
<tr>
<td>4096</td>
<td>4096</td>
<td>3</td>
<td>18.017</td>
<td>0.705</td>
<td>0.705</td>
<td>5.460</td>
<td>-17.929</td>
<td>18.017</td>
<td>0.11303</td>
<td>0.33404</td>
</tr>
<tr>
<td>4096</td>
<td>4096</td>
<td>5</td>
<td>2.057</td>
<td>0.894</td>
<td>1.201</td>
<td>3.373</td>
<td>-4.613</td>
<td>2.057</td>
<td>0.04700</td>
<td>0.06372</td>
</tr>
<tr>
<td>8192</td>
<td>8192</td>
<td>3</td>
<td>30.147</td>
<td>0.643</td>
<td>0.643</td>
<td>6.139</td>
<td>-24.893</td>
<td>30.147</td>
<td>0.11944</td>
<td>0.44843</td>
</tr>
<tr>
<td>8192</td>
<td>8192</td>
<td>5</td>
<td>2.310</td>
<td>0.871</td>
<td>1.168</td>
<td>3.389</td>
<td>-4.902</td>
<td>2.310</td>
<td>0.05869</td>
<td>0.07606</td>
</tr>
</tbody>
</table>

    <p>Here $\text{mse}_o$ is the result calculated using the $a, b, c$ from the Muon author. As seen from the table, results depend significantly on matrix size and the number of iterations; the loss function suggests that non-square matrices converge more easily than square ones. The $a, b, c$ provided by the Muon author seem to be the optimal solution for a square matrix when the number of iterations is 5. When the number of iterations is fixed, the result depends on the matrix size, which essentially depends on the distribution of singular values. A noteworthy result regarding this distribution as $n, m \to \infty$ is the <a href="https://en.wikipedia.org/wiki/Marchenko%E2%80%93Pastur_distribution">Marchenko–Pastur distribution</a>.</p>

    <p>Reference code:</p>
<pre><code>import jax
import jax.numpy as jnp
from tqdm import tqdm

n, m, T = 1024, 1024, 5
key, data = jax.random.key(42), jnp.array([])
for _ in tqdm(range(1000), ncols=0, desc='SVD'):
    key, subkey = jax.random.split(key)
    M = jax.random.normal(subkey, shape=(n, m))
    S = jnp.linalg.svd(M, full_matrices=False)[1]
    data = jnp.concatenate([data, S / (S**2).sum()**0.5])

@jax.jit
def f(w, x):
    k, x1, x2 = w
    for _ in range(T):
        x = x + k * x * (x**2 - x1**2) * (x**2 - x2**2)
    return ((x - 1)**2).mean()

f_grad = jax.grad(f)
w, u = jnp.array([1, 0.9, 1.1]), jnp.zeros(3)
for _ in tqdm(range(100000), ncols=0, desc='SGD'):
    u = 0.9 * u + f_grad(w, data)  # Momentum acceleration
    w = w - 0.01 * u

k, x1, x2 = w
a, b, c = 1 + k * x1**2 * x2**2, -k * (x1**2 + x2**2), k
print(f'{n} & {m} & {T} & {k:.3f} & {x1:.3f} & {x2:.3f} & {a:.3f} & {b:.3f} & {c:.3f} & {f(w, data):.5f}')
</code></pre>

    <h2>Some Reflections</h2>
    <p>If we follow the default choice of $T=5$, then for an $n \times n$ matrix parameter, Muon's each update step requires at least 15 matrix multiplications of $n \times n$ by $n \times n$. This computational overhead is undoubtedly significantly larger than Adam's, leading some readers to worry about whether Muon is practical.</p>
    <p>In fact, this concern is unnecessary. Although Muon's calculation is more complex than Adam's, the additional time per step is small; my conclusion is within 5%, and the Muon author claims it can be as low as 2%. This is because the matrix multiplications in Muon happen after the current gradient computation is finished and before the next gradient computation starts. During this period, almost all computational power is idle, and these matrix multiplications have static sizes and can be parallelized, hence they do not significantly increase time costs. Moreover, Muon requires one fewer set of cache variables than Adam, leading to lower memory costs.</p>
    <p>The most thought-provoking aspect of Muon is actually the intrinsic difference between vectors and matrices and its impact on optimization. Common optimizers like SGD, Adam, and Tiger have element-wise update rules; whether parameters are vectors or matrices, they are treated as one large vector, with components updated independently following the same rules. Optimizers with this property are often easier to analyze theoretically and facilitate tensor parallelism, as splitting a large matrix into two small matrices to be handled independently doesn't change the optimization trajectory.</p>
    <p>But Muon is different. It takes the matrix as the basic unit, considering some unique properties of matrices. Some readers might find it strange: aren't matrices and vectors just arrangements of numbers, what difference could there be? Take the concept of "trace" as an example: it is the sum of diagonal elements. This concept wasn't chosen randomly; it has an important property of being invariant under similarity transformations and is equal to the sum of all eigenvalues. From this, we can see that diagonal elements and non-diagonal elements of a matrix do not have perfectly equal status. Muon's superior performance stems precisely from considering this inequality.</p>
    <p>Of course, this also leads to some negative impacts. If a matrix is partitioned across different devices, then using Muon would require gathering their gradients before calculating the update amount, rather than having each device update independently, which increases communication costs. Even ignoring parallelism, this problem exists. For example, Multi-Head Attention is generally projected into $Q$ (and $K, V$) via a single large matrix, then reshaped into multiple heads. While there is only one matrix in the model parameters, it is essentially multiple small matrices; thus, theoretically, we should split the large matrix into multiple small matrices to update them independently.</p>
    <p>In short, Muon's non-element-wise update rule effectively captures the fundamental differences between vectors and matrices but also introduces some minor issues, which might not suit the aesthetic tastes of some readers.</p>
    <p>(Supplement: Almost concurrently with the publication of this blog, Keller Jordan, the author of Muon, also released his own blog post: <a href="https://kellerjordan.github.io/posts/muon/">"Muon: An optimizer for hidden layers in neural networks"</a>.)</p>

    <h2>The Norm Perspective</h2>
    <p>Theoretically, what key characteristic of matrices does Muon capture? Perhaps the norm perspective can provide the answer.</p>
    <p>The discussion in this section is primarily based on the papers <a href="https://ieeexplore.ieee.org/abstract/document/7347351">"Stochastic Spectral Descent for Discrete Graphical Models"</a> and <a href="https://papers.cool/arxiv/2409.20325">"Old Optimizer, New Norm: An Anthology,"</a> particularly the latter. However, the starting point is not new; we briefly touched upon it in <a href="translation_9660.html">"Gradient Flow: Exploring the Path to the Minimum"</a>: for a vector parameter $\boldsymbol{w} \in \mathbb{R}^n$, we define the next update rule as:</p>
    \begin{equation}\boldsymbol{w}_{t+1} = \mathop{\text{argmin}}_{\boldsymbol{w}} \frac{\Vert\boldsymbol{w} - \boldsymbol{w}_t\Vert^2}{2\eta_t} + \mathcal{L}(\boldsymbol{w})\end{equation}
    <p>where $\Vert\cdot\Vert$ is some vector norm; this is known as "steepest gradient descent" under a specific norm constraint. Assuming $\eta_t$ is sufficiently small, the first term dominates, meaning $\boldsymbol{w}_{t+1}$ will be very close to $\boldsymbol{w}_t$. If we assume a first-order approximation of $\mathcal{L}(\boldsymbol{w})$ is sufficient, the problem simplifies to:</p>
    \begin{equation}\boldsymbol{w}_{t+1} = \mathop{\text{argmin}}_{\boldsymbol{w}} \frac{\Vert\boldsymbol{w} - \boldsymbol{w}_t\Vert^2}{2\eta_t} + \mathcal{L}(\boldsymbol{w}_t) + \nabla_{\boldsymbol{w}_t}\mathcal{L}(\boldsymbol{w}_t)^{\top}(\boldsymbol{w}-\boldsymbol{w}_t)\end{equation}
    <p>Let $\Delta\boldsymbol{w}_{t+1} = \boldsymbol{w}_{t+1}-\boldsymbol{w}_t$ and $\boldsymbol{g}_t = \nabla_{\boldsymbol{w}_t}\mathcal{L}(\boldsymbol{w}_t)$. This can be rewritten as:</p>
    \begin{equation}\Delta\boldsymbol{w}_{t+1} = \mathop{\text{argmin}}_{\Delta\boldsymbol{w}} \frac{\Vert\Delta\boldsymbol{w}\Vert^2}{2\eta_t} + \boldsymbol{g}_t^{\top}\Delta\boldsymbol{w}\end{equation}
    <p>A general way to calculate $\Delta\boldsymbol{w}_{t+1}$ is through differentiation, but <a href="https://papers.cool/arxiv/2409.20325">"Old Optimizer, New Norm: An Anthology"</a> provides a unified solution without differentiation: decompose $\Delta\boldsymbol{w}$ into norm $\gamma = \Vert\Delta\boldsymbol{w}\Vert$ and a direction vector $\boldsymbol{\varphi} = -\Delta\boldsymbol{w}/\Vert\Delta\boldsymbol{w}\Vert$. Thus:</p>
    \begin{equation}\min_{\Delta\boldsymbol{w}} \frac{\Vert\Delta\boldsymbol{w}\Vert^2}{2\eta_t} + \boldsymbol{g}_t^{\top}\Delta\boldsymbol{w} = \min_{\gamma\geq 0, \Vert\boldsymbol{\varphi}\Vert=1} \frac{\gamma^2}{2\eta_t} - \gamma\boldsymbol{g}_t^{\top}\boldsymbol{\varphi} = \min_{\gamma\geq 0} \frac{\gamma^2}{2\eta_t} - \gamma\bigg(\underbrace{\max_{\Vert\boldsymbol{\varphi}\Vert=1}\boldsymbol{g}_t^{\top}\boldsymbol{\varphi}}_{\text{denoted as }\Vert \boldsymbol{g}_t\Vert^{\dagger}}\bigg)\end{equation}
    <p>Since $\gamma$ is just a scalar similar to the learning rate, it's easy to find the optimal value as $\eta_t\Vert \boldsymbol{g}_t\Vert^{\dagger}$, while the update direction $\boldsymbol{\varphi}^*$ maximizes $\boldsymbol{g}_t^{\top}\boldsymbol{\varphi}$ subject to $\Vert\boldsymbol{\varphi}\Vert=1$. Substituting the Euclidean norm $\Vert\boldsymbol{\varphi}\Vert_2 = \sqrt{\boldsymbol{\varphi}^{\top}\boldsymbol{\varphi}}$, we have $\Vert \boldsymbol{g}_t\Vert^{\dagger}=\Vert \boldsymbol{g}_t\Vert_2$ and $\boldsymbol{\varphi}^* = \boldsymbol{g}_t/\Vert \boldsymbol{g}_t\Vert_2$. In this case, $\Delta\boldsymbol{w}_{t+1}=-\eta_t \boldsymbol{g}_t$, which is Gradient Descent (SGD). Generally, for a $p$-norm:</p>
    \begin{equation}\Vert\boldsymbol{\varphi}\Vert_p = \sqrt[p]{\sum_{i=1}^n |\varphi_i|^p}\end{equation}
    <p><a href="https://en.wikipedia.org/wiki/H%C3%B6lder%27s_inequality">Hölder's inequality</a> gives $\boldsymbol{g}^{\top}\boldsymbol{\varphi} \leq \Vert \boldsymbol{g}\Vert_q \Vert \boldsymbol{\varphi}\Vert_p$, where $1/p + 1/q = 1$. Utilizing this, we obtain:</p>
    \begin{equation}\max_{\Vert\boldsymbol{\varphi}\Vert_p=1}\boldsymbol{g}^{\top}\boldsymbol{\varphi} = \Vert \boldsymbol{g}\Vert_q\end{equation}
    <p>The equality holds when:</p>
    \begin{equation}\boldsymbol{\varphi}^* = \frac{1}{\Vert\boldsymbol{g}\Vert_q^{q/p}}\Big[\text{sign}(g_1) |g_1|^{q/p},\text{sign}(g_2) |g_2|^{q/p},\cdots,\text{sign}(g_n) |g_n|^{q/p}\Big]\end{equation}
    <p>The optimizer using this direction is called pbSGD, see <a href="https://www.ijcai.org/proceedings/2020/451">"pbSGD: Powered Stochastic Gradient Descent Methods for Accelerated Non-Convex Optimization."</a> Notably, as $p \to \infty$, we have $q \to 1$ and $|g_i|^{q/p} \to 1$, which degenerates into SignSGD. This means SignSGD is actually steepest gradient descent under the $\Vert\cdot\Vert_{\infty}$ norm.</p>

    <h2>Matrix Norms</h2>
    <p>Now let's switch our focus to matrix parameters $\boldsymbol{W} \in \mathbb{R}^{n \times m}$. Similarly, we define its update rule as:</p>
    \begin{equation}\boldsymbol{W}_{t+1} = \mathop{\text{argmin}}_{\boldsymbol{W}} \frac{\Vert\boldsymbol{W} - \boldsymbol{W}_t\Vert^2}{2\eta_t} + \mathcal{L}(\boldsymbol{W})\end{equation}
    <p>where $\Vert\cdot\Vert$ is some matrix norm. Using a first-order approximation again, we get:</p>
    \begin{equation}\Delta\boldsymbol{W}_{t+1} = \mathop{\text{argmin}}_{\Delta\boldsymbol{W}} \frac{\Vert\Delta\boldsymbol{W}\Vert^2}{2\eta_t} + \text{Tr}(\boldsymbol{G}_t^{\top}\Delta\boldsymbol{W})\end{equation}
    <p>where $\Delta\boldsymbol{W}_{t+1} = \boldsymbol{W}_{t+1}-\boldsymbol{W}_t$ and $\boldsymbol{G}_t = \nabla_{\boldsymbol{W}_t}\mathcal{L}(\boldsymbol{W}_t)$. Again using the "norm-direction" decoupling, with $\gamma = \Vert\Delta\boldsymbol{W}\Vert$ and $\boldsymbol{\Phi} = -\Delta\boldsymbol{W}/\Vert\Delta\boldsymbol{W}\Vert$, we get:</p>
    \begin{equation}\min_{\Delta\boldsymbol{W}} \frac{\Vert\Delta\boldsymbol{W}\Vert^2}{2\eta_t} + \text{Tr}(\boldsymbol{G}_t^{\top}\Delta\boldsymbol{W}) = \min_{\gamma\geq 0} \frac{\gamma^2}{2\eta_t} - \gamma\bigg(\underbrace{\max_{\Vert\boldsymbol{\Phi}\Vert=1}\text{Tr}(\boldsymbol{G}_t^{\top}\boldsymbol{\Phi})}_{\text{denoted as }\Vert \boldsymbol{G}_t\Vert^{\dagger}}\bigg)\end{equation}
    <p>Then we analyze specific norms. There are two commonly used matrix norms: one is the <a href="https://kexue.fm/archives/10366#%E8%8C%83%E6%95%B0%E7%9B%B8%E5%85%B3">Frobenius norm (F-norm)</a>, which is essentially the Euclidean norm of the flattened matrix. In this case, the conclusion is the same as for vectors: the answer is SGD. The other is the 2-norm induced by vector norms, also known as the spectral norm:</p>
    \begin{equation}\Vert \boldsymbol{\Phi}\Vert_2 = \max_{\Vert \boldsymbol{x}\Vert_2 = 1} \Vert \boldsymbol{\Phi}\boldsymbol{x}\Vert_2\end{equation}
    <p>Note that the $\Vert\cdot\Vert_2$ on the right side applies to vectors, so the definition is clear. More discussion on the 2-norm can be found in <a href="translation_6051.html">"Lipschitz Continuity in Deep Learning"</a> and <a href="https://kexue.fm/archives/10407#%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0">"The Path to Low Rank Approximation (2): SVD."</a> Since the 2-norm is induced by "matrix-vector" multiplication, it more appropriately fits matrix multiplication, and it always holds that $\Vert\boldsymbol{\Phi}\Vert_2\leq \Vert\boldsymbol{\Phi}\Vert_F$, meaning the 2-norm provides a tighter measure than the F-norm.</p>
    <p>So, we proceed with calculations for the 2-norm. Let the SVD of $\boldsymbol{G}$ be $\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^{\top} = \sum_{i=1}^r \sigma_i \boldsymbol{u}_i \boldsymbol{v}_i^{\top}$. we have:</p>
    \begin{equation}\text{Tr}(\boldsymbol{G}^{\top}\boldsymbol{\Phi})=\text{Tr}\Big(\sum_{i=1}^r \sigma_i \boldsymbol{v}_i \boldsymbol{u}_i^{\top}\boldsymbol{\Phi}\Big) = \sum_{i=1}^r \sigma_i \boldsymbol{u}_i^{\top}\boldsymbol{\Phi}\boldsymbol{v}_i\end{equation}
    <p>By definition, when $\Vert\boldsymbol{\Phi}\Vert_2=1$, $\Vert\boldsymbol{\Phi}\boldsymbol{v}_i\Vert_2\leq \Vert\boldsymbol{v}_i\Vert_2=1$. Thus $\boldsymbol{u}_i^{\top}\boldsymbol{\Phi}\boldsymbol{v}_i\leq 1$, and therefore:</p>
    \begin{equation}\text{Tr}(\boldsymbol{G}^{\top}\boldsymbol{\Phi})\leq \sum_{i=1}^r \sigma_i\end{equation}
    <p>The equality is reached when all $\boldsymbol{u}_i^{\top}\boldsymbol{\Phi}\boldsymbol{v}_i$ are equal to 1, in which case:</p>
    \begin{equation}\boldsymbol{\Phi} = \sum_{i=1}^r \boldsymbol{u}_i \boldsymbol{v}_i^{\top} = \boldsymbol{U}_{[:,:r]}\boldsymbol{V}_{[:,:r]}^{\top} = \text{msign}(\boldsymbol{G})\end{equation}
    <p>Thus, we have proved that gradient descent under the 2-norm penalty is exactly the Muon optimizer when $\beta=0$! When $\beta > 0$, the moving average takes effect, which we can treat as a more accurate estimate of the gradient, thus applying $\text{msign}$ to the momentum instead. Overall, Muon is equivalent to gradient descent under the 2-norm constraint. The 2-norm better captures the intrinsic differences between matrices, allowing each step to be more precise and fundamental.</p>

    <h2>Tracing the Origins</h2>
    <p>There is a much earlier related work to Muon called <a href="https://papers.cool/arxiv/1802.09568">"Shampoo: Preconditioned Stochastic Tensor Optimization."</a> This 2018 paper proposed an optimizer named Shampoo, which shares similarities with Muon.</p>
    <p>The strategy of adaptive learning rates via the average of squared gradients, first proposed in the Adagrad paper <a href="https://jmlr.org/papers/v12/duchi11a.html">"Adaptive Subgradient Methods for Online Learning and Stochastic Optimization,"</a> initially suggested directly accumulating the squared gradients, which corresponds to a global uniform average. Subsequent RMSProp and Adam adapted this with a 设计 similar to momentum, using a moving average, which was found to perform better in practice.</p>
    <p>Furthermore, Adagrad originally proposed accumulating the outer product $\boldsymbol{g}\boldsymbol{g}^{\top}$. However, because caching the outer product consumes too much spatial cost, the Hadamard product $\boldsymbol{g}\odot\boldsymbol{g}$ was used in practice. What is the theoretical basis for accumulating outer products? As derived in <a href="translation_10588.html">"Adaptive Learning Rate Optimizers from the Perspective of Hessian Approximation,"</a> the answer is that the long-term average of the gradient outer product $\mathbb{E}[\boldsymbol{g}\boldsymbol{g}^{\top}]$ approximates the square of the Hessian matrix $\sigma^2\boldsymbol{\mathcal{H}}_{\boldsymbol{\theta}^*}^2$, so this is actually an approximation of the second-order Newton method.</p>
    <p>Shampoo inherited the idea of caching outer products from Adagrad but struck a compromise considering cost. Like Muon, it optimizes matrices (and higher-order tensors) specifically. Its strategy is to cache matrix products $\boldsymbol{G}\boldsymbol{G}^{\top}$ and $\boldsymbol{G}^{\top}\boldsymbol{G}$ instead of outer products, bringing spatial cost to $\mathcal{O}(n^2 + m^2)$ rather than $\mathcal{O}(n^2 m^2)$:</p>
    \begin{equation}
    \begin{aligned}
    \boldsymbol{L}_t =&\, \beta\boldsymbol{L}_{t-1} + \boldsymbol{G}_t\boldsymbol{G}_t^{\top} \\[5pt]
    \boldsymbol{R}_t =&\, \beta\boldsymbol{R}_{t-1} + \boldsymbol{G}_t^{\top}\boldsymbol{G}_t \\[5pt]
    \boldsymbol{W}_t =&\, \boldsymbol{W}_{t-1} - \eta_t \boldsymbol{L}_t^{-1/4}\boldsymbol{G}_t\boldsymbol{R}_t^{-1/4} \\
    \end{aligned}
    \end{equation}
    <p>The $\beta$ here was added by me for illustration; Shampoo defaults $\beta=1$. The ${}^{-1/4}$ exponent refers to matrix power operations, which can be completed via SVD. Since Shampoo did not propose an approximate scheme like Newton-Schulz iteration and directly used SVD, to save computing costs, it does not calculate $\boldsymbol{L}_t^{-1/4}$ and $\boldsymbol{R}_t^{-1/4}$ at every step, but only updates them at fixed step intervals.</p>
    <p>Specifically, when $\beta=0$, the update vector in Shampoo is $(\boldsymbol{G}\boldsymbol{G}^{\top})^{-1/4}\boldsymbol{G}(\boldsymbol{G}^{\top}\boldsymbol{G})^{-1/4}$. By performing SVD on $\boldsymbol{G}$, we can prove that:</p>
    \begin{equation}(\boldsymbol{G}\boldsymbol{G}^{\top})^{-1/4}\boldsymbol{G}(\boldsymbol{G}^{\top}\boldsymbol{G})^{-1/4} = (\boldsymbol{G}\boldsymbol{G}^{\top})^{-1/2}\boldsymbol{G}= \boldsymbol{G}(\boldsymbol{G}^{\top}\boldsymbol{G})^{-1/2}=\text{msign}(\boldsymbol{G})\end{equation}
    <p>This shows that when $\beta=0$, Shampoo and Muon are theoretically equivalent! Therefore, Shampoo and Muon share a common ground in terms of update amount design.</p>

    <h2>Summary</h2>
    <p>This article introduced the Muon optimizer, which has recently become a hot topic on Twitter. It is specifically tailored for matrix parameters and currently appears to be more efficient than AdamW. Moreover, it seems to embody some fundamental differences between vectorization and matrixization, making it worthy of study and reflection.</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/10592" style="color: #005fcc;">https://kexue.fm/archives/10592</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
