
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    packages: {'[+]': ['ams']},
    tags: 'ams'
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  },
  loader: {load: ['[tex]/ams']}
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/4299">[Incredible Word2Vec] 1. Mathematical Principles</a></h1>

<p>By 苏剑林 | April 02, 2017</p>

<p>For readers familiar with Deep Learning and Natural Language Processing (NLP), Word2Vec is a household name. Although not everyone has used it personally, most people have heard of it—Google's highly efficient tool for obtaining word vectors.</p>

<h2>Is Word2Vec Incredible?</h2>

<p>Most people treat Word2Vec as a synonymous term for word vectors. In other words, they use it purely as a tool for obtaining word representations, and few readers concern themselves with the model itself. This might be because the model is so simplified that people assume such a simple model must be inaccurate and therefore unusable for modeling language, even if its byproduct—the word vectors—is quite good. Indeed, if viewed as a language model, Word2Vec is far too crude.</p>

<p>However, why should we view it only as a language model? Setting aside the constraints of language modeling and looking at the model itself, we find that the two Word2Vec models—CBOW and Skip-Gram—are actually extremely useful. They describe the relationship between surrounding words and the current word from different perspectives. Many basic NLP tasks, such as keyword extraction and logical reasoning, are built upon this relationship. This series of articles hopes to provide some inspiration by introducing the Word2Vec model itself and several "incredible" use cases, offering new ways to research such problems.</p>

<p>Speaking of Word2Vec being "incredible," when it was first released, perhaps the most surprising feature was its Word Analogy property—linear characteristics such as <code>king - man ≈ queen - woman</code>. The author, Mikolov, believed this property implied that the word vectors generated by Word2Vec possessed semantic reasoning capabilities. It was this feature, combined with the Google pedigree, that made Word2Vec rapidly popular. Unfortunately, when training word vectors ourselves, it is often difficult to reproduce this exact result, and there isn't even a solid theoretical basis suggesting that a good set of word vectors <i>must</i> satisfy this Word Analogy property. In contrast, the various uses I will introduce here are highly reproducible; readers can even train a Word2Vec model on a small corpus and obtain similar results.</p>

<h2>Mathematical Principles: Online Resources</h2>

<p>Readers interested in this series should understand the mathematical principles of Word2Vec. Since Word2Vec has been out for several years, there are countless articles introducing it. Personally, I recommend the series of blog posts by the expert peghoty: <a href="http://blog.csdn.net/itplus/article/details/37969519">http://blog.csdn.net/itplus/article/details/37969519</a></p>

<p>Additionally, the post <a href="translation_4122.html">"What's Really Going On with Word Vectors and Embeddings?"</a> on this blog is also helpful for understanding the principles of Word2Vec.</p>

<p>For the convenience of readers, I have collected two corresponding PDF files:</p>

<p><a href="https://kexue.fm/usr/uploads/2017/04/2833204610.pdf">Mathematical Principles of word2vector in Detail.pdf</a></p>
<p><a href="https://kexue.fm/usr/uploads/2017/04/146269300.pdf">Deep Learning in Action: word2vec.pdf</a></p>

<p>The first one is the PDF version of the recommended blog series by peghoty. Of course, if your English is good, you can read the original Word2Vec papers directly:</p>

<blockquote>
  <p>[1] Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. Efficient Estimation of Word Representations in Vector Space. In Proceedings of Workshop at ICLR, 2013.</p>
  <p>[2] Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Corrado, and Jeffrey Dean. Distributed Representations of Words and Phrases and their Compositionality. In Proceedings of NIPS, 2013.</p>
</blockquote>

<p>However, I personally feel that the original papers are not as clearly explained as the Chinese commentaries.</p>

<h2>Mathematical Principles: A Simple Explanation</h2>

<p>Simply put, Word2Vec consists of "two training schemes + two acceleration methods," so strictly speaking, it offers four candidate models.</p>

<p>The two training schemes are CBOW and Skip-Gram, as shown in the figure below:</p>

<p><i>(Two Models of Word2Vec)</i></p>

<p>In colloquial terms, they are "summing up surrounding words to predict the current word" ($P(w_t|Context)$) and "using the current word to predict surrounding words individually" ($P(w_{others}|w_t)$). These are essentially conditional probability modeling problems. The two acceleration methods are Hierarchical Softmax and Negative Sampling. Hierarchical Softmax is a simplification of the Softmax function, directly reducing the complexity of predicting probabilities from $\mathcal{O}(|V|)$ to $\mathcal{O}(\log_2 |V|)$, though its precision is slightly lower than the original Softmax. Negative Sampling takes the opposite approach; it combines the original input and output as a single input and performs a binary classification to assign a score. This can be seen as modeling the joint probabilities $P(w_t, Context)$ and $P(w_t, w_{others})$. Positive samples are those that appear in the corpus, while negative samples are randomly drawn. For more details, it is best to study peghoty's blog series closely; that is also where I learned the implementation details of Word2Vec.</p>

<p><b>Finally, it should be noted that the model used in this series is the combination of "Skip-Gram + Hierarchical Softmax." That is, we will be using the $P(w_{others}|w_t)$ model itself, not just the word vectors. Therefore, readers who wish to follow this series will need some understanding of the Skip-Gram model and some familiarity with the construction and implementation of Hierarchical Softmax.</b></p>

<p>Please stay tuned~</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/4299" style="color: #005fcc;">https://kexue.fm/archives/4299</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
