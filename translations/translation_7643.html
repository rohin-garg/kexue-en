
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    tags: 'ams',
    packages: {'[+]': ['ams']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/7643">Do We Really Need to Reduce Training Set Loss to Zero?</a></h1>

<p>By 苏剑林 | July 31, 2020</p>

<p>When training a model, do we need the loss function to be trained all the way down to 0? Obviously not. Generally speaking, we use a training set to train the model, but what we hope for is that the loss on the validation set is as small as possible. Normally, after the training set loss drops to a certain value, the validation set loss will start to rise. Therefore, there is no need to reduce the training set loss to 0.</p>

<p>That being the case, after a certain threshold has already been reached, can we do something else to improve model performance? The ICML 2020 paper <a href="https://papers.cool/arxiv/2002.08709">"Do We Need Zero Training Loss After Achieving Zero Training Error?"</a> answers this question. However, the paper's answer is limited only to the level of "what it is" and does not describe "why" very well. Additionally, after reading the interpretation by the expert <a href="https://zhuanlan.zhihu.com/p/163676138">kid丶</a> on Zhihu, I still didn't find the answer I wanted. Therefore, I analyzed it myself and recorded it here.</p>

<h2>Description of Ideas <a id="思路描述" href="#思路描述">#</a></h2>

<p>The solution provided by the paper is very simple. Suppose the original loss function is $\mathcal{L}(\theta)$, it is now modified to $\tilde{\mathcal{L}}(\theta)$:</p>

\begin{equation}\tilde{\mathcal{L}}(\theta)=|\mathcal{L}(\theta) - b|+b\end{equation}

<p>where $b$ is a pre-set threshold. When $\mathcal{L}(\theta) > b$, $\tilde{\mathcal{L}}(\theta)=\mathcal{L}(\theta)$; at this time, ordinary gradient descent is executed. However, when $\mathcal{L}(\theta) < b$, $\tilde{\mathcal{L}}(\theta)=2b-\mathcal{L}(\theta)$. Notice that the sign of the loss function has changed, so at this point, it is gradient ascent. Therefore, in general, using $b$ as the threshold, when the loss is below the threshold, the goal is instead to increase the loss function. The paper calls this modification "Flooding."</p>

<p>What effect does this have? The paper shows that in certain tasks, after the training set loss function is processed this way, the "Double Descent" phenomenon can appear in the validation set loss, as shown in the figure below:</p>

<p style="text-align:center"><img src="https://kexue.fm/usr/uploads/2020/07/399086699.png" alt="Left: Training schematic without Flooding; Right: Training schematic with Flooding" /><br />Left: Training schematic without Flooding; Right: Training schematic with Flooding</p>

<p>Simply put, the final result on the validation set might be better. The experimental results from the original paper are as follows:</p>

<p style="text-align:center"><img src="https://kexue.fm/usr/uploads/2020/07/2021644788.png" alt="Flooding Experimental Results" /><br />Flooding experimental results. The "F" in the third row represents Flooding, and the columns with red checkmarks are those with Flooding added.</p>

<h2>Personal Analysis <a id="个人分析" href="#个人分析">#</a></h2>

<p>How do we explain this method? One can imagine that after the loss function reaches $b$, the training process roughly alternates between executing gradient descent and gradient ascent. Intuitively, it seems that one step of ascent and one step of descent would just cancel each other out. Is this actually the case? Let's do a calculation and see. Suppose we first perform one step of descent followed by one step of ascent, with a learning rate of $\varepsilon$, then:</p>

\begin{equation}\begin{aligned}&\theta_n = \theta_{n-1} - \varepsilon g(\theta_{n-1})\\
&\theta_{n+1} = \theta_n + \varepsilon g(\theta_n)
\end{aligned}\end{equation}

<p>where $g(\theta)=\nabla_{\theta}\mathcal{L}(\theta)$. Now we have</p>

\begin{equation}\begin{aligned}\theta_{n+1} =&\ e \theta_{n-1} - \varepsilon g(\theta_{n-1}) + \varepsilon g\big(\theta_{n-1} - \varepsilon g(\theta_{n-1})\big)\\
\approx&\ \theta_{n-1} - \varepsilon g(\theta_{n-1}) + \varepsilon \big(g(\theta_{n-1}) - \varepsilon \nabla_{\theta} g(\theta_{n-1}) g(\theta_{n-1})\big)\\
=&\ \theta_{n-1} - \frac{\varepsilon^2}{2}\nabla_{\theta}\Vert g(\theta_{n-1})\Vert^2
\end{aligned}\end{equation}

<p>The $\approx$ here uses the Taylor expansion to approximate the expansion of the loss function.</p>

<p>The final result is equivalent to gradient descent with a loss function consisting of a gradient penalty $\Vert g(\theta)\Vert^2=\Vert\nabla_{\theta}\mathcal{L}(\theta)\Vert^2$ and a learning rate of $\frac{\varepsilon^2}{2}$. More interestingly, if changed to "ascent first then descent," the expression remains the same (which reminds me of the story of "increasing the price by 10% then decreasing it by 10%" and "decreasing the price by 10% then increasing it by 10%"). Therefore, on average, the modification that Flooding makes to the loss function is equivalent to minimizing $\Vert\nabla_{\theta}\mathcal{L}(\theta)\Vert^2$ after ensuring that the loss function is small enough. This pushes the parameters toward a flatter region, which usually provides improved generalization performance (better resistance to perturbations), thus explaining to some extent why Flooding works.</p>

<p>In essence, this is not fundamentally different from adding random noise to parameters or adversarial training, etc., except that here perturbations are added only after ensuring the loss is small enough. Readers can refer to <a href="translation_7466.html">"Random Thoughts on Generalization: From Random Noise and Gradient Penalty to Virtual Adversarial Training"</a> to understand related content, or refer to the "Regularization" section in Chapter 7 of Part II of the "Bible" <i>Deep Learning</i>.</p>

<h2>Further Brainstorming <a id="继续脑洞" href="#继续脑洞">#</a></h2>

<p>Readers who intend to use this method may worry about the choice of $b$. However, I have another idea: $b$ simply determines when to start alternating training. What if we use different learning rates for alternating training from the very beginning? That is, always execute</p>

\begin{equation}\begin{aligned}&\theta_n = \theta_{n-1} - \varepsilon_1 g(\theta_{n-1})\\
&\theta_{n+1} = \theta_n + \varepsilon_2 g(\theta_n)
\end{aligned}\end{equation}

<p>where $\varepsilon_1 > \varepsilon_2$. This way, we remove $b$ (though we introduce the choice of $\varepsilon_1/\varepsilon_2$; there is no free lunch in this world). Repeating the above approximate expansion, we get</p>

\begin{equation}\begin{aligned}
\theta_{n+1} \approx&\ \theta_{n-1} - (\varepsilon_1 - \varepsilon_2) g(\theta_{n-1}) - \frac{\varepsilon_1\varepsilon_2}{2}\nabla_{\theta}\Vert g(\theta_{n-1})\Vert^2\\
=&\ \theta_{n-1} - (\varepsilon_1 - \varepsilon_2)\nabla_{\theta}\left[\mathcal{L}(\theta_{n-1}) + \frac{\varepsilon_1\varepsilon_2}{2(\varepsilon_1 - \varepsilon_2)}\Vert \nabla_{\theta}\mathcal{L}(\theta_{n-1})\Vert^2\right]
\end{aligned}\end{equation}

<p>This is equivalent to optimizing the loss function $\mathcal{L}(\theta) + \frac{\varepsilon_1\varepsilon_2}{2(\varepsilon_1 - \varepsilon_2)}\Vert\nabla_{\theta}\mathcal{L}(\theta)\Vert^2$ with a learning rate of $\varepsilon_1 - \varepsilon_2$ from start to finish. In other words, the gradient penalty is added from the beginning. Can this improve the model's generalization performance? I tried it briefly; in some cases, there is a slight improvement, and generally, there are no negative effects. Overall, it is not as good as directly adding the gradient penalty yourself, so I do not recommend doing it this way.</p>

<blockquote>Note: Reader <a href="https://kexue.fm/archives/7643#comment-14142">@xx205</a> provided the reference <a href="http://www.danielpovey.com/files/2017_interspeech_backstitch.pdf">"Backstitch: Counteracting Finite-sample Bias via Negative Steps"</a>, which points out that this approach is effective in speech recognition. Therefore, my statement above might not be entirely complete; readers please test and verify for yourselves. Thanks again to reader <a href="https://kexue.fm/archives/7643#comment-14142">@xx205</a> for the materials.</blockquote>

<h2>Conclusion <a id="文章小结" href="#文章小结">#</a></h2>

<p>This article briefly introduced a training strategy proposed in an ICML 2020 paper—"gradient ascent after reaching a certain point"—and provided my own derivation and understanding. The results show that it is equivalent to a gradient penalty on the parameters, and gradient penalty is one of the common regularization methods.</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/7643" style="color: #005fcc;">https://kexue.fm/archives/7643</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
