
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    macros: {
      Vert: "\\Vert"
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/9257">Talk on Generative Diffusion Models (9): Conditional Generation Control</a></h1>

<p>By 苏剑林 | August 30, 2022</p>

<p>The previous articles have mostly focused on theoretical results. In this article, we will discuss a topic of significant practical value: conditional controlled generation.</p>

<p>As generative models, the development of diffusion models closely mirrors that of VAEs, GANs, and flow models: unconditional generation appeared first, followed closely by conditional generation. Unconditional generation is often used to explore the upper bounds of performance, while conditional generation is more focused on application, as it allows us to control the output according to our intentions. Since the advent of DDPM, many works on conditional diffusion models have emerged; one could even say it was conditional diffusion models—such as the famous text-to-image models <a href="https://papers.cool/arxiv/2204.06125">DALL·E 2</a> and <a href="https://papers.cool/arxiv/2205.11487">Imagen</a>—that truly made diffusion models popular.</p>

<p>In this article, we will briefly study and summarize the theoretical foundations of conditional diffusion models.</p>

<h2 id="Technical Analysis">Technical Analysis <a href="https://kexue.fm/archives/9257#%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90">#</a></h2>

<p>Methodologically, there are two primary ways to achieve conditional generation: post-hoc modification (Classifier-Guidance) and pre-training (Classifier-Free).</p>

<p>For most people, the cost of training a SOTA-level diffusion model is prohibitive, whereas training a classifier is manageable. Therefore, the idea is to reuse an existing unconditional diffusion model trained by others and use a classifier to adjust the generation process to achieve controlled generation—this is the post-hoc Classifier-Guidance scheme. On the other hand, for "deep-pocketed" companies like Google and OpenAI, which do not lack data or computing power, they prefer to incorporate conditional signals directly into the training process of the diffusion model to achieve better generation quality—this is the pre-training Classifier-Free scheme.</p>

<p>The Classifier-Guidance scheme originated from <a href="https://papers.cool/arxiv/2105.05233">"Diffusion Models Beat GANs on Image Synthesis"</a>, initially used for class-conditional generation. Later, <a href="https://papers.cool/arxiv/2112.05744">"More Control for Free! Image Synthesis with Semantic Diffusion Guidance"</a> generalized the concept of the "Classifier," enabling generation based on images or text. The Classifier-Guidance scheme has lower training costs (NLP readers might recall the similar <a href="https://papers.cool/arxiv/1912.02164">PPLM model</a>), but higher inference costs, and its control over fine details is often not as precise.</p>

<p>As for the Classifier-Free scheme, it first appeared in <a href="https://papers.cool/arxiv/2207.12598">"Classifier-Free Diffusion Guidance"</a>. Subsequent eye-catching models like <a href="https://papers.cool/arxiv/2204.06125">DALL·E 2</a> and <a href="https://papers.cool/arxiv/2205.11487">Imagen</a> are basically built upon it. It is worth mentioning that although the paper was only posted to Arxiv last month, it was actually accepted at NeurIPS 2021 last year. It should be said that the Classifier-Free scheme itself has little theoretical novelty; it is the most straightforward approach to conditional diffusion models. It appeared later simply because of the high cost of re-training diffusion models. Given sufficient data and computing power, the Classifier-Free scheme has demonstrated astonishing detail-control capabilities.</p>

<h2 id="Conditional Input">Conditional Input <a href="https://kexue.fm/archives/9257#%E6%9D%A1%E4%BB%B6%E8%BE%93%E5%85%A5">#</a></h2>

<p>Essentially, the Classifier-Free scheme is just expensive to train and "lacks technical complexity" in itself, so most of this article will focus on the Classifier-Guidance scheme, with Classifier-Free introduced briefly at the end.</p>

<p>As readers of our previous articles know, the most critical step in a generative diffusion model is the construction of the generation process $p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)$. For generation conditioned on an input $\boldsymbol{y}$, we simply replace $p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)$ with $p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y})$, meaning we add $\boldsymbol{y}$ as an input to the generation process. To reuse a pre-trained unconditional model $p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)$, we use Bayes' theorem:
\begin{equation}p(\boldsymbol{x}_{t-1}|\boldsymbol{y}) = \frac{p(\boldsymbol{x}_{t-1})p(\boldsymbol{y}|\boldsymbol{x}_{t-1})}{p(\boldsymbol{y})}\end{equation}
By adding the condition $\boldsymbol{x}_t$ to each term, we get:
\begin{equation}p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y}) = \frac{p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)p(\boldsymbol{y}|\boldsymbol{x}_{t-1}, \boldsymbol{x}_t)}{p(\boldsymbol{y}|\boldsymbol{x}_t)}\label{eq:bayes-1}\end{equation}
Note that in the forward process, $\boldsymbol{x}_t$ is obtained by adding noise to $\boldsymbol{x}_{t-1}$. Since noise does not help with classification, adding $\boldsymbol{x}_t$ provides no benefit for classification given $\boldsymbol{x}_{t-1}$. Thus, $p(\boldsymbol{y}|\boldsymbol{x}_{t-1}, \boldsymbol{x}_t) = p(\boldsymbol{y}|\boldsymbol{x}_{t-1})$, leading to:
\begin{equation}p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y}) = \frac{p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)p(\boldsymbol{y}|\boldsymbol{x}_{t-1})}{p(\boldsymbol{y}|\boldsymbol{x}_t)} = p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t) e^{\log p(\boldsymbol{y}|\boldsymbol{x}_{t-1}) - \log p(\boldsymbol{y}|\boldsymbol{x}_t)}\label{eq:bayes-2}\end{equation}</p>

<h2 id="Approximate Distribution">Approximate Distribution <a href="https://kexue.fm/archives/9257#%E8%BF%91%E4%BC%BC%E5%88%86%E5%B8%83">#</a></h2>

<p>Readers who have read <a href="translation_9209.html">"Talk on Generative Diffusion Models (5): General Framework SDE Edition"</a> will find the following process familiar. However, even if you haven't, we will provide the full derivation below.</p>

<p>When $T$ is sufficiently large, the variance of $p(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})$ is small enough that the probability is only significantly greater than 0 when $\boldsymbol{x}_t$ is very close to $\boldsymbol{x}_{t-1}$. The converse is also true: $p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y})$ or $p(\boldsymbol{x}_t|\boldsymbol{x}_{t-1}, \boldsymbol{y})$ is only significant when $\boldsymbol{x}_t$ and $\boldsymbol{x}_{t-1}$ are very close. We only need to focus on probability changes within this range. Using a Taylor expansion:
\begin{equation}\log p(\boldsymbol{y}|\boldsymbol{x}_{t-1}) - \log p(\boldsymbol{y}|\boldsymbol{x}_t)\approx (\boldsymbol{x}_{t-1} - \boldsymbol{x}_t)\cdot\nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t)\end{equation}
Strictly speaking, there is also a term regarding the change in $t$, but it does not depend on $\boldsymbol{x}_{t-1}$ and is therefore a constant term that does not affect the probability distribution of $\boldsymbol{x}_{t-1}$, so we omit it. Assuming the original $p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t) = \mathcal{N}(\boldsymbol{x}_{t-1}; \boldsymbol{\mu}(\boldsymbol{x}_t), \sigma_t^2\boldsymbol{I}) \propto e^{-\Vert \boldsymbol{x}_{t-1} - \boldsymbol{\mu}(\boldsymbol{x}_t)\Vert^2/2\sigma_t^2}$, we then have the approximation:
\begin{equation}\begin{aligned}
p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y}) \propto&\, e^{-\Vert \boldsymbol{x}_{t-1} - \boldsymbol{\mu}(\boldsymbol{x}_t)\Vert^2/2\sigma_t^2 + (\boldsymbol{x}_{t-1} - \boldsymbol{x}_t)\cdot\nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t)} \\
\propto&\, e^{-\Vert \boldsymbol{x}_{t-1} - \boldsymbol{\mu}(\boldsymbol{x}_t) - \sigma_t^2 \nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t))\Vert^2/2\sigma_t^2}
\end{aligned}\end{equation}
From this, it can be seen that $p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y})$ is approximately $\mathcal{N}(\boldsymbol{x}_{t-1}; \boldsymbol{\mu}(\boldsymbol{x}_t) + \sigma_t^2 \nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t), \sigma_t^2\boldsymbol{I})$. Thus, we only need to modify the sampling in the generation process to:
\begin{equation}\boldsymbol{x}_{t-1} = \boldsymbol{\mu}(\boldsymbol{x}_t) \color{skyblue}{+} {\color{skyblue}{\underbrace{\sigma_t^2 \nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t)}_{\text{Additional Term}}}} + \sigma_t\boldsymbol{\varepsilon},\quad \boldsymbol{\varepsilon}\sim \mathcal{N}(\boldsymbol{0},\boldsymbol{I})\end{equation}
This is the core result of the Classifier-Guidance scheme. Note that the input to $p(\boldsymbol{y}|\boldsymbol{x}_t)$ is the noisy sample $\boldsymbol{x}_t$, which means we need a model that can predict from noisy samples. If we only have a model $p_o(\boldsymbol{y}|\boldsymbol{x})$ for noise-free samples, we can consider using $p(\boldsymbol{y}|\boldsymbol{x}_t)$ as:
\begin{equation}p(\boldsymbol{y}|\boldsymbol{x}_t) = p_{o}(\boldsymbol{y}|\boldsymbol{\mu}(\boldsymbol{x}_t))\end{equation}
That is, we use $\boldsymbol{\mu}(\cdot)$ to denoise $\boldsymbol{x}_t$ before passing it to $p(\boldsymbol{y}|\boldsymbol{x}_t)$, which avoids the cost of training a classifier on noisy samples.</p>

<h2 id="Gradient Scaling">Gradient Scaling <a href="https://kexue.fm/archives/9257#%E6%A2%AF%E5%BA%A6%E7%BC%A9%E6%94%BE">#</a></h2>

<p>The original paper (<a href="https://papers.cool/arxiv/2105.05233">"Diffusion Models Beat GANs on Image Synthesis"</a>) found that introducing a scaling parameter $\gamma$ into the classifier gradient can better adjust the generation effect:
\begin{equation}\boldsymbol{x}_{t-1} = \boldsymbol{\mu}(\boldsymbol{x}_t) \color{skyblue}{+} \color{skyblue}{\sigma_t^2 \color{red}{\gamma}\nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t)} + \sigma_t\boldsymbol{\varepsilon},\quad \boldsymbol{\varepsilon}\sim \mathcal{N}(\boldsymbol{0},\boldsymbol{I})\label{eq:gamma-sample}\end{equation}
When $\gamma > 1$, the generation process will use more classifier signals. This improves the correlation between the generation result and the input signal $\boldsymbol{y}$, but it reduces the diversity of the generated results accordingly. Conversely, decreasing $\gamma$ reduces the correlation but increases diversity.</p>

<p>How do we understand this parameter theoretically? The original paper suggested viewing it as increasing the focus of the distribution via a power operation, i.e., defining:
\begin{equation}\tilde{p}(\boldsymbol{y}|\boldsymbol{x}_t) = \frac{p^{\gamma}(\boldsymbol{y}|\boldsymbol{x}_t)}{Z(\boldsymbol{x}_t)},\quad Z(\boldsymbol{x}_t)=\sum_{\boldsymbol{y}} p^{\gamma}(\boldsymbol{y}|\boldsymbol{x}_t)\end{equation}
As $\gamma$ increases, the prediction $\tilde{p}(\boldsymbol{y}|\boldsymbol{x}_t)$ becomes closer to a one-hot distribution. Using this instead of $p(\boldsymbol{y}|\boldsymbol{x}_t)$ for Classifier-Guidance makes the generation process tend to pick samples with higher classification confidence.</p>

<p>However, while this perspective has some reference value, it isn't entirely correct because:
\begin{equation}\nabla_{\boldsymbol{x}_t}\log \tilde{p}(\boldsymbol{y}|\boldsymbol{x}_t) = \gamma\nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t) - \nabla_{\boldsymbol{x}_t} \log Z(\boldsymbol{x}_t) \neq \gamma\nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t)\end{equation}
The original paper mistakenly assumed that $Z(\boldsymbol{x}_t)$ is a constant, so $\nabla_{\boldsymbol{x}_t} \log Z(\boldsymbol{x}_t)=0$. But in fact, when $\gamma\neq 1$, $Z(\boldsymbol{x}_t)$ explicitly depends on $\boldsymbol{x}_t$. The author also gave some thought to whether there is any remedy for this, but unfortunately, there were no results; we can only weakly assume that the gradient properties at $\gamma=1$ (where $Z(\boldsymbol{x}_t)=1$) can be approximately generalized to the case where $\gamma\neq 1$.</p>

<h2 id="Similarity Control">Similarity Control <a href="https://kexue.fm/archives/9257#%E7%9B%B8%E4%BC%BC%E6%8E%A7%E5%88%B6">#</a></h2>

<p>In fact, the best way to understand $\gamma\neq 1$ is to give up on understanding $p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y})$ through Bayes' theorem as in equations $\eqref{eq:bayes-1}$ and $\eqref{eq:bayes-2}$, and instead directly define:
\begin{equation}p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y}) = \frac{p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t) e^{\gamma\cdot\text{sim}(\boldsymbol{x}_{t-1}, \boldsymbol{y})}}{Z(\boldsymbol{x}_t, \boldsymbol{y})},\quad Z(\boldsymbol{x}_t,\boldsymbol{y})=\sum_{\boldsymbol{x}_{t-1}} p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t) e^{\gamma\cdot\text{sim}(\boldsymbol{x}_{t-1}, \boldsymbol{y})}\end{equation}
where $\text{sim}(\boldsymbol{x}_{t-1}, \boldsymbol{y})$ is some measure of similarity or correlation between the generation result $\boldsymbol{x}_{t-1}$ and the condition $\boldsymbol{y}$. Under this perspective, $\gamma$ is directly integrated into the definition of $p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y})$, controlling the correlation between result and condition. When $\gamma$ is larger, the model tends to generate $\boldsymbol{x}_{t-1}$ that is more relevant to $\boldsymbol{y}$.</p>

<p>To further obtain a sampleable approximation, we can expand at $\boldsymbol{x}_{t-1}=\boldsymbol{x}_t$ (or at $\boldsymbol{x}_{t-1}=\boldsymbol{\mu}(\boldsymbol{x}_t)$, as before):
\begin{equation}e^{\gamma\cdot\text{sim}(\boldsymbol{x}_{t-1}, \boldsymbol{y})}\approx e^{\gamma\cdot\text{sim}(\boldsymbol{x}_t, \boldsymbol{y}) + \gamma\cdot(\boldsymbol{x}_{t-1}-\boldsymbol{x}_t)\cdot\nabla_{\boldsymbol{x}_t}\text{sim}(\boldsymbol{x}_t, \boldsymbol{y})}
\end{equation}
Assuming this approximation is sufficient, and removing terms independent of $\boldsymbol{x}_{t-1}$, we get:
\begin{equation}p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y})\propto p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)e^{\gamma\cdot(\boldsymbol{x}_{t-1}-\boldsymbol{x}_t)\cdot\nabla_{\boldsymbol{x}_t}\text{sim}(\boldsymbol{x}_t, \boldsymbol{y})}
\end{equation}
As before, substituting $p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)=\mathcal{N}(\boldsymbol{x}_{t-1}; \boldsymbol{\mu}(\boldsymbol{x}_t), \sigma_t^2\boldsymbol{I})$ and completing the square results in:
\begin{equation}p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y})\approx \mathcal{N}(\boldsymbol{x}_{t-1}; \boldsymbol{\mu}(\boldsymbol{x}_t) + \sigma_t^2\gamma \nabla_{\boldsymbol{x}_t} \text{sim}(\boldsymbol{x}_t, \boldsymbol{y}), \sigma_t^2\boldsymbol{I})
\end{equation}</p>

<p>This way, we don't have to worry about the probabilistic meaning of $p(\boldsymbol{y}|\boldsymbol{x}_t)$, but only need to directly define the metric function $\text{sim}(\boldsymbol{x}_t, \boldsymbol{y})$. Here, $\boldsymbol{y}$ is no longer limited to "categories"; it can be any input signal such as text or images. Usually, these are processed by their respective encoders into feature vectors, and cosine similarity is used:
\begin{equation}\text{sim}(\boldsymbol{x}_t, \boldsymbol{y}) = \frac{E_1(\boldsymbol{x}_t)\cdot E_2(\boldsymbol{y})}{\Vert E_1(\boldsymbol{x}_t)\Vert \Vert E_2(\boldsymbol{y})\Vert}\end{equation}
It should be pointed out that $\boldsymbol{x}_t$ in the intermediate process is noisy, so the encoder $E_1$ generally should not be the one trained on clean data; it's better to fine-tune it with noisy data. Furthermore, for style transfer, Gram matrix distance is typically used instead of cosine similarity, depending on the scenario. These are the series of results from the paper <a href="https://papers.cool/arxiv/2112.05744">"More Control for Free! Image Synthesis with Semantic Diffusion Guidance"</a>. For more details, please refer to the original paper.</p>

<h2 id="Continuous Cases">Continuous Cases <a href="https://kexue.fm/archives/9257#%E8%BF%9E%E7%BB%AD%E6%83%85%E5%BD%A2">#</a></h2>

<p>After the previous derivations, we found that the correction term for the mean is $\sigma_t^2 \gamma \nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t)$ or $\sigma_t^2\gamma \nabla_{\boldsymbol{x}_t} \text{sim}(\boldsymbol{x}_t, \boldsymbol{y})$. They share a common trait: when $\sigma_t=0$, the correction term also equals 0, and the control fails.</p>

<p>So, can $\sigma_t$ in the generation process be equal to 0? Certainly. For example, the DDIM introduced in <a href="translation_9181.html">"Talk on Generative Diffusion Models (4): DDIM = High-level perspective DDPM"</a> is a generation process with zero variance. In this case, how do we perform controlled generation? Here, we need to use the general SDE-based results introduced in <a href="translation_9228.html">"Talk on Generative Diffusion Models (6): General Framework ODE Edition"</a>. In that article, we introduced that for a forward SDE:
\begin{equation}d\boldsymbol{x} = \boldsymbol{f}_t(\boldsymbol{x}) dt + g_t d\boldsymbol{w}\end{equation}
The corresponding most general reverse SDE is:
\begin{equation}d\boldsymbol{x} = \left(\boldsymbol{f}_t(\boldsymbol{x}) - \frac{1}{2}(g_t^2 + \sigma_t^2)\nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{x})\right) dt + \sigma_t d\boldsymbol{w}\end{equation}
This allows us to freely choose the reverse variance $\sigma_t^2$. DDPM and DDIM can both be seen as special cases, where $\sigma_t=0$ corresponds to a generalized DDIM. As can be seen, the only part of the reverse SDE related to the input is $\nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{x})$. If we want to do conditional generation, we naturally replace it with $\nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{x}|\boldsymbol{y})$. Using Bayes' theorem:
\begin{equation}\nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{x}|\boldsymbol{y}) = \nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{x}) + \nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{y}|\boldsymbol{x})\end{equation}
Under common parameterization, $\nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{x}) = -\frac{\boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)}{\bar{\beta}_t}$, therefore:
\begin{equation}\nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{x}|\boldsymbol{y}) = -\frac{\boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)}{\bar{\beta}_t} + \nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{y}|\boldsymbol{x}) = -\frac{\boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) - \bar{\beta}_t\nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{y}|\boldsymbol{x})}{\bar{\beta}_t}\end{equation}
This means that regardless of the generation variance, we only need to replace $\boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$ with $\boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) - \bar{\beta}_t\nabla_{\boldsymbol{x}}\log p_t(\boldsymbol{y}|\boldsymbol{x})$ to achieve conditional controlled generation. Therefore, under the unified perspective of SDEs, we can very simply and directly obtain the most general results for the Classifier-Guidance scheme.</p>

<h2 id="Classifier-Free">Classifier-Free <a href="https://kexue.fm/archives/9257#%E6%97%A0%E5%88%86%E7%B1%BB%E5%99%A8">#</a></h2>

<p>Finally, we briefly introduce the Classifier-Free scheme. It's actually very simple: it directly defines:
\begin{equation}p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{y}) = \mathcal{N}(\boldsymbol{x}_{t-1}; \boldsymbol{\mu}(\boldsymbol{x}_t, \boldsymbol{y}), \sigma_t^2\boldsymbol{I})
\end{equation}
Following the results from the previous DDPM articles, $\boldsymbol{\mu}(\boldsymbol{x}_t, \boldsymbol{y})$ is generally parameterized as:
\begin{equation}\boldsymbol{\mu}(\boldsymbol{x}_t, \boldsymbol{y}) = \frac{1}{\alpha_t}\left(\boldsymbol{x}_t - \frac{\beta_t^2}{\bar{\beta}_t}\boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, \boldsymbol{y}, t)\right)\end{equation}
The loss function for training is:
\begin{equation}\mathbb{E}_{\boldsymbol{x}_0,\boldsymbol{y}\sim\tilde{p}(\boldsymbol{x}_0,\boldsymbol{y}), \boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\left\Vert\boldsymbol{\varepsilon} - \boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\bar{\alpha}_t \boldsymbol{x}_0 + \bar{\beta}_t \boldsymbol{\varepsilon}, \boldsymbol{y}, t)\right\Vert^2\right]\end{equation}
Its advantage is that the additional input $\boldsymbol{y}$ is introduced during the training process; theoretically, more input information makes training easier. Its disadvantage is also that $\boldsymbol{y}$ is introduced during training, which means every time you want to introduce a new type of signal control, you must retrain the entire diffusion model.</p>

<p>Notably, the Classifier-Free scheme also mimicked the scaling mechanism of the $\gamma$ parameter from Classifier-Guidance to balance correlation and diversity. Specifically, the mean in equation $\eqref{eq:gamma-sample}$ can be rewritten as:
\begin{equation}\boldsymbol{\mu}(\boldsymbol{x}_t) + \sigma_t^2 \gamma \nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t) = \gamma\left[\boldsymbol{\mu}(\boldsymbol{x}_t) + \sigma_t^2 \nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t)\right] - (\gamma - 1) \boldsymbol{\mu}(\boldsymbol{x}_t)\end{equation}
The Classifier-Free scheme essentially fits $\boldsymbol{\mu}(\boldsymbol{x}_t) + \sigma_t^2 \nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{y}|\boldsymbol{x}_t)$ directly with the model. By analogy with the equation above, we can also introduce a parameter $w = \gamma - 1$ in the Classifier-Free scheme and use:
\begin{equation}\tilde{\boldsymbol{\epsilon}}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, \boldsymbol{y}, t) = (1 + w)\boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, \boldsymbol{y}, t) - w \boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)\end{equation}
to replace $\boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, \boldsymbol{y}, t)$ during generation. Where does the unconditional $\boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$ come from? We can introduce a specific input $\boldsymbol{\phi}$, whose target images consist of all images, and include it in the model training. This way, we can consider $\boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) = \boldsymbol{\epsilon}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, \boldsymbol{\phi}, t)$.</p>

<h2 id="Summary">Summary <a href="https://kexue.fm/archives/9257#%E6%96%87%E7%AB%A0%E5%B0%8F%E7%BB%93">#</a></h2>

<p>This article briefly introduced the theoretical results for building conditional diffusion models, mainly including post-hoc modification (Classifier-Guidance) and pre-training (Classifier-Free) schemes. The former does not require retraining the diffusion model and can achieve simple control at low cost; the latter requires retraining the diffusion model, which is more expensive but allows for more refined control.</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/9257" style="color: #005fcc;">https://kexue.fm/archives/9257</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
