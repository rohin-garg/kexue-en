
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    tags: 'ams',
    packages: {'[+]': ['ams']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
    <h1><a href="https://kexue.fm/archives/5577">The Principle of Minimum Entropy (III): "Flying Elephant Across the River" — Sentence Templates and Language Structures</a></h1>

    <p>By 苏剑林 | May 30, 2018</p>

    <p>In the previous article, <a href="translation_5476.html">"The Principle of Minimum Entropy (II): building a lexicon via 'Decisiveness'"</a>, we used the principle of minimum entropy as a starting point for a series of mathematical derivations, eventually arriving at equations $(2.15)$ and $(2.17)$. These tell us that elements with high mutual information should be merged, as this helps reduce "learning difficulty." Using this principle, we achieved unsupervised lexicon generation through adjacent character mutual information.</p>

    <p>From characters to words, and from words to phrases, we have been examining whether adjacent elements can be merged into a good "pattern." But why must patterns be adjacent? Of course, they don't have to be. When we learn a language, we learn not only words and phrases but also "fixed collocations"—that is, how words are used together reasonably. This is the manifestation of grammar, which is what this article aims to explore, hoping to eventually achieve a degree of unsupervised syntactic analysis.</p>

    <p>Since we are considering language associations across non-adjacent words, I have named it "Flying Elephant Across the River" (a move in Chinese chess where the elephant jumps across the central line), precisely:</p>

    <blockquote>The second movement of the "Tome of Patterns" — "Flying Elephant Across the River"</blockquote>

    <h2 id="语言结构">Language Structure</h2>

    <p>For most people, they don't really know what grammar is; in their minds, there are only "fixed collocations," "fixed formulas," or more formally, "templates." In most cases, we speak reasonable sentences based on templates. Different people may have different speaking templates, which represent personal speaking styles or even "catchphrases."</p>

    <h3 id="句模版">Sentence Templates</h3>

    <p>For example, "What is the Y of X" is a simple template. It has specific words like "is," "the," "of," "what," and placeholders X and Y. By simply substituting two nouns for X and Y, we get a grammatically correct sentence (whether it is factual or not is another matter). Many such templates can be listed: "X and Y," "the Y of X," "Can X do Y?", "What are the Ys of X?", "Is it X, Y, or Z?", and so on.</p>

    <p style="text-align:center"><img src="https://kexue.fm/usr/uploads/2018/05/1758661642.png" alt="Sentence template and nested usage example" /><br />
    <em>Sentence template and nested usage example</em></p>

    <p>Of course, while we can extract as many templates as possible, a finite number of templates cannot cover the ever-changing possibilities of language. Therefore, it is more important to use templates based on nesting. For example, in the template "What is the Y of X," X can be replaced by the template "A and B," resulting in "What is the Y of (A and B)?" In this way, through nested templates, a vast number of sentences can be obtained.</p>

    <h3 id="等价类">Equivalence Classes</h3>

    <p>Next, once we have the template "What is the Y of X?", how do we know what can be filled in X and Y?</p>

    <p>We just said "substitute two nouns," but according to our approach so far, we only know how to build a lexicon; we don't even know what a "noun" is, let alone that a noun should be filled in. In fact, we don't need to know anything in advance. We can extract "equivalence classes" for each candidate position through a large corpus, where the candidate words for X form one equivalence class, the candidates for Y form another, and so on.</p>

    <p style="text-align:center"><img src="https://kexue.fm/usr/uploads/2018/05/291686701.png" alt="Sentence templates and the concept of equivalence classes" /><br />
    <em>Sentence templates and the concept of equivalence classes</em></p>

    <p><strong>Of course, such a plan is quite ideal. In fact, the raw corpora we currently obtain are in much worse condition. But regardless, "a skyscraper starts from the ground"; we will first solve the ideal case and consider general cases during actual use.</strong></p>

    <p>Below we will explore, one by one, how to obtain sentence templates from large amounts of raw corpora, how to recognize the sentence templates used in sentences, and even how to mine the hierarchical structure of sentences.</p>

    <h2 id="生成模版">Generating Templates</h2>

    <p>In fact, with the experience of building a lexicon from the previous article, it is not difficult to conceive an algorithm for generating sentence templates.</p>

    <p>In lexicon construction, our statistical objects were characters; now, our statistical objects are words. Furthermore, words are composed of adjacent characters, but sentence templates are not necessarily composed of adjacent words (otherwise they would degenerate into words or phrases). Therefore, we also need to consider cross-word co-occurrence, which is the Skip-Gram model used in Word2Vec.</p>

    <h3 id="有向无环图">Directed Acyclic Graph</h3>

    <p>A Directed Acyclic Graph (DAG) is a graph theory model frequently encountered in NLP. In fact, the unigram word segmentation model can be abstractly viewed as a shortest path planning problem on a DAG. The construction of the candidate template set here also requires the use of a DAG.</p>

    <p>Because we consider the Skip-Gram model, we can connect "word pairs" within a sentence that are relatively "tight" (high mutual information). From a graph theory perspective, this forms a "Directed Acyclic Graph":</p>

    <p style="text-align:center"><img src="https://kexue.fm/usr/uploads/2018/05/3545041075.png" alt="Directed acyclic graph formed by sentence and Skip-Gram relationships" /><br />
    <em>Directed acyclic graph formed by sentence and Skip-Gram relationships</em></p>

    <p>We extract all paths on the graph. If a path skips adjacent nodes, we insert a placeholder (denoted as X below). This generates a candidate template set. For example, from the graph above, extracted candidate templates might include:</p>

    <blockquote>Computer X Mouse X<br />
    X's X has what X's X?<br />
    X's X has what X?<br />
    X is relatively X</blockquote>

    <h3 id="算法步骤">Algorithm Steps</h3>

    <p>We can specifically describe the above process as follows:</p>

    <blockquote>
        1. Segment the corpus into sentences and tokenize them;<br />
        2. Select a window size <i>window</i>. Count individual word frequencies ($p_a, p_b$) and co-occurrence frequencies ($p_{ab}$) for Any two words within the window size in the corpus;<br />
        3. Set a threshold for occurrence frequency $min\_prob$ and a threshold for mutual information $min\_pmi$;<br />
        4. Traverse all sentences:<br />
        &nbsp;&nbsp;&nbsp;&nbsp;4.1. Construct a graph for each sentence, where words in the sentence are nodes;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;4.2. For word pairs $(a, b)$ within the window in the sentence, if $p_{ab} > min\_prob$ and $\ln\frac{p_{ab}}{p_a p_b} > min\_pmi$, add a directed edge "a --> b" to the graph;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;4.3. Find all paths on the graph (isolated points also count as paths) and add them to the statistics as candidate templates.<br />
        5. Count the frequency of each "quasi-template," sort them in descending order by frequency, and take the top portion.
    </blockquote>

    <p><strong>This algorithm can be used for extracting sentence templates and also simply for extracting phrases (collocations) by setting the window to 1. Therefore, it essentially encompasses the lexicon construction mentioned in the previous article; thus, the algorithm above is a generalized extraction framework.</strong></p>

    <h3 id="效果演示">Effect Demonstration</h3>

    <p>Below are some sentence templates extracted from the <a href="translation_5067.html">Baidu Zhidao question set</a> (the numbers are the calculated frequencies, which can be ignored):</p>

    <blockquote>
        &lt; Template: [X] 的 [X] &gt; 20199<br />
        &lt; Template: [X] 吗 &gt; 9695<br />
        &lt; Template: [X] 是 [X] &gt; 5358<br />
        &lt; Template: [X] 的 &gt; 3979<br />
        &lt; Template: [X] 和 [X] &gt; 3919<br />
        &lt; Template: 我 [X] &gt; 3766<br />
        &lt; Template: [X] 有 [X] &gt; 3568<br />
        &lt; Template: [X] 了 &gt; 2910<br />
        &lt; Template: [X] 了 [X] &gt; 2702<br />
        &lt; Template: [X] 怎么 [X] &gt; 2340<br />
        &lt; Template: [X] 到 [X] &gt; 2254<br />
        &lt; Template: [X] 在 [X] &gt; 2234<br />
        &lt; Template: [X] 我 [X] &gt; 2147<br />
        &lt; Template: [X] 不 [X] &gt; 1708<br />
        &lt; Template: 求 [X] &gt; 1547<br />
        &lt; Template: [X] 怎么样 &gt; 1371
    </blockquote>

    <p>Note that templates like "X 的 X" and "X 怎么 X," where a word is sandwiched between two placeholders, are trivial; they simply tell us that the word can be inserted into a sentence. Therefore, to see the effect more clearly, we exclude this type of template and get:</p>

    <blockquote>
        &lt; Template: [X] 吗 &gt; 9695<br />
        &lt; Template: [X] 的 &gt; 3979<br />
        &lt; Template: 我 [X] &gt; 3766<br />
        &lt; Template: [X] 了 &gt; 2910<br />
        &lt; Template: 求 [X] &gt; 1547<br />
        &lt; Template: [X] 怎么样 &gt; 1371<br />
        &lt; Template: [X] 啊 &gt; 1324<br />
        &lt; Template: 有 [X] &gt; 1319<br />
        &lt; Template: [X] 怎么办 &gt; 1232<br />
        &lt; Template: 为什么 [X] &gt; 1220<br />
        &lt; Template: 请问 [X] &gt; 1189<br />
        &lt; Template: [X] 呢 &gt; 1099<br />
        &lt; Template: [X] 么 &gt; 1003<br />
        &lt; Template: 谢谢 &gt; 997<br />
        &lt; Template: 怎么 [X] &gt; 903<br />
        &lt; Template: 在 [X] &gt; 894<br />
        &lt; Template: 现在 [X] &gt; 874<br />
        &lt; Template: 如何 [X] &gt; 867<br />
        &lt; Template: [X] 好 &gt; 798<br />
        &lt; Template: [X] 是 [X] 意思 &gt; 728<br />
        &lt; Template: 是 [X] &gt; 727<br />
        &lt; Template: [X] 是什么意思 &gt; 721<br />
        &lt; Template: [X] 是什么 &gt; 684<br />
        &lt; Template: 怎么办 &gt; 589<br />
        &lt; Template: 有没有 [X] &gt; 582<br />
        &lt; Template: [X] 多少钱 &gt; 550<br />
        &lt; Template: 从 [X] &gt; 526<br />
        &lt; Template: 什么 [X] &gt; 522<br />
        &lt; Template: [X] 有哪些 &gt; 490<br />
        &lt; Template: [X] 是什么 [X] &gt; 483
    </blockquote>

    <p>From the results, our sentence template generation is indeed effective, as these templates help us discover rules of language usage. For example:</p>

    <blockquote>
        1. Templates like "[X] 吗", "[X] 了", "[X] 怎么样" have placeholders at the beginning, indicating these words can be placed at the end of a question (the corpus used consists of questions).<br />
        2. Templates like "我 [X]", "求 [X]", "为什么 [X]", "请问 [X]" have placeholders at the end, indicating these words can be placed at the beginning of a question.<br />
        3. Templates like "谢谢" and "怎么办" have no placeholders, indicating they can stand alone as sentences.<br />
        4. Templates like "[X] 是 [X] 意思" and "[X] 是什么 [X]" reflect fixed collocations in the language.
    </blockquote>

    <p>From a general perspective, these templates describe syntactic-level linguistic phenomena. Of course, to avoid confusion with current mainstream syntactic analysis, we might as well call them language structural patterns, or directly "sentence templates."</p>

    <h2 id="结构解析">Structural Analysis</h2>

    <p><strong>Just like word segmentation, once sentence templates are constructed, we need an algorithm to identify which templates are used in a sentence. Only by achieving this step can we identify equivalence classes of words from the corpus.</strong></p>

    <p>Looking back at the word segmentation algorithm, word segmentation is just a problem of sentence partitioning. The words partitioned out have no "holes" (placeholders). However, if we want to identify which templates are used in a sentence, templates have "holes" and can be nested, which makes identification difficult. Yet, once we can accomplish this, we obtain a hierarchical structural decomposition of the sentence, which is a very attractive goal.</p>

    <h3 id="投射性假设">Projectivity Hypothesis</h3>

    <p>To implement hierarchical decomposition of sentences, we can first borrow the "projectivity hypothesis" commonly used in syntactic analysis.</p>

    <p>Projectivity in language roughly means that if a sentence can be divided into several "semantic blocks," these blocks do not overlap. That is, if words 1, 2, and 3 form one semantic block, and words 4 and 5 form another, this is allowed. But if words 1, 2, and 4 form a semantic block and words 3 and 5 form another, this is impossible. Most languages, including Chinese and English, basically satisfy projectivity.</p>

    <h3 id="结构假设">Structural Hypothesis</h3>

    <p>To complete the hierarchical structural decomposition of a sentence, we need to make a more complete hypothesis about the compositional structure of the sentence. Inspired by the projectivity hypothesis, I believe we can make the following assumptions about sentence structure:</p>

    <blockquote>
        1. Each semantic block is a continuous substring of the sentence, and the sentence itself is also a semantic block;<br />
        2. Each semantic block is generated by a primary sentence template, where the placeholder parts of the template are also semantic blocks;<br />
        3. Each individual word can be viewed as a trivial sentence template and also as a semantic block of the smallest granularity.
    </blockquote>

    <p>In short, these three assumptions can be summarized in one sentence:</p>

    <blockquote>Every sentence is generated by the mutual nesting of sentence templates.</blockquote>

    <p>At first glance, this assumption may seem unreasonable, but careful thought reveals it is sufficient to describe the structure of most sentences. Readers might have doubts like: "Is it possible to use two sentence templates in parallel rather than nested?" The answer is: probably not. Because if this happens, the "parallelism" itself can be viewed as a template. For example, by treating "X and X" as a template, the two semantic blocks in this template are parallel; it can even be nested with itself as "X and (X and X)" to describe more parallel phenomena.</p>

    <p><strong>Precisely because we made this assumption about language structure, once we identify the optimal sentence template combination for a sentence, we obtain its hierarchical structure—because per the assumption, templates are combined via nesting, nesting implies recursion, and recursion is a tree-like hierarchical structure.</strong></p>

    <h3 id="分解算法">Decomposition Algorithm</h3>

    <p>With the structural hypothesis, we can describe the template recognition algorithm. First, let's restate the word segmentation algorithm. The idea of unigram word segmentation is:</p>

    <blockquote>Segment a sentence into words such that the sum of the logarithms of their probabilities is maximized (the sum of information is minimized).</blockquote>

    <p>It can also be expressed as follows:</p>

    <blockquote>Find a series of words to cover every character in the sentence without repetition or omission, such that the sum of the logarithms of their probabilities is maximized (the sum of information is minimized).</blockquote>

    <p>Previously, we thought of segmentation as cutting the sentence; this equivalent expression reverses it, requiring coverage of the sentence. With this reverse thinking, we can propose a template recognition algorithm:</p>

    <blockquote>Find a series of sentence templates to cover every word in the sentence without repetition, omission, or overlap, such that the sum of the logarithms of their probabilities is maximized (the sum of information is minimized).</blockquote>

    <p>Of course, this is just the idea. In the implementation, the main difficulty is handling placeholders—that is, each word in the sentence represents both itself and a potential placeholder. This duality makes scanning and recognition difficult. Fortunately, following the structural assumptions above, we can transform it into a recursive calculation:</p>

    <blockquote>In the optimal structural decomposition scheme, the decomposition scheme for each semantic block under the main template is also optimal.</blockquote>

    <p style="text-align:center"><img src="https://kexue.fm/usr/uploads/2018/05/291686701.png" alt="Hierarchical structure analysis of a sentence, containing nested template calls" /><br />
    <em>Hierarchical structure analysis of a sentence, containing nested template calls</em></p>

    <p>Thus, we get the algorithm:</p>

    <blockquote>
        1. Scan for all possible templates appearing in the sentence (this can be done quickly using a Trie structure);<br />
        2. The score of each decomposition scheme equals the score of the main template of the sentence plus the score of the optimal decomposition scheme for each semantic block.
    </blockquote>

    <h3 id="结果展示">Result Display</h3>

    <p>Below are demonstrations of some simple examples analyzed using a limited set of templates. As we can see, hierarchical structural analysis of sentences has indeed been preliminarily realized.</p>

<pre><code>+---&gt; (鸡蛋)可以(吃)吗
| +---&gt; 鸡蛋
| | +---&gt; 鸡蛋
| +---&gt; 可以
| +---&gt; 吃
| | +---&gt; 吃
| +---&gt; 吗

+---&gt; (牛肉鸡蛋)可以(吃)吗
| +---&gt; 牛肉鸡蛋
| | +---&gt; 牛肉
| | +---&gt; 鸡蛋
| +---&gt; 可以
| +---&gt; 吃
| | +---&gt; 吃
| +---&gt; 吗

+---&gt; (苹果)的(颜色)是(什么)呢
| +---&gt; 苹果
| | +---&gt; 苹果
| +---&gt; 的
| +---&gt; 颜色
| | +---&gt; 颜色
| +---&gt; 是
| +---&gt; 什么
| | +---&gt; 什么
| +---&gt; 呢

+---&gt; (雪梨和苹果和香蕉)的(颜色)是(什么)呢
| +---&gt; (雪梨和苹果)和(香蕉)
| | +---&gt; (雪梨)和(苹果)
| | | +---&gt; 雪梨
| | | | +---&gt; 雪梨
| | | +---&gt; 和
| | | +---&gt; 苹果
| | | | +---&gt; 苹果
| | +---&gt; 和
| | +---&gt; 香蕉
| | | +---&gt; 香蕉
| +---&gt; 的
| +---&gt; 颜色
| | +---&gt; 颜色
| +---&gt; 是
| +---&gt; 什么
| | +---&gt; 什么
| +---&gt; 呢
</code></pre>

    <p>Of course, we cannot only report good news; here are some failed examples:</p>

<pre><code>+---&gt; (我的美味)的(苹果的颜色)是(什么)呢
| +---&gt; (我)的(美味)
| | +---&gt; 我
| | | +---&gt; 我
| | +---&gt; 的
| | +---&gt; 美味
| | | +---&gt; 美味
| +---&gt; 的
| +---&gt; (苹果)的(颜色)
| | +---&gt; 苹果
| | | +---&gt; 苹果
| | +---&gt; 的
| | +---&gt; 颜色
| | | +---&gt; 颜色
| +---&gt; 是
| +---&gt; 什么
| | +---&gt; 什么
| +---&gt; 呢

+---&gt; (苹果)的(颜色)是(什么的意思是什么)呢
| +---&gt; 苹果
| | +---&gt; 苹果
| +---&gt; 的
| +---&gt; 颜色
| | +---&gt; 颜色
| +---&gt; 是
| +---&gt; (什么)的(意思)是(什么)
| | +---&gt; 什么
| | | +---&gt; 什么
| | +---&gt; 的
| | +---&gt; 意思
| | | +---&gt; 意思
| | +---&gt; 是
| | +---&gt; 什么
| | | +---&gt; 什么
| +---&gt; 呢
</code></pre>

    <p>We will analyze the failed examples later.</p>

    <h2 id="文章总结">Summary</h2>

    <p>For those feeling completely confused or having many things to complain about, please read this section first~</p>

    <h3 id="拼图游戏">Jigsaw Puzzle</h3>

    <p>From words to phrases to sentence templates, we have been playing a jigsaw puzzle: as we piece things together, we find that these two pieces fit well, so we merge them. Because merging items with high mutual information as a whole helps reduce the overall information entropy, which in turn reduces the overall learning difficulty.</p>

    <p>If sentence templates don't make sense in the context of Chinese, just look back at how we learned English in primary or middle school; back then, we probably learned many English sentence templates~</p>

    <h3 id="有什么用">What Is It For?</h3>

    <p>"Sentence template" is a new concept proposed in this article, and using it to recognize language structures is a new attempt. Readers might ask: what is this for?</p>

    <p>I think the best way to answer this is to quote Isaac Newton:</p>

    <blockquote>I do not know what I may appear to the world, but to myself I seem to have been only like a boy playing on the sea-shore, and diverting myself in now and then finding a smoother pebble or a prettier shell than ordinary, whilst the great ocean of truth lay all undiscovered before me.</blockquote>

    <p>I cited this to show that the fundamental reason for this exploration <strong>is not for some practical purpose, but to purely explore the mysteries of natural language.</strong></p>

    <p>Of course, if at the same time the research results possess some application value, that would be even more perfect. From current results, such value may exist. In NLP, we face ever-changing sentences, but in fact, "sentence styles" are finite, which means sentence templates are also finite. If necessary, we can manually annotate the meanings of the placeholders in each sentence template, which would allow us to map sentence template structures to conventional syntactic descriptions. Decomposing (infinite) sentences through finite templates can make NLP scenarios more flexible.</p>

    <p>Similar things might have appeared in traditional natural language processing, but the content described here is purely the result of unsupervised discovery, has a self-consistent theoretical description, and the preliminary results are acceptable. Therefore, it is worth further thinking about its application value.</p>

    <h3 id="艰难前进">Moving Forward with Difficulty</h3>

    <p>After reading this article, the reader's biggest feeling might be "completely confused": can it be simplified a bit more?</p>

    <p>To answer this, it must be mentioned that more than a month has passed since the last article in this series, and this article is finally being published; this seems like a long time. In terms of form, this article is just a simple extension of the previous one: doesn't it just extend adjacent associations to non-adjacent ones?</p>

    <p>Indeed, that is true in form. But to extend this idea to something with both theoretical and practical value is not simple or smooth. For example, in template generation, how to obtain all candidate templates without omission is a difficult problem; secondly, after obtaining sentence templates (whether automatically or manually), identifying the templates within a sentence is even more difficult. Both the theoretical thinking and the programming implementation involve many obstacles, requiring a clear grasp of tree structures and recursive programming. I also debugged for over half a month before finalizing the entire process, though it may not be complete.</p>

    <p>So, it is perfectly normal to feel confused. Even after completing the work and writing this article, I still feel quite confused~</p>

    <h3 id="改进思路">Ideas for Improvement</h3>

    <p>In the <a href="https://kexue.fm/archives/5577#%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90">Result Display</a> section, we also presented some failed examples. In fact, there might be even more.</p>

    <p>We should look at this from two perspectives. On the one hand, we have successful examples; exploring pure unsupervised mining is worthwhile even if we only get a small portion of successful results. On the other hand, for failed examples, we need to think about the reasons for failure and consider solutions.</p>

    <p>I believe the overall idea of sentence templates is correct, but the issue lies in the fact that we have not reached true semantic-level understanding. For example, in the first failed example, the result was</p>

    <blockquote>(the delicious of mine) of (the color of the apple) is (what) huh</blockquote>

    <p>Can we say this decomposition is completely wrong? No. Strictly speaking, this decomposition is not grammatically incorrect; it just doesn't align with semantics or our common sense. Therefore, the error lies not with the sentence templates themselves, but with the inability to fully integrate semantics to build templates.</p>

    <p>Looking at current mainstream syntactic analysis work, whether supervised or unsupervised, they basically combine "part-of-speech" to complete the analysis. This provides us with a direction: the next step in the minimum entropy series is to explore the problem of word clustering to better capture word meaning and language commonality.</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="translation_5577.html" style="color: #005fcc;">https://kexue.fm/archives/5577</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
