
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams'
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>

<nav style="margin-bottom: 1.5em;">
    <a href="../index.html" style="display: inline-flex; align-items: center; color: #555; text-decoration: none; font-size: 0.95em;">
        <span style="margin-right: 0.3em;">&larr;</span> Back to Index
    </a>
</nav>

<h1><a href="https://kexue.fm/archives/6549">The Evolution of GAN Architectures</a></h1>

    <p>By 苏剑林 | April 19, 2019</p>

    <p>In fact, the discovery of <a href="translation_6486.html">O-GAN</a> has reached my ideal pursuit for GANs, allowing me to comfortably leap out of the deep pit of GAN research. Therefore, I will now attempt to explore broader and more diverse research directions, such as tasks in NLP that haven't been done yet, Graph Neural Networks, or other interesting things. However, before that, I want to record my previous learning results regarding GANs. In this article, let's comb through the development of GAN architectures—primarily the development of generators, as discriminators haven't changed much over time. Also, this article introduces the architectural development of GANs in the field of images and has nothing to do with SeqGAN in NLP. Furthermore, this article will not repeat basic GAN introductions.</p>

    <h3>A Word Up Front</h3>
    <p>Of course, in a broad sense, any progress in classification models in the image domain can be considered progress for the discriminator (since they are both classifiers, related technologies can be applied to the discriminator). Since image classification models essentially haven't undergone qualitative changes since ResNet, this also suggests that the ResNet structure is basically the optimal choice for the discriminator.</p>
    <p>However, generators are different. Although relatively standard architectural designs have formed for GAN generators since DCGAN, they are far from being "finalized" or "optimal." Until recently, many works have been proposing new designs for generators. For example, SAGAN introduced Self-Attention into the generator (and discriminator), and the famous StyleGAN introduced a generator in the form of style transfer based on PGGAN. Therefore, many works indicate that there is still room for exploration in GAN generator architectures. A good generator architecture can accelerate GAN convergence or improve GAN performance.</p>

    <h3>DCGAN</h3>
    <p>When talking about the history of GAN architecture development, one must mention DCGAN; it qualifies as a landmark event in GAN history.</p>

    <h4>Background</h4>
    <p>As is well known, GANs originated in Ian Goodfellow's paper <a href="https://arxiv.org/abs/1406.2661">"Generative Adversarial Networks"</a>, but early GANs were limited to simple datasets like MNIST. This was because GANs had just emerged; although they attracted a wave of interest, they were still in the trial-and-error stage, with issues like model architecture, stability, and convergence still being explored. The emergence of DCGAN laid a solid foundation for solving these problems.</p>
    <p>DCGAN comes from the article <a href="https://arxiv.org/abs/1511.06434">"Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks"</a>. If we were to say what it did, it's actually simple: it proposed an architecture for generators and discriminators that significantly stabilized GAN training, to the point that it became the standard GAN architecture for a long time. It sounds simple, but in reality, achieving this was not easy, because there are many intuitively "reasonable" architectures. Selecting the near-optimal one from various combinations clearly required a significant amount of experimentation. Because DCGAN established the standard GAN architecture, researchers could focus more on diverse tasks thereafter, no longer agonizing over model architecture and stability, which led to the flourishing development of GANs.</p>

    <h4>Architecture Description</h4>
    <p>Having said all that, let's return to the discussion of the architecture itself. The model architecture proposed by DCGAN is roughly as follows:</p>
    <ol>
        <li>Neither the generator nor the discriminator uses pooling layers; instead, they use convolutional layers with strides. The discriminator uses regular convolution (Conv2D), while the generator uses transposed convolution (DeConv2D);</li>
        <li>Batch Normalization is used in both the generator and the discriminator;</li>
        <li>ReLU activation is used in all layers of the generator except the output layer, which uses the Tanh activation function;</li>
        <li>LeakyReLU activation is used in all layers of the discriminator;</li>
        <li>No fully connected layers are used after the convolutional layers;</li>
        <li>After the last convolutional layer of the discriminator, Global Pooling is not used; instead, it is directly flattened.</li>
    </ol>
    <p>Actually, looking back now, this is still a relatively simple structure, embodying the beauty of "simplicity is the ultimate sophistication," further proving that what is good must be concise.</p>
    <p>The DCGAN structure diagram is as follows:</p>
    <p style="text-align:center;">DCGAN Discriminator Architecture (Left) and Generator Architecture (Right)</p>

    <h4>Personal Summary</h4>
    <p>Several key points:</p>
    <ol>
        <li>The kernel size for convolution and transposed convolution is 4x4 or 5x5;</li>
        <li>The stride for convolution and transposed convolution is usually 2;</li>
        <li>For the discriminator, BN is generally not used after the first convolution layer, and then the pattern is "Conv2D + BN + LeakyReLU" until the feature map size is 4x4;</li>
        <li>For the generator, the first layer is fully connected, then reshaped to 4x4, followed by the "DeConv2D + BN + ReLU" pattern. BN is not used in the last layer, which uses Tanh activation; correspondingly, input images are scaled to -1 to 1 by dividing by 255, multiplying by 2, and subtracting 1.</li>
    </ol>
    <p>Although it might look large in terms of parameter count, DCGAN is actually fast and doesn't consume much VRAM, so it is very popular. Thus, despite being old, it is still used in many tasks today. At least for rapid experimentation, it is an excellent architecture.</p>

    <h3>ResNet</h3>
    <p>As GAN research deepened, people gradually discovered some shortcomings of the DCGAN architecture.</p>

    <h4>Problems with DCGAN</h4>
    <p>The common consensus is that because DCGAN's generator uses transposed convolution, and transposed convolution inherently has "Checkerboard Artifacts," these artifacts limit the upper bound of DCGAN’s generation capability. For more details on checkerboard artifacts, check <a href="https://distill.pub/2016/deconv-checkerboard/">"Deconvolution and Checkerboard Artifacts"</a> (Highly recommended, with many visual illustrations).</p>
    <p style="text-align:center;">Illustration of checkerboard artifacts, manifested as an interlaced effect like a chessboard when zoomed in. Image from "Deconvolution and Checkerboard Artifacts"</p>
    <p>To be precise, checkerboard artifacts are not a problem of "transposed convolution" per se, but an inherent issue with $stride > 1$, which causes the convolution to fail to cover the entire image "isotropically," resulting in an interlaced effect. Since transposed convolutions are usually paired with $stride > 1$, they are typically blamed. In fact, parallel to transposed convolution, dilated convolution also has checkerboard artifacts because it can be proven that under certain transformations, dilated convolution is equivalent to regular convolution with $stride > 1$.</p>

    <p>On the other hand, I suspect there is another reason: DCGAN's non-linear capability might be insufficient. Readers who have analyzed DCGAN results will notice that once the input image size is fixed, the entire DCGAN architecture is essentially fixed, including the number of layers. The only thing that seems changeable is the kernel size (channel numbers can be adjusted slightly, but the adjustment space isn't large). Changing the kernel size can change the model's non-linear capability to an extent, but it only changes the width of the model, and for deep learning, depth is often more important than width. The problem is that for DCGAN, there is no natural and direct way to increase depth.</p>

    <h4>The ResNet Model</h4>
    <p>Due to these reasons, and with the deepening of ResNet in classification problems, the application of ResNet structures in GANs was naturally considered. In fact, the mainstream generator and discriminator architectures for GANs have indeed become ResNet-based. The basic structure is illustrated below:</p>
    <p style="text-align:center;">ResNet-based Discriminator Architecture (Left) and Generator Architecture (Right), with a single ResBlock structure in the middle</p>
    <p>As we can see, ResNet-based GANs don't differ significantly from DCGAN in overall structure (further affirming DCGAN's foundational role). The main features are:</p>
    <ol>
        <li>Transposed convolution is removed in both the discriminator and generator, leaving only ordinary convolution layers;</li>
        <li>The convolutional kernel size is usually unified to 3x3, and convolutions form residual blocks;</li>
        <li>Upsampling and downsampling are achieved through AvgPooling2D and UpSampling2D, whereas DCGAN used convolution/transposed convolution with $stride > 1$; where UpSampling2D effectively scales up the image dimensions;</li>
        <li>Since there are already residuals, ReLU can be used as the unified activation function; of course, some models still use LeakyReLU, though the difference is minimal;</li>
        <li>By increasing the number of convolution layers in the ResBlocks, both the non-linear capability and depth of the network can be increased, which is the flexibility of ResNet;</li>
        <li>Generally, the residual form is $x + f(x)$, where $f$ represents the combination of convolution layers; however, in GANs, model initialization is typically smaller than in standard classification models, so for stability, some models change it to $x + \alpha \times f(x)$, where $\alpha$ is a small number like 0.1, to achieve better stability;</li>
        <li>Some authors believe BN is not suitable for GANs and sometimes remove it entirely or replace it with LayerNorm, etc.</li>
    </ol>

    <h4>Personal Summary</h4>
    <p>I haven't carefully researched which paper first applied ResNet to GANs, but prominent GANs like PGGAN, SNGAN, and SAGAN have all used ResNet. ResNet strides are all equal to 1, thus it is uniform enough to avoid checkerboard artifacts.</p>
    <p>However, ResNet is not without drawbacks. Although ResNet doesn't increase the number of parameters compared to DCGAN (in some cases even fewer), ResNet is much slower and requires significantly more VRAM. This is because ResNet has more layers and more connections between layers, leading to more complex gradients and weaker parallelism (parallelism is possible within a layer, but consecutive layers are serial and cannot be directy parallelized). The result is that it's slower and consumes more VRAM.</p>
    <p>Furthermore, checkerboard artifacts are actually very subtle effects; perhaps they only become noticeable during high-definition image generation. In my experiments generating 128x128 or even 256x256 faces or LSUN, I didn't visually perceive a significant difference in results between DCGAN and ResNet, but DCGAN's speed was more than 50% faster than ResNet. In terms of VRAM, DCGAN can directly run 512x512 generation (on a single 1080ti), while for ResNet, running 256x256 is already a bit strained. Therefore, unless I am trying to beat the current state-of-the-art FID scores, I wouldn't choose the ResNet architecture.</p>

    <h3>SELF-MOD</h3>
    <p>Normally, after introducing ResNet, I should introduce models like PGGAN and SAGAN, as they are landmark events in terms of resolution or IS/FID metrics. However, I don't plan to introduce them because, strictly speaking, PGGAN is not a new model architecture; it just provides a progressive training strategy that can be applied to DCGAN or ResNet architectures. And SAGAN's changes are not major; standard SAGAN just inserts a Self-Attention layer into common DCGAN or ResNet architectures, which doesn't count as a major change in generator architecture.</p>
    <p>Next, I will introduce a relatively new improvement: the Self-Modulated Generator, from the paper <a href="https://arxiv.org/abs/1809.11096">"On Self Modulation for Generative Adversarial Networks"</a>, which I will simply refer to as "SELF-MOD" here.</p>

    <h4>Conditional BN</h4>
    <p>Before introducing SELF-MOD, I need to introduce something else: Conditional Batch Normalization (Conditional BN).</p>
    <p>As is well known, BN is a common operation in deep learning, especially in the image field. To be honest, I don't like BN very much, but I must admit it plays an important role in many GAN models. Standard BN is unconditional: for an input tensor $\boldsymbol{x}_{i,j,k,l}$, where $i,j,k,l$ represent the batch, height, width, and channel dimensions of the image, the training phase is as follows:</p>

    \begin{equation}\boldsymbol{x}_{i,j,k,l}^{(out)}=\boldsymbol{\gamma}_l \times \frac{\boldsymbol{x}_{i,j,k,l}^{(in)} - \boldsymbol{\mu}_l}{\boldsymbol{\sigma}_l+\epsilon} + \boldsymbol{\beta}_l\end{equation}

    <p>where</p>

    \begin{equation}\boldsymbol{\mu}_l = \frac{1}{N}\sum_{i,j,k} \boldsymbol{x}_{i,j,k,l}^{(in)},\quad \boldsymbol{\sigma}^2_l = \frac{1}{N}\sum_{i,j,k} \left(\boldsymbol{x}_{i,j,k,l}^{(in)}-\boldsymbol{\mu}_l\right)^2\end{equation}

    <p>are the mean and variance of the input batch data, where $N = \text{batch_size} \times \text{height} \times \text{width}$, while $\boldsymbol{\beta}$ and $\boldsymbol{\gamma}$ are trainable parameters, and $\epsilon$ is a small positive constant to prevent division by zero. In addition, a set of moving average variables $\hat{\boldsymbol{\mu}}, \hat{\boldsymbol{\sigma}}^2$ is maintained to use during the testing phase.</p>
    <p>The reason this BN is called unconditional is that parameters $\boldsymbol{\beta}, \boldsymbol{\gamma}$ are obtained purely through gradient descent and do not depend on the input. Correspondingly, if $\boldsymbol{\beta}, \boldsymbol{\gamma}$ depend on some input $\boldsymbol{y}$, it is called Conditional BN:</p>

    \begin{equation}\boldsymbol{x}_{i,j,k,l}^{(out)}=\boldsymbol{\gamma}_l(\boldsymbol{y}) \times \frac{\boldsymbol{x}_{i,j,k,l}^{(in)} - \boldsymbol{\mu}_l}{\boldsymbol{\sigma}_l+\epsilon} + \boldsymbol{\beta}_l(\boldsymbol{y})\end{equation}

    <p>Here $\boldsymbol{\beta}_l(\boldsymbol{y}), \boldsymbol{\gamma}(\boldsymbol{y})$ are outputs of some model.</p>
    <p>Let's first talk about how to implement it. It is actually very easy to implement Conditional BN in Keras. Reference code is as follows:</p>

<pre><code>
def ConditionalBatchNormalization(x, beta, gamma):
    """
    To implement Conditional BN, we just need to remove the native 
    beta and gamma from Keras's BatchNormalization and pass in 
    external beta and gamma instead. For training stability, 
    it's best to initialize beta with zeros and gamma with ones.
    """
    x = BatchNormalization(center=False, scale=False)(x)
    def cbn(x):
        x, beta, gamma = x
        for i in range(K.ndim(x)-2):
            # Adjust the ndim of beta; modify this based on the specific case
            beta = K.expand_dims(beta, 1)
            gamma = K.expand_dims(gamma, 1)
        return x * gamma + beta
    return Lambda(cbn)([x, beta, gamma])
</code></pre>

    <h4>SELF-MOD GAN</h4>
    <p>Conditional BN first appeared in the article <a href="https://arxiv.org/abs/1707.03141">"Modulating early visual processing by language"</a>, and was later used in <a href="https://arxiv.org/abs/1802.05637">"cGANs With Projection Discriminator"</a>. Currently, it has become the standard solution for Conditional GANs (cGAN), including SAGAN and BigGAN. To put it simply, cGAN uses the label $\boldsymbol{c}$ as a condition for $\boldsymbol{\beta}, \boldsymbol{\gamma}$ to form conditional BN, replacing the unconditional BN in the generator. In other words, the primary input to the generator is still the random noise $\boldsymbol{z}$, while the condition $\boldsymbol{c}$ is passed into every BN layer of the generator.</p>

    <p>Why talk so much about conditional BN? What does it have to do with SELF-MOD?</p>
    <p>The situation is this: SELF-MOD considers that the stability of cGAN training is better, but usually, GANs don't have labels $\boldsymbol{c}$ available. What to do? Just use the noise $\boldsymbol{z}$ itself as the label! This is the meaning of Self-Modulated—modulating oneself without relying on external labels, but achieving similar effects. Described with a formula:</p>

    \begin{equation}\boldsymbol{x}_{i,j,k,l}^{(out)}=\boldsymbol{\gamma}_l(\boldsymbol{z}) \times \frac{\boldsymbol{x}_{i,j,k,l}^{(in)} - \boldsymbol{\mu}_l}{\boldsymbol{\sigma}_l+\epsilon} + \boldsymbol{\beta}_l(\boldsymbol{z})\end{equation}

    <p>In the original paper, $\boldsymbol{\beta}(\boldsymbol{z})$ is a two-layer fully connected network:</p>

    \begin{equation}\boldsymbol{\beta}(\boldsymbol{z})=\boldsymbol{W}^{(2)}\max\left(0, \boldsymbol{W}^{(1)}\boldsymbol{z}+\boldsymbol{b}^{(2)}\right)\end{equation}

    <p>$\boldsymbol{\gamma}(\boldsymbol{z})$ is the same. Looking at the official source code, I found that the dimension of the middle layer can be set smaller, such as 32, so it won't significantly increase the parameter count. This is the generator for an unconditional GAN with a SELF-MOD structure.</p>

    <h4>Personal Summary</h4>
    <p style="text-align:center;">DCGAN generator in SELF-MOD form. ResNet-based versions are similar, just replacing BN with the SELF-MOD version.</p>
    <p>I combined the SELF-MOD structure with my O-GAN experiments and found that the convergence speed increased by nearly 50%, and the final FID and reconstruction results were better. The excellence of SELF-MOD is clear. I even have a faint feeling that O-GAN and SELF-MOD are a great match (haha, maybe just a narcissistic illusion).</p>
    <p>Keras reference code is here:</p>
    <p><a href="https://github.com/bojone/o-gan/blob/master/o_gan_celeba_sm_4x4.py">https://github.com/bojone/o-gan/blob/master/o_gan_celeba_sm_4x4.py</a></p>
    <p>Additionally, even in cGAN, the SELF-MOD structure can be used. Standard cGAN uses the condition $\boldsymbol{c}$ as the BN input condition; SELF-MOD uses both $\boldsymbol{z}$ and $\boldsymbol{c}$ as BN input conditions. Reference usage:</p>

    \begin{equation}\begin{aligned}\boldsymbol{\beta}(\boldsymbol{z},\boldsymbol{c}) =& \boldsymbol{W}^{(2)}\max\left(0, \boldsymbol{W}^{(1)}\boldsymbol{z}'+\boldsymbol{b}^{(2)}\right)\\ \boldsymbol{z}' =& \boldsymbol{z}+\text{E}(\boldsymbol{c})+\text{E}'(\boldsymbol{c})\otimes \boldsymbol{z}\end{aligned}\end{equation}

    <p>where $\text{E}, \text{E}'$ are two Embedding layers. In cases where the number of categories is small, they can be directly understood as fully connected layers. $\boldsymbol{\gamma}$ is analogous.</p>

    <h3>Other Architectures</h3>
    <p>Readers might find it strange: why hasn't the famous <a href="https://arxiv.org/abs/1809.11096">BigGAN</a> and <a href="https://arxiv.org/abs/1812.04948">StyleGAN</a> been mentioned?</p>
    <p>In fact, BigGAN didn't make particularly unique improvements to the model architecture, and even the authors themselves admit it's just about "brute force achieving miracles." As for StyleGAN, it indeed improved the model architecture. However, once you understand the previously mentioned SELF-MOD, StyleGAN is not hard to understand; one can even view StyleGAN as a variant of SELF-MOD.</p>

    <h4>AdaIN</h4>
    <p>The core of StyleGAN is something called AdaIN (Adaptive Instance Normalization), which originates from the style transfer paper <a href="https://arxiv.org/abs/1703.06868">"Arbitrary Style Transfer in Real-time with Adaptive Instance Normalization"</a>. It is actually very similar to Conditional BN, perhaps even simpler:</p>

    \begin{equation}\boldsymbol{x}_{i,j,k,l}^{(out)}=\boldsymbol{\gamma}_l(\boldsymbol{y}) \times \frac{\boldsymbol{x}_{i,j,k,l}^{(in)} - \boldsymbol{\mu}_{i,l}}{\boldsymbol{\sigma}_{i,l}+\epsilon} + \boldsymbol{\beta}_l(\boldsymbol{y})\end{equation}

    <p>The difference from Conditional BN is: Conditional BN uses $\boldsymbol{\mu}_{l}$ and $\boldsymbol{\sigma}_{l}$, whereas AdaIN uses $\boldsymbol{\mu}_{i,l}$ and $\boldsymbol{\sigma}_{i,l}$. In other words, AdaIN calculates statistical features within a single sample rather than across a batch. Therefore, AdaIN does not need to maintain moving averages of mean and variance, making it simpler than conditional BN.</p>

    <h4>StyleGAN</h4>
    <p style="text-align:center;">DCGAN generator in StyleGAN form. ResNet-based versions are similar; the main change is replacing Conditional BN with AdaIN.</p>
    <p>With SELF-MOD and AdaIN, we can clarify StyleGAN. The main change in StyleGAN is also the generator. Compared to SELF-MOD, its differences are:</p>
    <ol>
        <li>Cancel the noise input at the top and replace it with a trainable constant vector;</li>
        <li>Replace all conditional BN with AdaIN;</li>
        <li>The input condition for AdaIN is created by transforming noise $z$ using a multi-layer MLP, which is then projected into $\boldsymbol{\beta}$ and $\boldsymbol{\gamma}$ for different AdaIN layers using different transformation matrices.</li>
    </ol>
    <p>It's that simple~</p>

    <h4>Personal Summary</h4>
    <p>I personally experimented with a simplified StyleGAN-style DCGAN and found that it could converge and the results were decent, but with slight Mode Collapse. Since official StyleGAN uses PGGAN training mode and I did not, I wonder if StyleGAN needs to be paired with PGGAN to be trained well? I don't have an answer yet. However, in my experiments, SELF-MOD was much easier to train and gave better results than StyleGAN.</p>

    <h3>Article Summary</h3>
    <p>This article briefly combed through the changes in GAN model architectures, mainly from DCGAN and ResNet to SELF-MOD, etc. These are all quite distinct changes; some subtle improvements might have been ignored.</p>
    <p>For a long time, there have been few works that drastically changed GAN model architectures, and SELF-MOD and StyleGAN have once again sparked interest in architectural changes. The paper <a href="https://arxiv.org/abs/1711.10925">"Deep Image Prior"</a> also showed that the prior knowledge contained within the model architecture itself is a significant reason image generation models can succeed. Proposing better model architectures means proposing better prior knowledge, which naturally benefits image generation.</p>
    <p>The architectures mentioned in this article are based on my own experiments, and the evaluations made are based on my personal experience and aesthetic views. If there are any inaccuracies, please feel free to correct them~</p>

    <hr>
    <p>Original source: <a href="https://kexue.fm/archives/6549">https://kexue.fm/archives/6549</a></p>

    <p>To cite this article, please refer to:</p>
    </article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/6549" style="color: #005fcc;">https://kexue.fm/archives/6549</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
