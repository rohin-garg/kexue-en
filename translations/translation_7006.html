
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    tags: 'ams',
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
    <nav style="margin-bottom: 1.5em;">
    <a href="../index.html" style="display: inline-flex; align-items: center; color: #555; text-decoration: none; font-size: 0.95em;">
        <span style="margin-right: 0.3em;">&larr;</span> Back to Index
    </a>
</nav>

    <h1><a href="https://kexue.fm/archives/7006">The Minimum Entropy Principle (V): "Step by Step" Community Detection and Clustering</a></h1>
    <p>By 苏剑林 | October 19, 2019</p>

    <p>Let us tirelessly review: the <a href="https://kexue.fm/tag/%E6%9C%80%E5%B0%8F%E7%86%B5/">Minimum Entropy Principle</a> is an unsupervised learning principle. "Entropy" represents the learning cost, and reducing this cost is our constant pursuit. By "minimizing the learning cost," we can unsupervisedly learn results that align with our intuition. This is the basic philosophy of the Minimum Entropy Principle.</p>

    <p>In this article, we will introduce a quite beautiful clustering algorithm that also embodies the Minimum Entropy Principle, or can be derived from it. It is called <a href="https://www.mapequation.org/">InfoMap</a>, or <a href="https://www.mapequation.org/">MapEquation</a>. In fact, InfoMap is a result from 2007, with the earliest paper being <a href="https://papers.cool/arxiv/0707.0609">"Maps of random walks on complex networks reveal community structure"</a>. Although it may seem old, I believe it remains the most beautiful clustering algorithm because it doesn't just tell us "how to cluster," but more importantly, it provides an elegant information-theoretic explanation of "why we cluster," and directly derives the entire clustering process from this explanation.</p>

    <figure>
        <img src="https://kexue.fm/usr/uploads/2019/10/961858593.png" alt="Complex directed network schematic" style="max-width:100%;">
        <figcaption>A schematic diagram of a complex directed graph network. Image from the original InfoMap paper "Maps of random walks on complex networks reveal community structure".</figcaption>
    </figure>

    <p>Of course, its positioning is not limited to clustering; more accurately, it is a "Community Detection" algorithm on graph networks. Community Detection roughly means given a directed/undirected graph network, find the "clumping" or "grouping" behavior within it. For detailed meaning, you can search for it yourself. Simply put, it is similar to clustering but has a richer meaning (can also refer to <a href="https://blog.csdn.net/itplus/article/details/41348651">"What is Community Detection?"</a>).</p>

    <h2>Entropy and Coding</h2>
    <p>In previous articles, we used the concept of information entropy. Starting from this article, we introduce the equivalent concept of information entropy—average code length. Introducing it helps us more precisely understand and construct the goal of minimum entropy.</p>

    <h3>Binary Tree Coding</h3>
    <figure>
        <img src="https://kexue.fm/usr/uploads/2019/10/2567931304.png" alt="Binary Tree Coding" style="max-width:100%;">
        <figcaption>Each code is not a prefix of another code, so these codes can form a binary tree.</figcaption>
    </figure>

    <p>Coding means using a combination of a finite number of markers to represent original info. The most typical is binary coding, which uses only digits 0 and 1. Codes and original objects usually have a one-to-one correspondence. For example, "Science" might correspond to (11, 1001).</p>
    <p>Note that we consider static coding here, meaning each object corresponds to one code. We also consider prefix-free codes (delimiter-free), meaning no additional separator is needed to decode individual objects. This simply requires that no code is a prefix of any other code (so that we can read code continuously until an object is identified, then start a new read). This implies that all codes can be constructed into a binary tree where each code corresponds to a leaf, as shown in the figure.</p>
    <p>On this basis, we can get an interesting conclusion: assuming $n$ different characters with code lengths $l_1, l_2, \dots, l_n$, we have:</p>
    \begin{equation} \sum_{i=1}^n 2^{-l_i}\leq 1 \label{eq:leq} \end{equation}
    <p>This is a direct corollary of this binary tree representation; readers can try to prove it themselves.</p>

    <h3>Shortest Coding Length</h3>
    <p>Imagine a "shorthand" scenario where we need to quickly record text. Encoding involves mapping each character to a binary code. To record faster, we obviously want frequently occurring characters to have shorter codes (e.g., the word "the" in English). If you used a long string like 11000010001 for "the", recording would be slow. Using something like 10 would be much faster.</p>
    <p>Suppose there are $n$ different characters with occurrence probabilities $P=(p_1, p_2, \dots, p_n)$. Two questions arise: <strong>First, how to find the optimal coding scheme for the shortest average length? Second, what is the theoretical minimum average length?</strong></p>
    <p>For the first question, the answer is Huffman coding (the same as in Huffman Softmax from Word2Vec), though that's not our focus. The answer to the second question is a fundamental result in information theory: <strong>Information Entropy</strong>.</p>
    \begin{equation} H(P)=-\sum_{i=1}^n p_i \log_2 p_i \label{eq:l} \end{equation}
    <p>That is, information entropy is the theoretical shortest average code length. This is a "powerful" result; it tells us that no matter what coding you use, the average code length cannot be lower than \eqref{eq:l}.</p>

    <blockquote>
        <p>In the delimiter-free coding scenario mentioned above, we give a simple proof of \eqref{eq:l}. Let the lengths be $l_1, l_2, \dots, l_n$. The average length is:</p>
        \begin{equation} \sum_{i=1}^n p_i l_i = -\sum_{i=1}^n p_i \log_2 2^{-l_i} \label{eq:avg-l} \end{equation}
        <p>Because we have inequality \eqref{eq:leq}, define:</p>
        \begin{equation} \hat{p} = 1 - \sum_{i=1}^n 2^{-l_i}\geq 0 \end{equation}
        <p>Then Equation \eqref{eq:avg-l} can be written as:</p>
        \begin{equation} - 0\times \log \hat{p}-\sum_{i=1}^n p_i \log_2 2^{-l_i} \end{equation}
        <p>This is the cross-entropy of distributions $P=(0, p_1, p_2, \dots, p_n)$ and $Q=(\hat{p}, 2^{-l_1}, 2^{-l_2}, \dots, 2^{-l_n})$. Since cross-entropy is minimized when $P=Q$ (proven via $KL(P\|Q) \geq 0$), we have:</p>
        \begin{equation} \sum_{i=1}^n p_i l_i \geq -\sum_{i=1}^n p_i \log_2 p_i \end{equation}
    </blockquote>

    <p>Even a brief contact with information theory reveals this conclusion. Minimum entropy involves finding better schemes to approach this limit, which is also the limit for lossless compression.</p>

    <h2>InfoMap</h2>
    <p>Back to InfoMap, it is directly related to compression coding. Until recently (October 15, 2019), I finally understood its origins. The difficulty was partly due to unfamiliarity with information theory and partly because the original papers perhaps didn't clarify the bottlenecks for non-specialist readers.</p>
    <p><strong>InfoMap Publication List: <a href="https://www.mapequation.org/publications.html">https://www.mapequation.org/publications.html</a></strong></p>

    <h3>Categorized Memory</h3>
    <p>If we are asked to memorize a sequence in a short time:</p>
    <p><em>Pear, Grape, Banana, Guangzhou, Shanghai, Beijing, Hangzhou, Shenzhen, 123, 654, 798, 963</em></p>
    <p>The sequence isn't long, but to form memories quickly, you would likely group them:</p>
    <blockquote>
        <p>1. The first 3 are Fruits; the middle 5 are Cities; the last 4 are Arabic Numbers;<br>
        2. The Fruits are Pear, Grape, Banana;<br>
        3. The Cities are Guangzhou, Shanghai, Beijing, Hangzhou, Shenzhen;<br>
        4. The Numbers are 123, 654, 798, 963.</p>
    </blockquote>
    <p>Memory efficiency is better using categorized grouping. The mathematical description of "improving efficiency" or "saving effort" is the reduction of entropy. Thus, a good classification scheme satisfies the minimum entropy principle. This is the core optimization goal of InfoMap: seeking the optimal clustering scheme by minimizing entropy.</p>

    <h3>Hierarchical Coding: Concept</h3>
    <p>As established, information entropy equals the shortest code length. Since categorized memory is efficient, it must correspond to some compression coding: Hierarchical Coding.</p>
    <p>In hierarchical coding, we no longer use a single code for an object but a combination of two: the first code represents the object's category, and the second represents its index within the category. If objects of the same category often appear "clumped," hierarchical coding can compress the data.</p>
    <p>How does hierarchical coding compress? Most InfoMap resources do not highlight the actual coding method. I believe the process is as follows:</p>
    <figure>
        <img src="https://kexue.fm/usr/uploads/2019/10/3745672224.png" alt="Hierarchical Coding method" style="max-width:100%;">
        <figcaption>Hierarchical coding method: Insert a category marker before words of the same category and an exit marker at the end of the category block.</figcaption>
    </figure>
    <p>To remain lossless, we insert category tags and exit tags. Category tags use one set of codes; in-category objects and exit tags use another set. Since categories provide separation, objects across different categories can share the same code (e.g., Pear and Shanghai could both be 001). This reduces average code length. When decoding, you read the category code, switch to that category's set, read until an exit marker appears, and repeat.</p>

    <h3>Hierarchical Coding: Calculation</h3>
    <p>Now we need a quantitative calculation. Assume we have a hierarchical coding scheme; we calculate the average length using these definitions:</p>
    <table border="1">
        <tr><th>Notation</th><th>Meaning</th></tr>
        <tr><td>$p_{\alpha}$</td><td>Probability of object $\alpha$ appearing</td></tr>
        <tr><td>$q_{i\curvearrowright}$</td><td>Probability of category $i$ appearing</td></tr>
    </table>
    <p>According to our convention, every category sequence entry ends with an exit tag. Thus $q_{i\curvearrowright}$ is also the occurrence probability of category $i$'s exit tag. Note that these are globally normalized probabilities:</p>
    \begin{equation} \underbrace{\sum_i q_{i\curvearrowright}}_{\text{Sum of cat. probabilities}} + \underbrace{\sum_{\alpha}p_{\alpha}}_{\text{Sum of object probabilities}} + \underbrace{\sum_i q_{i\curvearrowright}}_{\text{Sum of exit tag probabilities}} = 1 \label{eq:guiyi} \end{equation}
    <p>Because categories and within-category objects use different coding sets, we calculate them separately. The shortest average code length for categories is:</p>
    \begin{equation} H(\mathcal{Q})=-\sum_i \frac{q_{i\curvearrowright}}{q_{\curvearrowright}} \log \frac{q_{i\curvearrowright}}{q_{\curvearrowright}} \end{equation}
    <p>where $q_{\curvearrowright} = \sum_i q_{i\curvearrowright}$. This results from normalizing category probabilities and applying the entropy formula.</p>
    <p>Similarly, for category $i$, the within-category shortest average length (including exit tags) is:</p>
    \begin{equation} H(\mathcal{P}^i)=- \frac{q_{i\curvearrowright}}{p_{i\circlearrowright}} \log \frac{q_{i\curvearrowright}}{p_{i\circlearrowright}} -\sum_{\alpha\in i} \frac{p_{\alpha}}{p_{i\circlearrowright}} \log \frac{p_{\alpha}}{p_{i\circlearrowright}} \end{equation}
    <p>where $p_{i\circlearrowright} = q_{i\curvearrowright} + \sum_{\alpha\in i} p_{\alpha}$. (Note the difference between $p, q, \curvearrowright$ and $\circlearrowright$).</p>
    <p>The total weighted average code length is:</p>
    \begin{equation} L(M) = \color{red}{q_{\curvearrowright}H(\mathcal{Q})} + \color{skyblue}{\sum_i p_{i\circlearrowright} H(\mathcal{P}^i)} \label{eq:loss} \end{equation}
    <p>With this index \eqref{eq:loss}, we can optimize. Given an object sequence, we seek a clustering scheme that minimizes $L(M)$. This algorithm has almost no hyperparameters—no need to pre-specify the number of clusters.</p>

    <h3>Random Walk</h3>
    <p>We have an objective \eqref{eq:loss}, but classic clustering doesn't provide a sequence. It usually gives similarities between samples. InfoMap abstracts the samples as a directed graph where edges $(\alpha, \beta)$ represent transition probabilities $p_{\beta\to\alpha}$ (normalized similarities).</p>
    <p>The classic idea of a "Random Walk" emerges: start at point $j$, jump to $i$ with probability $p(i|j)$, and repeat to generate a long sequence. With this sequence, we can apply \eqref{eq:loss}.</p>
    <figure>
        <img src="https://kexue.fm/usr/uploads/2019/10/731773099.png" alt="InfoMap coding and clustering process" style="max-width:100%;">
        <figcaption>InfoMap coding and clustering process. (a) Random walk; (b) Building Huffman codes from probabilities; (c) Hierarchical coding; (d) Category coding inside hierarchical coding. Below, sequences show hierarchical coding is shorter.</figcaption>
    </figure>
    <p>The InfoMap process: <strong>Construct transition probabilities, perform random walks on the graph to generate a sequence, apply hierarchical coding to the sequence, and minimize \eqref{eq:loss} to complete clustering.</strong></p>

    <h3>InfoMap Mathematical Details</h3>
    <p>We don't actually need to simulate the walk. We only need the steady-state probabilities $p_{\alpha}$ by solving:</p>
    \begin{equation} \begin{pmatrix}p_1\\p_2\\ \vdots \\p_n\end{pmatrix} = \begin{pmatrix}p_{1\to 1} & p_{2\to 1} & \cdots & p_{n\to 1}\\p_{1\to 2} & p_{2\to 2} & \cdots & p_{n\to 2} \\ \vdots& \vdots& \ddots & \vdots \\p_{1\to n} & p_{2\to n} & \cdots & p_{n\to n}\end{pmatrix} \begin{pmatrix}p_1\\p_2\\ \vdots \\p_n\end{pmatrix} \label{eq:pab} \end{equation}
    <p>or $p_{\beta}=\sum_{\alpha} p_{\alpha}p_{\alpha\to\beta}$. To ensure a unique solution and avoid getting stuck in isolated areas, we introduce "teleportation probability" $\tau$ (with probability $1-\tau$ follow the graph, with probability $\tau$ jump to any node). The equation becomes:</p>
    \begin{equation} p_{\beta}=(1-\tau)\sum_{\alpha} p_{\alpha}p_{\alpha\to\beta} + \tau \sum_{\alpha} \frac{p_{\alpha}}{n} \label{eq:pa} \end{equation}
    <p>Authors set $\tau=0.15$ by default. Now for $q_{i\curvearrowright}$, the exit probability from category $i$, it is the probability of moving from category $i$ to any node outside $i$:</p>
    \begin{equation} q_{i\curvearrowright} = \sum_{\alpha\in i}\sum_{\beta\not\in i} p_{\alpha} p_{\alpha\to\beta} \end{equation}
    <p>With teleportation:</p>
    \begin{equation} \begin{aligned} q_{i\curvearrowright} =& \sum_{\alpha\in i}\sum_{\beta\not\in i} p_{\alpha} \left[(1-\tau)p_{\alpha\to\beta} + \frac{\tau}{n}\right]\\ =& \tau\frac{n - n_i}{n}\sum_{\alpha\in i}p_{\alpha} + (1-\tau)\sum_{\alpha\in i}\sum_{\beta\not\in i} p_{\alpha}p_{\alpha\to\beta} \end{aligned} \label{eq:q-exit} \end{equation}
    <p>where $n_i$ is the number of nodes in category $i$.</p>
    <p>The InfoMap workflow:</p>
    <ol>
        <li>Define transition probabilities $p_{\alpha\to\beta}$;</li>
        <li>Numerically solve \eqref{eq:pa} for $p_{\alpha}$;</li>
        <li>Search for a clustering scheme to minimize \eqref{eq:loss}.</li>
    </ol>

    <h3>Extension Ideas</h3>
    <p>InfoMap is easily extended: multilevel hierarchical coding (clusters of clusters) by iterating the loss function, and overlapping community detection (one node in multiple clusters). Allowing a node to belong to multiple categories adds redundancy to the node's code but may reduce exit/category marker codes, lowering the total average length. Refer to <a href="https://papers.cool/arxiv/1010.0431">"Multilevel compression..."</a> and <a href="https://papers.cool/arxiv/1105.0812">"Compression of Flow Can Reveal Overlapping-Module..."</a>.</p>

    <h2>Experiments</h2>
    <h3>Solving Algorithm</h3>
    <p>The original search was greedy search plus simulated annealing. Each node starts in its own cluster, then pairs are merged to maximize the drop in \eqref{eq:loss}. An improved greedy algorithm followed, making it fast enough for networks with millions of nodes and edges.</p>

    <h3>Installation</h3>
    <p>Implemented in C++ with Python and R wrappers. Official site: <a href="https://www.mapequation.org/code.html">https://www.mapequation.org/code.html</a>.</p>

    <h3>Word Clustering</h3>
    <p>Example using Word2Vec similarities: <a href="https://github.com/bojone/infomap/blob/master/word_cluster.py">word_cluster.py</a>. Results show coherent groups like family members (Sister, Father, Aunt), corporate finance (Stock, Securities, Loan, CEO), and school/education terms.</p>

    <h2>Summary</h2>
    <p>InfoMap is a clustering/community detection algorithm based on transition probabilities with a beautiful information-theoretic (Minimum Entropy) explanation. It has few hyperparameters and is widely applicable for finding structural modules in any domain containing nodes and graph connections. Its elegance makes it worth exploring.</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/7006" style="color: #005fcc;">https://kexue.fm/archives/7006</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
