
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    tags: 'ams',
    packages: {'[+]': ['ams']}
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
  <h1><a href="https://kexue.fm/archives/4695">CRF In A Nutshell</a></h1>
  <p>By 苏剑林 | November 25, 2017</p>

  <p>This article aims to explain the principles of CRF (Conditional Random Field) using language that is as concise as possible. The term "In A Nutshell" carries meanings such as "introduction" or "popular science" (Hawking wrote a book called <i>The Universe in a Nutshell</i>, and I am clumsily following suit here).</p>

  <p>Most articles introducing CRF on the web, whether in Chinese or English, usually start by discussing concepts of probability graphs and then introduce the exponential formula for features, claiming it as CRF. "Probability graphs" are merely an illustrative way of understanding; however, if the principles are not clear, providing too many figurative analogies will only confuse the reader, making it seem like you are just being pretentious. (Speaking of which, I want to vent again: solving a neural network is clearly about calculating a gradient and then iterating—this is so easy to understand—yet people gave it a pretentious name like "backpropagation." If you don't clearly state that its essence is differentiation and iterative solving, how many readers will truly understand when you just say backpropagation?)</p>

  <p>Alright, enough with the filler. Let's get to the main point.</p>

  <h2 id="Per-tag-Softmax">Per-tag Softmax</h2>

  <p>CRF is commonly found in sequence labeling tasks. Suppose our model input is $Q$ and the output target is a sequence $a_1, a_2, \dots, a_n$; then, according to our usual modeling logic, we naturally hope to maximize the probability of the target sequence:
  $$P(a_1, a_2, \dots, a_n | Q)$$
  Whether using traditional methods or deep learning methods, modeling the complete sequence directly is difficult. Therefore, we usually use some assumptions to simplify it. For example, using the naive assumption gives us:
  $$P(a_1, a_2, \dots, a_n | Q) = P(a_1 | Q) P(a_2 | Q) \dots P(a_n | Q)$$
  Note that $Q$ here is not necessarily the original input; for instance, it might be the hidden outputs $q_1, q_2, \dots, q_n$ after multiple layers of LSTM. We assume that global correlations have already been captured by the preceding model, so in the final step, we can assume the features are independent of each other, thus:
  \[\begin{aligned}
  P(a_1 | Q) &= P(a_1 | q_1, q_2, \dots, q_n) = P(a_1 | q_1) \\
  P(a_2 | Q) &= P(a_2 | q_1, q_2, \dots, q_n) = P(a_2 | q_2) \\
  &\vdots \\
  P(a_n | Q) &= P(a_n | q_1, q_2, \dots, q_n) = P(a_n | q_n)
  \end{aligned}\]
  Consequently:
  $$P(a_1, a_2, \dots, a_n | Q) = P(a_1 | q_1) P(a_2 | q_2) \dots P(a_n | q_n)$$
  This yields the most common solution: directly outputting the tag with the maximum probability for each label. The preceding model is usually a multi-layer bidirectional LSTM.</p>

  <h2 id="Conditional-Random-Field">Conditional Random Field</h2>

  <p>Per-tag softmax is a simple and effective method, but it sometimes produces unreasonable results. For example, when using SBME for 4-tag word segmentation, per-tag softmax cannot exclude the possibility of a sequence like <code>bbbb</code>, but this sequence violates our decoding rules (a <code>b</code> can only be followed by <code>m</code> or <code>e</code>). Some say per-tag softmax does not need dynamic programming, but that is incorrect; in this case, we need at least a "0 or 1" transition matrix to directly set unreasonable transition probabilities to 0 (such as $P(b|b)=0$), and then use dynamic programming to ensure a reasonable sequence is obtained.</p>

  <p>The problem with the above scheme fundamentally lies in the fact that when modeling, we used the naive assumption of complete output independence (unigram model), but our actual output sequences are context-dependent, resulting in a mismatch between the optimization objective and the model assumptions. Can we directly incorporate the context? Simple: just use a bigram model.
  \[\begin{aligned}
  P_Q(a_1, a_2, \dots, a_n) &= P_Q(a_1) P_Q(a_2 | a_1) P_Q(a_3 | a_1, a_2) \dots P_Q(a_n | a_1, \dots, a_{n-1}) \\
  &= P_Q(a_1) P_Q(a_2 | a_1) P_Q(a_3 | a_2) \dots P_Q(a_n | a_{n-1})
  \end{aligned}\]
  To make the expression look better, I moved the input $Q$ into the subscript. This is <b>already very close to CRF</b>!</p>

  <p>Continuing to observe the equation above, it is a product of transition probabilities. However, why must we define each term as a transition probability? Thus, the CRF approach is very general. First, it defines a function $f(x, y; Q)$ (it could be a sum of some simple feature functions, but the specific form is not actually important), and then directly sets:
  $$P_Q(a_1, a_2, \dots, a_n) = \frac{1}{Z} \exp \left( \sum_k f(a_{k-1}, a_k; Q) \right)$$
  where $Z$ is the normalization factor. Compared to the previous equation, the difference is that $P_Q(a_k | a_{k-1})$ has probabilistic meaning (conditional probability), while the individual term $e^{f(a_{k-1}, a_k; Q)}/Z$ does not have probabilistic meaning. Therefore, CRF is a more general form.</p>

  <p>That is all there is to CRF.</p>

  <p>A more complete reference link: <a href="https://zhuanlan.zhihu.com/p/28465510">https://zhuanlan.zhihu.com/p/28465510</a></p>

  <h2 id="Linear-Chain-CRF">Linear Chain CRF</h2>

  <p>Wait? Are you kidding me? This is CRF? What on earth are these $P_Q(a_k | a_{k-1})$ terms? And what about $f(x, y; Q)$?</p>

  <p>Dear reader, you've stumped me. I don't know what they are either. If you don't believe me, look at some tutorials online; the formulas they give are roughly like this (copied directly from <a href="http://blog.echen.me/2012/01/03/introduction-to-conditional-random-fields/">here</a>):
  \[\begin{aligned}
  p(l | s) &= \frac{\exp[score(l | s)]}{\sum_{l'} \exp[score(l' | s)]} \\
  &= \frac{\exp[\sum_{j=1}^m \sum_{i=1}^n \lambda_j f_j(s, i, l_i, l_{i-1})]}{\sum_{l'} \exp[\sum_{j=1}^m \sum_{i=1}^n \lambda_j f_j(s, i, l'_i, l'_{i-1})]}
  \end{aligned}\]
  The $f$ terms here are all unknown "feature functions" that need to be specifically designed according to the problem, which is equivalent to saying they are unknown $f(a_{k-1}, a_k; Q)$. So, I really don't know what they are.</p>

  <p>Fine, even if you are right, at least teach me how to use it?</p>

  <p>Here, I'll introduce a frequently used version—the linear chain CRF, which is the version included with TensorFlow. Let's first write out:
  \[\begin{aligned}
  &P_Q(a_1, a_2, \dots, a_n) \\
  &= P_Q(a_1) P_Q(a_2 | a_1) P_Q(a_3 | a_2) \dots P_Q(a_n | a_{n-1}) \\
  &= P_Q(a_1) \frac{P_Q(a_1, a_2)}{P_Q(a_1) P_Q(a_2)} P_Q(a_2) \frac{P_Q(a_2, a_3)}{P_Q(a_2) P_Q(a_3)} P_Q(a_3) \dots \frac{P_Q(a_{n-1}, a_n)}{P_Q(a_{n-1}) P_Q(a_n)} P_Q(a_n)
  \end{aligned}\]
  Doesn't that look quite nice? Building on the general idea of CRF, we discard the probabilistic meaning of each term and directly write:
  \[\begin{aligned}
  &P_Q(a_1, a_2, \dots, a_n) \\
  &= \frac{1}{Z} \exp \Big[ f(a_1; Q) + g(a_1, a_2; Q) + f(a_2; Q) + \dots + g(a_{n-1}, a_n; Q) + f(a_n; Q) \Big]
  \end{aligned}\]
  The so-called "linear chain" simply assumes that the function $g$ is actually independent of $Q$; in any situation, they share a common $g(a_{k-1}, a_k)$, making it nothing more than a matrix to be determined. The rest is similar to the per-tag softmax case, assuming $f(a_k; Q) \equiv f(a_k; q_k)$. According to the maximum likelihood principle, the loss should be:
  \[\begin{aligned}
  &-\log P_Q(a_1, a_2, \dots, a_n) \\
  &= - \sum_{k=1}^n f(a_k; q_k) - \sum_{k=2}^n g(a_{k-1}, a_k) + \log Z
  \end{aligned}\]
  If the preceding model uses a BiLSTM to obtain the features $q_k$, then we have the classic BiLSTM-CRF for sequence labeling tasks.</p>

  <p>So, it is now easy to understand the CRF functions provided in TensorFlow:
  <a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/crf">https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/crf</a></p>

  <p>Compared to per-tag softmax, CRF is merely a different loss function. Of course, it also adds a mutual information matrix (transition matrix), and decoding requires the Viterbi algorithm. But none of that is important, because TensorFlow has written it all for us.</p>

  <h2 id="Redesign">Redesign?</h2>

  <p>The linear chain CRF can be seen as a simplified template. Is it possible for us to refer to this template and design an improved CRF? For example, using a model to generate a mutual information matrix that is dependent on $Q$? It might be possible.</p>

  <p>Only by peeling the nutshell can one better taste the nut; that's the flavor of the nutshell. Once you know the "what" and the "why," everything becomes less mysterious.</p>

  <p>(New introduction: <a href="https://kexue.fm/archives/5542">https://kexue.fm/archives/5542</a>)</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/4695" style="color: #005fcc;">https://kexue.fm/archives/4695</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
