
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    packages: {'[+]': ['ams']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
    <h1><a href="https://kexue.fm/archives/4647">On the Design of Activation Functions in Neural Networks</a></h1>

    <p>By 苏剑林 | October 26, 2017</p>

    <p>Activation functions are the source of non-linearity in neural networks. Without these functions, the entire network would consist only of linear operations. Since the composition of linear operations is still linear, the final effect would be equivalent to a single-layer linear model.</p>

    <p>So, what are the common activation functions? Furthermore, what principles should guide the choice of an activation function? Can any non-linear function serve as an activation function?</p>

    <p>The activation functions explored here are those for hidden layers, not for the output layer. The final output generally uses specific activation functions that cannot be changed arbitrarily; for example, binary classification typically uses the sigmoid function, multi-class classification typically uses softmax, and so on. In contrast, there is more room for choice regarding activation functions in the hidden layers.</p>

    <h2>Even Floating Point Errors Work!</h2>

    <p>Theoretically, any non-linear function has the potential to be an activation function. A very convincing example is a recent successful attempt by OpenAI to use floating-point errors as an activation function. For details, please read OpenAI's blog: <a href="https://blog.openai.com/nonlinear-computation-in-linear-networks/">https://blog.openai.com/nonlinear-computation-in-linear-networks/</a></p>

    <p>Alternatively, read the introduction by Synced (Jiqi Zhixin): <a href="https://mp.weixin.qq.com/s/PBRzS4Ol_Zst35XKrEpxdw">https://mp.weixin.qq.com/s/PBRzS4Ol_Zst35XKrEpxdw</a></p>

    <p>Nonetheless, the training costs of different activation functions vary. Although OpenAI's exploration showed that even floating-point errors can serve as activation functions, the non-differentiability of this operation led them to use "Evolutionary Strategies" to train the model. "Evolutionary Strategies" refers to algorithms such as genetic algorithms, which are time-consuming and labor-intensive.</p>

    <h2>ReLU Paved the Way</h2>

    <p>Does adding differentiability to allow training via gradient descent solve all problems? Not necessarily. At the dawn of neural networks, the Sigmoid function was generally used as the activation function:</p>
    \begin{equation}\text{sigmoid}(x)=\sigma(x)=\frac{1}{1+e^{-x}}\end{equation}
    <p>The characteristic of this function is that the left end approaches 0 and the right end approaches 1. Both ends are saturated, as shown below:</p>
    <p><img src="https://kexue.fm/usr/uploads/2017/10/3745672808.png" alt="sigmoid"></p>

    <p>Because of this, its derivatives approach 0 at both ends. Since we optimize using gradient descent, a derivative approaching zero means that the update amount in each iteration is very small (proportional to the gradient). Consequently, updates become difficult. This is especially true as the number of layers increases; due to the chain rule of differentiation, the update amount becomes proportional to the $n$-th power of the gradient, making optimization even harder. This is why early neural networks could not be made very deep.</p>

    <p>A landmark activation function is the ReLU function, whose definition is very simple:</p>
    \begin{equation}\text{relu}(x)=\max(x,0)\end{equation}
    <p>Its graph is as follows:</p>
    <p><img src="https://kexue.fm/usr/uploads/2017/10/3937190011.png" alt="relu"></p>

    <p>This is a piecewise linear function. Clearly, its derivative is 1 on the positive axis and 0 on the negative axis. This ensures that half of the space across the entire real number domain is unsaturated. In contrast, the Sigmoid function is saturated in almost all regions (the proportion of saturated regions tends toward 1; saturation is defined as the derivative being very close to 0).</p>

    <p>ReLU is a piecewise linear function, and its non-linearity is weak, so networks generally need to be very deep. However, this satisfies our needs perfectly, because given the same performance, depth is often more important than width—deeper models tend to have better generalization capabilities. Thus, since the advent of the ReLU activation function, various deep models have been proposed. A landmark event was likely the success of the VGG model on ImageNet; subsequent developments need not be detailed here.</p>

    <h2>Better Swish</h2>

    <p>Despite ReLU's brilliant record, some felt that the fact that half of ReLU's domain is saturated remains a significant shortcoming. Consequently, variants such as LeakyReLU and PReLU were proposed, though these modifications are largely similar.</p>

    <p>A few days ago, the Google Brain team proposed a new activation function called Swish. Information can be found here: <a href="http://mp.weixin.qq.com/s/JticD0itOWH7Aq7ye1yzvg">http://mp.weixin.qq.com/s/JticD0itOWH7Aq7ye1yzvg</a></p>

    <p>Its definition is:</p>
    \begin{equation}\text{swish}(x)=x\cdot\sigma(x)=\frac{x}{1+e^{-x}}\end{equation}
    <p>Its graph is as follows:</p>
    <p><img src="https://kexue.fm/usr/uploads/2017/10/301540326.png" alt="Swish"></p>

    <p>The team's test results show that this function outperforms ReLU in many models.</p>

    <p>From the graph, Swish looks similar to ReLU, with the only major difference being the negative region near zero. To speak with the benefit of hindsight, even I had considered this activation function, as it is similar to the GLU activation function proposed by Facebook. The GLU activation function is:</p>
    \begin{equation}(\boldsymbol{W}_1\boldsymbol{x}+\boldsymbol{b}_1)\otimes \sigma(\boldsymbol{W}_2\boldsymbol{x}+\boldsymbol{b}_2)\end{equation}
    <p>In other words, two sets of parameters are trained separately; one set is activated by sigmoid and then multiplied by the other set. Here, $\sigma(\boldsymbol{W}_2\boldsymbol{x}+\boldsymbol{b}_2)$ is called the "gate," which is the "G" in GLU. Swish essentially takes both set of parameters to be the same, training only one set of parameters.</p>

    <h2>Improvement Ideas</h2>

    <p>Swish has stirred up some controversy. Some believe Google Brain has made a mountain out of a molehill—that improving an activation function is something small teams can do, and major teams like Google Brain should pursue more "high-end" directions. Regardless, Google Brain conducted many experiments, and the results all indicate that Swish is superior to ReLU. Therefore, we need to consider: what is the reason behind this?</p>

    <p>The following analysis is purely my own subjective conjecture and currently lacks theoretical or experimental proof; please read it with discretion. I believe a very important reason why Swish outperforms ReLU is related to initialization.</p>

    <p><strong>Swish is unsaturated near the origin; it is only saturated in regions far from the origin on the negative axis. In contrast, ReLU is saturated in half the space even near the origin. When training models, we typically use uniform or normal distribution initialization. Regardless of the type, the mean of the initialization is generally 0. This means that half of the initialized parameters fall into ReLU's saturated region, rendering half of the parameters unused at the very beginning. Especially due to strategies like BN (Batch Normalization), where outputs automatically approximate a normal distribution with a mean of 0, half of the parameters in these cases fall into ReLU's saturated zone. By comparison, Swish is slightly better because it maintains a certain unsaturated region on the negative axis, leading to higher parameter utilization.</strong></p>

    <p>As mentioned earlier, I had considered the Swish activation function but did not research it deeply. One reason was that it didn't seem concise or elegant enough—I even found it a bit ugly. Seeing that Swish's experimental results are so good, I wondered if there are similar, more aesthetically pleasing activation functions. I thought of one:</p>
    \begin{equation}x\cdot\min(1,e^x)\end{equation}
    <p>Its graph is:</p>
    <p><img src="https://kexue.fm/usr/uploads/2017/10/2407511054.png" alt="An activation function of my own design"></p>

    <p>Actually, it looks quite similar to Swish. The logic was to maintain $x$ on the positive axis, and for the negative axis, to think of a function that first decreases, then increases, and approaches 0. I thought of $xe^{-x}$, and with a slight adjustment, I arrived at this function. In some of my models, its performance was even slightly better than Swish (specifically in my Q&amp;A models). Of course, I only performed a few experiments and don't have the energy or computing power for extensive comparative testing.</p>

    <p>Comparison with Swish; orange is Swish.</p>
    <p><img src="https://kexue.fm/usr/uploads/2017/10/1187425890.png" alt="Comparison with Swish (orange)"></p>

    <p>It should be noted that if you want to use this function, you cannot write it directly in this form because the calculation of $e^x$ might overflow. A form that won't overflow is:</p>
    \begin{equation}\max(x, x\cdot e^{-\|x\|})\end{equation}
    <p>Or using the ReLU function, it can be written as:</p>
    \begin{equation}x + \text{relu}(x\cdot e^{-\|x\|}-x)\end{equation}

    <p>Could it be that all effective activation functions resemble the checkmark (√) on our homework?</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/4647" style="color: #005fcc;">https://kexue.fm/archives/4647</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
