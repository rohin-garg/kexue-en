
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    packages: {'[+]': ['ams']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  },
  loader: {load: ['[tex]/ams']}
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
    <h1><a href="https://kexue.fm/archives/8829">Entropy Normalization of Probability Distributions</a></h1>
    <p>By 苏剑林 | December 24, 2021</p>

    <p>In the previous article <a href="translation_8823.html">"From Entropy Invariance to Attention Scaling"</a>, we derived a new Attention Scale from the perspective of entropy invariance. Experiments showed that this new scale, which maintains entropy invariance, indeed results in better extrapolation performance for Attention. At that point, a natural question occurred to me:</p>

    <blockquote>
        Is there an operation similar to L2 Normalization that can directly transform a probability distribution such that it maintains its original distribution characteristics while setting its entropy to a specified value?
    </blockquote>

    <p>I searched around but found no similar research. So, I attempted to derive it myself and obtained a basically satisfactory result, which I refer to as "Entropy Normalization." I am recording it here for readers who may find it useful.</p>

    <h2>Power Transformation</h2>

    <p>First, assume an $n$-dimensional distribution $(p_1, p_2, \cdots, p_n)$. Its entropy is defined as:</p>
    \begin{equation}\mathcal{H} = -\sum_i p_i \log p_i = \mathbb{E}[-\log p_i]\end{equation}
    <p>Since $p_i \in [0,1]$, we have $-p_i \log p_i \geq 0$, and thus $\mathcal{H} \geq 0$. When one $p_i$ is 1 and the others are 0 (one-hot), it reaches its minimum value of 0. Furthermore, it can be proven that when all $p_i$ equal $1/n$, $\mathcal{H}$ reaches its maximum value of $\log n$. Therefore, the range of $\mathcal{H}$ is $[0, \log n]$.</p>

    <p>Thus, we first need to find a transformation for the distribution that can preserve the primary information of the distribution and has the capability to vary the entropy from $0$ to $\log n$. Here, we choose the power transformation:</p>
    \begin{equation}p_i\quad\to\quad \tilde{p}_i = \frac{p_i^{\gamma}}{\sum\limits_i p_i^{\gamma}}\end{equation}
    <p>One reason for choosing the power transformation is that it preserves the monotonicity of the distribution; that is, if $p_i > p_j$, then $\tilde{p}_i > \tilde{p}_j$. I believe this is one of the important properties a distribution needs to maintain. Furthermore, when all $p_i$ are non-zero and not equal to each other, the power transformation indeed has the capability to vary the entropy from $0 \sim \log n$. Without loss of generality, we assume $1 > p_1 > p_2 > \cdots > p_n > 0$. Clearly, when $\gamma = 0$, $\tilde{p}_i=1/n$, and the entropy is the maximum value $\log n$. When $\gamma \to \infty$:</p>
    \begin{equation}\tilde{p}_1 = \lim_{\gamma\to\infty}\frac{p_1^{\gamma}}{\sum\limits_i p_i^{\gamma}} = \lim_{\gamma\to\infty}\frac{1}{1 + \sum\limits_{i > 1} (p_i/p_1)^{\gamma}}=1\end{equation}
    <p>This results in a one-hot distribution $(1, 0, \cdots, 0)$, with a corresponding entropy of 0. It can be further proven by taking the derivative that the entropy is monotonically decreasing with respect to $\gamma$. Therefore, as $\gamma$ increases from $0$ to $\infty$, the entropy decreases from $\log n$ to $0$.</p>

    <h2>Iterative Solution</h2>

    <p>After determining that the power transformation is a viable method, we need to enter the solver phase. That is, for any given specified $\mathcal{H}^* \in (0, \log n)$, we need to find the correct $\gamma$ such that the entropy of the resulting distribution is the specified value $\mathcal{H}^*$.</p>

    <p>First, we write out:</p>
    \begin{equation}\mathcal{H}_{\gamma} = -\sum_i\frac{p_i^{\gamma}}{\sum\limits_i p_i^{\gamma}}\log \frac{p_i^{\gamma}}{\sum\limits_i p_i^{\gamma}}=\log\sum_i p_i^{\gamma} - \frac{\gamma\sum\limits_i p_i^{\gamma}\log p_i}{\sum\limits_i p_i^{\gamma}}\end{equation}
    <p>The complexity of the result on the far right leads us to believe that an analytical solution likely does not exist, so we must seek an iterative solution algorithm.</p>

    <p>We perform an expansion at $\gamma=1$ (mainly utilizing $p_i^{\gamma} \approx p_i + (\gamma-1)p_i\log p_i$):</p>
    \begin{equation}
    \begin{aligned}
    \mathcal{H}_{\gamma} \approx &\, -\sum_i p_i\log p_i + \left(\left(\sum_i p_i\log p_i\right)^2-\sum_i p_i\left(\log p_i\right)^2\right)(\gamma - 1)\\
    =&\, \mathcal{H}_1 + \left(\mathcal{H}_1^2-\mathbb{E}\left[\left(\log p_i\right)^2\right]\right)(\gamma - 1)
    \end{aligned}
    \end{equation}
    <p>Then:</p>
    \begin{equation}\gamma \approx 1 + \frac{\mathcal{H}_{\gamma}-\mathcal{H}_1}{\mathcal{H}_1^2-\mathbb{E}\left[\left(\log p_i\right)^2\right]}\end{equation}
    <p>Based on this result, starting from $\gamma=1$ and repeatedly applying the above formula for iteration, we can solve for the final distribution:</p>
    \begin{equation}
    \mathcal{H}\leftarrow -\sum_i p_i \log p_i,\quad
    \gamma \leftarrow 1 + \frac{\mathcal{H}^*-\mathcal{H}}{\mathcal{H}^2-\mathbb{E}\left[\left(\log p_i\right)^2\right]},\quad p_i \leftarrow \frac{p_i^{\gamma}}{\sum\limits_i p_i^{\gamma}}
    \end{equation}
    <p>This is effectively Newton's method for solving non-linear equations. In experiments, it was found that 3 to 4 iterations yield good convergence. If the actual goal is simply to roughly control the range of entropy, 1 to 2 iterations are sufficient.</p>

    <p>Numpy reference code:</p>
<pre><code>p = np.random.random(100)
p /= p.sum() # Simulate a distribution
gamma = 1
H_f = np.log(30) # Desired entropy

for i in range(10):
    H = -(p * np.log(p)).sum()
    gamma = 1 + (H_f - H) / (H**2 - (p * np.log(p)**2).sum())
    p = p**gamma
    p /= p.sum()
</code></pre>

    <h2>Application Ideas</h2>

    <p>This article mainly introduces the concept of "Entropy Normalization" because I found it interesting and wanted to derive it. However, regarding specific good application cases, I haven't fully refined them yet.</p>

    <p>Lower entropy means the probability is concentrated in a few positions; in other words, the probabilities at other positions are closer to zero. Therefore, to some extent, entropy is a measure of the sparsity of a probability distribution. If we wish to obtain sparser prediction results, we can control this via entropy normalization. On the other hand, a sparser distribution also means the model is more likely to suffer from vanishing gradients. Thus, conversely, we could use entropy normalization to ensure the entropy does not become too small, thereby alleviating the vanishing gradient problem.</p>

    <p>Speaking of sparsity, work like <a href="https://papers.cool/arxiv/1602.02068">Sparsemax</a> and <a href="https://kexue.fm/archives/8046#%E7%A8%80%E7%96%8FSoftmax">Sparse Softmax</a> (which I conceptualized) comes to mind. Sparsemax achieves sparsity by treating entropy as a penalty term, while Sparse Softmax introduces sparsity through direct truncation. Both exhibit better interpretability or effects in certain scenarios. Would sparsity brought about directly by entropy normalization be effective? This might be a question worth exploring.</p>

    <p>Additionally, in the random sampling of auto-regressive models, we often use top-$k$ or top-$p$ truncation. These truncations are essentially reducing the entropy of the distribution. Accordingly, we could use entropy normalization to ensure the entropy of the distribution at each sampling step remains consistent, potentially replacing top-$k$ or top-$p$ sampling. This is another possible application.</p>

    <p>The main issue with using entropy normalization is that there is no clear standard for which value to "normalize to." Currently, I don't have a better idea beyond observing existing experimental results to tune the parameter, but that is not an ideal answer.</p>

    <h2>Summary</h2>

    <p>This article introduced the concept of Entropy Normalization, using a direct transformation to set the entropy of a distribution to a specified value, and brainstormed some potential applications.</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/8829" style="color: #005fcc;">https://kexue.fm/archives/8829</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
