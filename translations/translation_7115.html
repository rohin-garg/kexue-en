
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    packages: {'[+]': ['ams']}
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<nav style="margin-bottom: 1.5em;">
    <a href="../index.html" style="display: inline-flex; align-items: center; color: #555; text-decoration: none; font-size: 0.95em;">
        <span style="margin-right: 0.3em;">&larr;</span> Back to Index
    </a>
</nav>

<h1><a href="https://kexue.fm/archives/7115">Universal Seq2Seq: Reading Comprehension Question Answering Based on Seq2Seq</a></h1>

<p>By 苏剑林 | December 05, 2019</p>

<p>Today, I added a new example to <a href="https://github.com/bojone/bert4keras">bert4keras</a>: Reading Comprehension Question Answering (<a href="https://github.com/bojone/bert4keras/blob/master/examples/task_reading_comprehension_by_seq2seq.py">task_reading_comprehension_by_seq2seq.py</a>). The corpora used are the same as before, <a href="translation_6906.html">WebQA and SogouQA</a>. The final score is around 0.77 (single model, without fine-tuning).</p>

<h2>Method Description</h2>

<p>Since the primary purpose this time was to add a demo to bert4keras, efficiency was not the main concern. The goal was universality and ease of use, so I adopted the most "universal" solution—using seq2seq to implement reading comprehension.</p>

<p>When using seq2seq, you basically don't need to worry about model design; you just concatenate the passage and the question and then predict the answer. Furthermore, the seq2seq approach naturally includes a method for determining whether a passage contains an answer and naturally leads to a multi-passage voting strategy. In short, if efficiency is not considered, seq2seq is a very elegant solution for reading comprehension.</p>

<p>This implementation of seq2seq still uses the UNILM scheme. Readers who are not familiar with it can read <a href="translation_6933.html">"From Language Models to Seq2Seq: Transformer as a Play, All in the Mask"</a> to understand the corresponding content.</p>

<h2>Model Details</h2>

<p>Building a seq2seq model using the UNILM scheme in bert4keras is basically a one-line task. Therefore, the main work in this example is not on building the model itself, but on handling the input and output.</p>

<h3>Input Format</h3>

<p>First is the input. The input format is simple and can be clearly explained with a diagram:</p>

<p>
  <a href="https://kexue.fm/usr/uploads/2019/12/4085505815.png" title="Click to view original image">
    <img src="https://kexue.fm/usr/uploads/2019/12/4085505815.png" alt="Illustration of Reading Comprehension Model using seq2seq">
  </a>
  <br>
  Illustration of Reading Comprehension Model using seq2seq
</p>

<h3>Output Processing</h3>

<p>If you are inputting a single passage and a single question to answer, you can simply follow the standard seq2seq processing scheme—beam search—for decoding.</p>

<p>However, WebQA and SogouQA are designed for search scenarios, meaning multiple passages exist simultaneously to answer the same question. This involves choosing a voting strategy. A naive idea is: each passage is combined with the question and decoded separately using beam search, providing a confidence level, and finally voting according to the method in <a href="translation_5409.html">"DGCNN: A Reading Comprehension-based Question Answering Model"</a>. The difficulty with this approach is assigning a reasonable confidence level to each answer; it appears less natural than the idea we present below and is also slightly less efficient.</p>

<p>Here, we provide a scheme that is more "integrated" with beam search:</p>

<blockquote>
  Exclude passages that have no answer first, and then when decoding each character of the answer, directly average the probability values predicted by all passages (in a specific way).
</blockquote>

<p>Specifically, all passages are concatenated with the question separately, and their respective probability distributions for the first character are produced. Passages where the first character produced is [SEP] are considered to have no answer and are excluded. After exclusion, the probability distributions of the first character from the remaining passages are averaged, and the top-k are retained (standard beam search procedure). When predicting the second character, each passage is combined with the top-k candidate values to predict their respective second-character probability distributions, which are then averaged by passage to provide the next top-k. This continues until [SEP] appears. (Essentially, it is standard beam search plus averaging by passage. If you still can't quite grasp it, you'll have to check the source code~)</p>

<p>Additionally, there should be two ways to generate answers: one is extractive, where the answer must be a fragment of the passage; the other is generative, where you don't need to consider whether the answer is a passage fragment and just decode to generate the answer. Both modes have corresponding logic in the decoding process of this article.</p>

<h2>Experimental Code</h2>

<p>Code link: <a href="https://github.com/bojone/bert4keras/blob/master/examples/task_reading_comprehension_by_seq2seq.py">task_reading_comprehension_by_seq2seq.py</a></p>

<p>Ultimately, on the <a href="https://github.com/bojone/dgcnn_for_reading_comprehension">evaluation script provided by SogouQA</a>, the valid set score is approximately 0.77 (Accuracy=0.7259005836184343, F1=0.813860036706151, Final=0.7698803101622926). This single-model performance far exceeds the previous <a href="translation_6906.html">"Open Source Edition of DGCNN Reading Comprehension QA Model (Keras Version)"</a>. Of course, the improvement comes at a cost—inference speed is significantly reduced, only predicting about 2 samples per second.</p>

<p>(The model has not been finely tuned; there is likely still room for improvement. The current focus is primarily on the demo.)</p>

<h2>Summary</h2>

<p>This article mainly provides an example of reading comprehension based on BERT and seq2seq ideas, and presents a multi-passage voting beam search strategy for readers' reference and testing~</p>

<p><strong>If you found this article helpful, you are welcome to share or reward this article. Rewards are not intended for profit, but to let me know how much sincere attention Scientific Spaces has received from its readers. Of course, if you ignore it, it will not affect your reading. Welcome and thank you again!</strong></p>

<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/7115" style="color: #005fcc;">https://kexue.fm/archives/7115</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
