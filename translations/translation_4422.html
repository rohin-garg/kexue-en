
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    packages: {'[+]': ['ams']}
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<nav style="margin-bottom: 1.5em;">
    <a href="../index.html" style="display: inline-flex; align-items: center; color: #555; text-decoration: none; font-size: 0.95em;">
        <span style="margin-right: 0.3em;">&larr;</span> Back to Index
    </a>
</nav>

<h1><a href="https://kexue.fm/archives/4422">General Crawler Exploration (II): Implementation on Forum Crawling</a></h1>

<p>By 苏剑林 | June 06, 2017</p>

<p>The solution mentioned previously is essentially sufficient if the crawled page has only a single effective area, such as a blog page or a news page. However, for websites with distinct hierarchical divisions, such as forums, we need further subdivision. This is because, after the aforementioned steps, while we can extract the effective text, the result is that all text is lumped together.</p>

<h2>Depth-First</h2>

<p>In order to further "chunk" the content, we also need to utilize the position information from the DOM tree. As shown in the DOM tree diagram in the previous article, we need to number every node and leaf, which requires a method to traverse the DOM tree. Here, we adopt a "Depth-First" approach.</p>

<p><strong>Depth-First Search</strong> (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. This process continues until all nodes reachable from the source node have been discovered. If any undiscovered nodes remain, one of them is selected as a new source, and the process is repeated until all nodes have been visited.</p>

<p>After a depth-first search of the DOM tree from the previous article, the numbering of each node and leaf is shown in the figure below.</p>

<p><a href="https://kexue.fm/usr/uploads/2017/06/4262993599.png" title="Click to view original image"><img src="https://kexue.fm/usr/uploads/2017/06/4262993599.png" alt="DOM Tree Numbering" /></a><br />
DOM Tree Numbering</p>

<h2>Exception Tags</h2>

<p>Numbering nodes is for subsequent clustering, and we naturally hope that the difference in numbering within the same class is as small as possible. Among many HTML tags, quite a few only serve to represent emphasis, hyperlinks, etc., such as the <code>strong</code> tag for bolding, the <code>em</code> tag for italics, and so on. These tags only change the style of the content without changing its hierarchy. Therefore, when traversing these tags, the numbering can remain unchanged. This ensures that tags within the same hierarchy are more similar, ensuring the effectiveness of clustering.</p>

<p>The exception tags we have listed are shown in the table below:</p>

<table border="1" style="width:100%; border-collapse: collapse;">
  <thead>
    <tr>
      <th>Tag</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>p/br</td>
      <td>Line break</td>
    </tr>
    <tr>
      <td>strong/b</td>
      <td>Bold</td>
    </tr>
    <tr>
      <td>em</td>
      <td>Italic</td>
    </tr>
    <tr>
      <td>font</td>
      <td>Font style</td>
    </tr>
    <tr>
      <td>u</td>
      <td>Underline</td>
    </tr>
    <tr>
      <td>a</td>
      <td>Hyperlink</td>
    </tr>
    <tr>
      <td>img</td>
      <td>Insert image</td>
    </tr>
    <tr>
      <td>h1/h2/h3/h4/h5</td>
      <td>Heading markers</td>
    </tr>
  </tbody>
</table>

<p>For the complete list of exception tags, please refer directly to the source code.</p>

<h2>Differential Peak Clustering</h2>

<p>By extracting the effective text through the previous steps and numbering it via the depth-first method described above, we obtain a sequence regarding text positions. We will find that the difference in numbering within the same module is relatively small, while the difference between different modules is relatively large. For example, the position numbers of the title, date, and content of the same article are very close, and the position numbers of the title, date, and reply content of a post on the same floor are also relatively close, as shown below. This induces us to use these position numbers to further cluster the effective text.</p>

<p><a href="https://kexue.fm/usr/uploads/2017/06/2512243094.png" title="Click to view original image"><img src="https://kexue.fm/usr/uploads/2017/06/2512243094.png" alt="BBS floor division" /></a><br />
BBS floor division</p>

<p>To this end, we examine the differential graph of the position sequence and describe the floor boundaries of the actual situation with red dashed lines, resulting in the following figure:</p>

<p><a href="https://kexue.fm/usr/uploads/2017/06/3131760149.png" title="Click to view original image"><img src="https://kexue.fm/usr/uploads/2017/06/3131760149.png" alt="Differential sequence graph" /></a><br />
The result of taking the differential of the position numbering sequence, using the index of the differential sequence as the x-axis and the differential result as the y-axis.</p>

<p>The figure above shows a very obvious pattern: the boundaries of each floor are basically at the local maximums of the differential sequence. Therefore, we can use this scheme to perform segmentation-style clustering, splitting the text at local peaks. This clustering method has excellent properties, such as:</p>

<blockquote>
  <p>1. It can automatically determine the number of clusters, meaning we don't need to know in advance exactly how many floors there are;</p>
  <p>2. It adapts to special cases. For example, if the second and third to last floors are wider than other floors because they contain comments within the floor (so-called "floor-within-floor"), this pattern still holds true even if the content is more extensive.</p>
</blockquote>

<p>This shows that using this pattern to block text and divide different floors is quite reliable. Furthermore, this clustering can be run repeatedly to adapt to different granularity requirements. In fact, for forums, running it approximately $1 \sim 2$ times is enough to obtain the floor division.</p>

<h2>Content Recognition</h2>

<p>Finally, specifically for forums, we categorize the content of each text area. To avoid complicates the crawler and ensure the efficiency of the crawler itself, the recognition methods used here are relatively simple and are purely rule-based classifications.</p>

<h3>Title</h3>

<p>Title recognition is relatively simple because normal page source codes contain a <code>&lt;title&gt;</code> field, which basically contains complete title information. Therefore, we just need to extract the title directly using regular expressions.</p>

<h3>Date</h3>

<p>In Chinese forums, several date formats are common:</p>

<blockquote>
  <p>2017-1-9 15:42</p>
  <p>2017年 1月 9日 15:42</p>
  <p>3小时前 (3 hours ago)</p>
  <p>昨天 20:48 (Yesterday 20:48)</p>
</blockquote>

<p>The first two date formats are easier to recognize, while the latter two are more difficult. The latter two formats mainly appear in posts published within a short period on certain forums and usually automatically revert to the first two formats after a day or two.</p>

<p>In this case, from the perspective of simplicity and stability, we can adopt a compromise strategy: do not recognize the dates for this part of the short-term posts on these websites and save them mixed together. From a continuous monitoring perspective, after a day or two, we will be able to recognize the dates. This neither affects the real-time nature of monitoring nor makes the program simpler and more reliable.</p>

<h3>Author</h3>

<p>In fact, identifying the author (the poster) is quite difficult; we have not found an effective algorithm to complete a universal author recognition model. also, considering that the value of identifying the poster is not particularly high, we ultimately abandoned this part of the recognition work.</p>

<h3>Main Body</h3>

<p>After identifying the time, the single text area is split into upper and lower halves by the time. We assume that one of the two halves is the main content. To identify which half is the body, we perform global statistics on both halves respectively and compare which half contains more Chinese characters. The half with more is considered the main content.</p>

<p>Of course, from a more rigorous perspective, one could follow the academic thinking in the previous article and use a language model to determine which part is closer to natural language, thereby identifying the main body. However, the efficiency of this scheme is low, and since we are primarily concerned with crawling Chinese content, we excluded this scheme from our experiments.</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/4422" style="color: #005fcc;">https://kexue.fm/archives/4422</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
