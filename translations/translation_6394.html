
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      tags: 'ams',
      packages: {'[+]': ['ams']}
    }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/6394">A Brief Introduction to the Non-Adversarial Generative Model GLANN</a></h1>

    <p>By 苏剑林 | February 26, 2019</p>


<p>A while ago, I saw that Facebook published a non-adversarial generative model called GLANN (posted on arXiv last December), claiming it could generate 1024 high-definition faces using a non-adversarial approach. I read it with great interest and indeed gained some insights, but I was also somewhat disappointed. As for why I was disappointed, you will understand as you read on.</p>

<p>Original paper: <a href="https://arxiv.org/abs/1812.08194">"Non-Adversarial Image Synthesis with Generative Latent Nearest Neighbors"</a><br>
Introduction by Machine Heart (Ji Qi Zhi Xin): <a href="https://www.jiqizhixin.com/articles/2018-12-25-3">"Why let GAN dominate? Facebook proposes GLANN, a non-adversarial generation method"</a></p>

<p>Sample results:<br>
<img src="https://kexue.fm/usr/uploads/2019/02/1032822081.png" alt="GLANN Results" /><br>
Below is a simple breakdown of the content related to the GLANN model.</p>

<h2>Implicit Maximum Likelihood</h2>
<p>The foundation of the entire GLANN method is "Implicit Maximum Likelihood Estimation", from the article <a href="https://arxiv.org/abs/1809.09087">"Implicit Maximum Likelihood Estimation"</a>, referred to as "IMLE". This article was only posted on arXiv last September, which surprised me quite a bit. Because the algorithm is so simple—I had already used it two years ago—I always felt it was an obviously valid method; yet it was published so late... (I feel like I missed out on millions).</p>

<h3>Directly Estimating the Probability Distribution</h3>
<p>The appendix of the IMLE paper provides a lot of complex mathematical derivations, but I feel they are not really necessary. IMLE is essentially the result of an integral approximation of the Dirac distribution.</p>

<p>In general, consider the following sampling process:
\begin{equation}z\sim q(z),\quad x = G(z)\end{equation}
This is actually assuming the distribution of $x$ is:
\begin{equation}q(x)=\int \delta\big(x-G(z)\big)q(z)dz\end{equation}
where $q(z)$ is generally a normal or uniform distribution, and $\delta(\cdot)$ represents the (multivariate) Dirac delta function.</p>

<p>Note that $q(x)$ can also be written as:
\begin{equation}q(x)=\mathbb{E}_{z\sim q(z)}\big[\delta\big(x-G(z)\big)\big]\end{equation}
And $\delta(\cdot)$ is actually a Gaussian distribution as the variance tends to 0:
\begin{equation}\delta(x)=\lim_{\sigma\to 0}\frac{1}{(2\pi\sigma^2)^{d/2}}\exp\left(-\frac{\Vert x\Vert^2}{2\sigma^2}\right)\end{equation}
With this in mind, we might as well let $\sigma$ take a finite value, perform calculations, and then let $\sigma\to 0$, i.e.,
\begin{equation}q(x)=\lim_{\sigma\to 0}\mathbb{E}_{z\sim q(z)}\left[\frac{1}{(2\pi\sigma^2)^{d/2}}\exp\left(-\frac{\Vert x - G(z)\Vert^2}{2\sigma^2}\right)\right]\end{equation}
Then, we perform maximum likelihood estimation, using $-\int p(x)\log q(x)dx$ as the loss, where $p(x)$ is the distribution of real samples:
\begin{equation}\begin{aligned}loss=&-\int p(x) \log \left\{\mathbb{E}_{z\sim q(z)}\left[\frac{1}{(2\pi\sigma^2)^{d/2}}\exp\left(-\frac{\Vert x - G(z)\Vert^2}{2\sigma^2}\right)\right]\right\}dx\\ 
=&\mathbb{E}_{x\sim p(x)}\left[-\log \left\{\mathbb{E}_{z\sim q(z)}\left[\frac{1}{(2\pi\sigma^2)^{d/2}}\exp\left(-\frac{\Vert x - G(z)\Vert^2}{2\sigma^2}\right)\right]\right\}\right]\\ 
\sim &\mathbb{E}_{x\sim p(x)}\left[-\log \left\{\mathbb{E}_{z\sim q(z)}\left[\exp\left(-\frac{\Vert x - G(z)\Vert^2}{2\sigma^2}\right)\right]\right\}\right]\end{aligned}\end{equation}
In the final expression, we have omitted constants irrelevant to the optimization.</p>

<p>Now we convert the expectation $\mathbb{E}$ into sampling, by substituting samples $x_1,x_2,\dots,x_M\sim p(x)$ and $z_1,z_2,\dots,z_N\sim q(z)$ into the loss:
\begin{equation}\begin{aligned}loss\sim& -\frac{1}{M}\sum_{i=1}^M \log \left\{\frac{1}{N}\sum_{j=1}^N\exp\left(-\frac{\Vert x_i - G(z_j)\Vert^2}{2\sigma^2}\right)\right\}\\ 
\sim& -\frac{1}{M}\sum_{i=1}^M \log \left\{\sum_{j=1}^N\exp\left(-\frac{\Vert x_i - G(z_j)\Vert^2}{2\sigma^2}\right)\right\}\end{aligned}\end{equation}
From the article <a href="translation_3290.html">"Seeking a Smooth Maximum Function"</a>, we know that $\text{logsumexp}$ (exponentiation, summation, then taking the logarithm) is actually a smooth approximation of the $\max$. As $\sigma\to 0$, it becomes the $\max$; adding a negative sign makes it the $\min$. Thus, the simplest form as $\sigma\to 0$ is:
\begin{equation}loss\sim \frac{1}{M}\sum_{i=1}^M \left(\min_{j=1}^N \Vert x_i - G(z_j)\Vert^2\right)\end{equation}
This is the loss used by IMLE. (The derivation is a bit long only because it's written in detail; it's actually not hard!)</p>

<p>Therefore, the specific process of IMLE is:<br />
1. Sample a batch of real samples $x_1,x_2,\dots,x_M$;<br />
2. Sample a batch of noise $z_1,z_2,\dots,z_N$, to obtain a batch of fake samples $\hat{x}_1,\hat{x}_2,\dots,\hat{x}_N$;<br />
3. For each real sample $x_i$, find its nearest fake sample $\hat{x}_{\rho(i)}$;<br />
4. Minimize the average distance $\frac{1}{M}\sum\limits_{i=1}^M \Vert x_i - \hat{x}_{\rho(i)}\Vert^2$.</p>

<h3>Analysis and Discussion of Effects</h3>
<p>Putting the derivation aside, this algorithm is quite simple: if every real sample can find a sufficiently close fake sample among the generated ones, doesn't that imply the generated samples are also very good?</p>

<p>That is why I said it was unbelievable that this algorithm was published so late. Now let's look at the results. The principle of the algorithm is sound, but the problem lies in the fact that "nearest" in the algorithm above uses the $L_2$ distance. For images, $L_2$ is not a good metric, so it is foreseeable that this method suffers from blurriness, much like VAEs. In fact, looking at the results on CelebA, it doesn't even compare to a VAE:</p>

<p><img src="https://kexue.fm/usr/uploads/2019/02/1033285449.png" alt="IMLE results on CelebA" /></p>

<p>Code: <a href="https://github.com/bojone/gan/blob/master/imle.py">https://github.com/bojone/gan/blob/master/imle.py</a></p>

<p>Actually, this idea can be generalized to general divergence optimization. For example, we could use
\begin{equation}KL(q(x)\Vert p(x))=\int q(x)\log \frac{q(x)}{p(x)}dx=\mathbb{E}_{x\sim q(x)}\big[\log q(x)-\log p(x)\big]\end{equation}
as the optimization objective. Treating $\log q(x)$ and $\log p(x)$ with the same method, the result is:
\begin{equation}loss\sim -\frac{1}{M}\sum_{i=1}^M \left(\min_{j=1}^N \Vert G(z_i) - x_j\Vert^2 - \min_{j=1}^K \Vert G(z_i) - G(z_j)\Vert^2\right)\end{equation}
Alternatively, setting a margin $m$ might make the effect better:
\begin{equation}loss\sim -\frac{1}{M}\sum_{i=1}^M \left(\min_{j=1}^N \Vert G(z_i) - x_j\Vert^2 + \text{relu}\left(m - \min_{j=1}^K \Vert G(z_i) - G(z_j)\Vert^2\right)\right)\end{equation}
Note that here two batches of fake samples must be sampled, otherwise the second term becomes meaningless (within the same batch, the second term is always 0). The second term is used to prevent mode collapse. The process for this new algorithm is:<br />
1. Sample a batch of real samples $x_1,x_2,\dots,x_M$;<br />
2. Sample a batch of noise $z_1,z_2,\dots,z_N$, to obtain a batch of fake samples $\hat{x}_1,\hat{x}_2,\dots,\hat{x}_N$;<br />
3. Sample another batch of noise $z_{N+1},z_{N+2},\dots,z_{N+K}$, to obtain another batch of fake samples $\hat{x}_{N+1},\hat{x}_{N+2},\dots,\hat{x}_{N+K}$;<br />
4. For each fake sample $\hat{x}_i$ ($1\leq i\leq N$), find its nearest real sample $x_{\rho_1(i)}$;<br />
5. For each fake sample $\hat{x}_i$ ($1\leq i\leq N$), find its nearest fake sample $\hat{x}_{N+\rho_2(i)}$ among $\hat{x}_{N+1},\hat{x}_{N+2},\dots,\hat{x}_{N+K}$;<br />
6. Minimize the "Real-Fake" distance while maximizing the "Fake-Fake" distance, which is the loss above.</p>

<p>Sample results:<br />
<img src="https://kexue.fm/usr/uploads/2019/02/1004663914.png" alt="Another IMLE result on CelebA" /><br />
They look about the same...</p>

<h2>From IMLE to GLANN</h2>
<p>Returning to the discussion of IMLE itself, it can be imagined that the main reason for its poor performance is the use of the $L_2$ distance. So, what if we replace it with another distance? For image realism, is there an existing loss function we can use?</p>

<h3>Perceptual Loss</h3>
<p>There actually is one: perceptual loss! This perceptual loss originated from style transfer, specifically from the paper <a href="https://arxiv.org/abs/1603.08155">"Perceptual Losses for Real-Time Style Transfer and Super-Resolution"</a>. Calculating this perceptual loss is somewhat complicated; it requires a pre-trained ImageNet model, generally VGG for simplicity, then calculating the vectors of its last few hidden layers, and then computing the $L_2$ (or $L_1$) distance of these hidden layer vectors and the $L_2$ (or $L_1$) distance of their Gram matrices, and finally summing them up.</p>

<p>This distance works quite well in style transfer tasks, but it is complex to calculate and feels more like an engineering product than a theoretical derivation. Therefore, I'm not very fond of it and have no interest in writing about it in detail. In short, one can combine perceptual loss with IMLE:
\begin{equation}loss\sim \frac{1}{M}\sum_{i=1}^M \left(\min_{j=1}^N d_{perceptual}\big(x_i,G(z_j)\big)\right)\label{eq:perceptual-1}\end{equation}</p>

<h3>Intermediate Product: GLO</h3>
<p>Directly optimizing the objective $\eqref{eq:perceptual-1}$ is theoretically fine, but the computational cost is huge. As mentioned, calculating perceptual loss is complex and requires a pre-trained ImageNet model. If the batch size is 64, we would need to calculate $64^2=4096$ perceptual losses per batch and take the minimum, which would be unacceptably slow or even impossible to run.</p>

<p>Therefore, GLANN also utilizes a technique called GLO, which comes from the paper <a href="https://arxiv.org/abs/1707.05776">"Optimizing the latent space of generative networks"</a>. GLO is also an extremely simple concept that resulted in yet another full paper... GLO doesn't even intend to be a generative model; GLO just wants to obtain a low-dimensional embedding. Suppose the real sample set is $x_1,x_2,\dots,x_M$; then GLO's optimization objective is:
\begin{equation}\mathop{\text{argmin}}_{G,\hat{z}_1,\dots,\hat{z}_M}\frac{1}{M}\sum_{i=1}^M d\big(x_i, G(\hat{z}_i)\big)\quad \text{s.t.}\quad \Vert z_i\Vert=1\end{equation}
GLO optimizes $\hat{z}_1,\dots,\hat{z}_M$ directly, which is equivalent to an Embedding layer, training an embedding for each image. The variable parts of the model are the constraints on the Embedding and the metric $d$. For GLANN, perceptual loss is used:
\begin{equation}\mathop{\text{argmin}}_{G,\hat{z}_1,\dots,\hat{z}_M}\frac{1}{M}\sum_{i=1}^M d_{perceptual}\big(x_i, G(\hat{z}_i)\big)\quad \text{s.t.}\quad \Vert z_i\Vert=1\end{equation}
This way, even with a batch size of 64, we only need to calculate 64 perceptual losses per batch since it doesn't involve pairwise comparisons.</p>

<h3>Final Result: GLANN</h3>
<p>Now that we have $\hat{z}_1,\dots,\hat{z}_M$, then $G(\hat{z}_i)$ can generate images. Now we just need to treat $\hat{z}_1,\dots,\hat{z}_M$ as raw data and apply IMLE (where we can use $L_2$ because it is just in the latent space):
\begin{equation}\mathop{\text{argmin}}_{T}\frac{1}{M}\sum_{i=1}^M \left(\min_{j=1}^N \Vert \hat{z}_i - T(z_j)\Vert^2\right)\end{equation}
This yields the generative model. The complete generation process is:
\begin{equation}z\sim q(z)\quad\xrightarrow{\quad T\quad }\quad \hat{z}_i \quad \xrightarrow{\quad G\quad }\quad x_i\end{equation}</p>

<h2>Personal Evaluation</h2>
<p>That concludes the explanation of the GLANN model. Overall, it is a model that integrates several techniques. As for the results, look at the images at the beginning; personally, I don't think the results are particularly great—the backgrounds are always a bit messy. Of course, it is undoubtedly better than pure IMLE or GLO, and it should be much easier to train than a GAN.</p>

<p>The main improvement of GLANN is replacing the $L_2$ distance with perceptual loss. In fact, this substitution should be applicable to many models; I suspect it could even be used in VAEs. On the other hand, the perceptual loss approach is too engineered for my taste, so I didn't feel like investigating it further. Also, the GLANN paper reported FID advantages on certain datasets. This looks good, but it is actually unfair. Since the calculation of FID itself relies on an ImageNet model, and the GLANN loss also uses an ImageNet model, GLANN's generation naturally has an advantage regarding FID.</p>

<p>In fact, one could use FID as the loss directly, train a GLO, and then train an IMLE to get a generative model. The FID of a generative model made this way would definitely be very low, but it wouldn't mean much because the reality of the images would not be guaranteed.</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="translation_6394.html" style="color: #005fcc;">https://kexue.fm/archives/6394</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
