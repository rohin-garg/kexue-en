
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    tags: 'ams',
    packages: {'[+]': ['ams']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<nav style="margin-bottom: 1.5em;">
    <a href="../index.html" style="display: inline-flex; align-items: center; color: #555; text-decoration: none; font-size: 0.95em;">
        <span style="margin-right: 0.3em;">&larr;</span> Back to Index
    </a>
</nav>

<h1><a href="https://kexue.fm/archives/3414">Text Sentiment Classification (II): Deep Learning Models</a></h1>

<p>By 苏剑林 | August 04, 2015</p>

<p>In the article <a href="translation_3360.html">"Text Sentiment Classification (I): Traditional Models,"</a> I briefly introduced the traditional approach to text sentiment classification. Traditional methods are easy to understand and relatively stable. However, they face two difficult-to-overcome limitations: <strong>1. Accuracy issues</strong>—traditional methods are generally satisfactory for common applications, but there is a lack of effective ways to further improve precision; <strong>2. Background knowledge issues</strong>—traditional methods require the prior extraction of an emotional dictionary. This step often requires manual intervention to ensure accuracy. In other words, the person doing this work must not only be a data mining expert but also a linguist. This dependency on background knowledge hinders progress in natural language processing (NLP).</p>

<p>Fortunately, deep learning has solved this problem (at least to a large extent). It allows us to build models for practical problems in specific fields with almost "zero background." This article continues the discussion on text sentiment classification by explaining deep learning models. Parts that were already discussed in detail in the previous article will not be repeated here.</p>

<h3>Deep Learning and Natural Language Processing <a name="深度学习与自然语言处理" href="https://kexue.fm/archives/3414#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86">#</a></h3>

<p>In recent years, deep learning algorithms have been applied to the field of natural language processing, achieving results superior to traditional models. Scholars like Bengio built neural probabilistic language models based on deep learning ideas and further utilized various deep neural networks to train language models on large-scale English corpora. This led to better semantic representations and completed common NLP tasks such as syntactic analysis and sentiment classification, providing new ideas for NLP in the era of big data.</p>

<p>According to my tests, sentiment analysis models based on deep neural networks <strong>often achieve an accuracy of over 95%</strong>. The charm and power of deep learning algorithms are evident!</p>

<p>For further information on deep learning, please refer to the following literature:</p>

<blockquote>
    [1] Yoshua Bengio, Réjean Ducharme Pascal Vincent, Christian Jauvin. A Neural Probabilistic Language Model, 2003<br>
    [2] A New Language Model: <a href="http://blog.sciencenet.cn/blog-795431-647334.html">http://blog.sciencenet.cn/blog-795431-647334.html</a><br>
    [3] Organized Deep Learning Notes: <a href="http://blog.csdn.net/zouxy09/article/details/8775360">http://blog.csdn.net/zouxy09/article/details/8775360</a><br>
    [4] Deep Learning: <a href="http://deeplearning.net">http://deeplearning.net</a><br>
    [5] Talk on Automatic Chinese Word Segmentation and Semantic Recognition: <a href="http://www.matrix67.com/blog/archives/4212">http://www.matrix67.com/blog/archives/4212</a><br>
    [6] Application of Deep Learning in Chinese Word Segmentation and Part-of-Speech Tagging: <a href="http://blog.csdn.net/itplus/article/details/13616045">http://blog.csdn.net/itplus/article/details/13616045</a>
</blockquote>

<h3>Representation of Language <a name="语言的表达" href="https://kexue.fm/archives/3414#%E8%AF%AD%E8%A8%80%E7%9A%84%E8%A1%A8%E8%BE%BE">#</a></h3>

<p>In the article <a href="translation_3331.html">"Chitchat: Neural Networks and Deep Learning,"</a> I mentioned that the most important step in modeling is feature extraction, and NLP is no exception. In NLP, the core question is: how can a sentence be effectively represented in numerical form? If this step can be completed, sentence classification becomes straightforward. Obviously, an elementary idea is to assign a unique ID (1, 2, 3, 4...) to each word and then treat a sentence as a set of IDs. For example, if 1, 2, 3, 4 represent "I", "you", "love", and "hate" respectively, then "I love you" is [1, 3, 2] and "I hate you" is [1, 4, 2]. This approach seems effective but is actually very problematic. For instance, a stable model would assume that 3 and 4 are very close, and thus [1, 3, 2] and [1, 4, 2] should yield similar classification results. However, according to our numbering, the meanings of the words represented by 3 and 4 are completely opposite, so the classification results cannot be the same. Therefore, this encoding method cannot provide good results.</p>

<p>Readers might think: <strong>what if I cluster the IDs of words with similar meanings together (giving them similar IDs)</strong>? Well, indeed, if there is a way to place IDs of similar words close to each other, it would greatly improve the model's accuracy. But the problem arises: if each word is given a unique ID and similar words are given similar IDs, we are essentially assuming semantic singularity—that is, assuming semantics are only one-dimensional. However, this is not the case; semantics should be multi-dimensional.</p>

<p><strong>For example, when we talk about "Home" (家园), some might think of the synonym "Family" (家庭), and from "Family," one might think of "Relatives" (亲人). These are all related meanings. On the other hand, from "Home," some might think of "Earth" (地球), and from "Earth," one might think of "Mars" (火星). In other words, both "Relatives" and "Mars" can be seen as secondary approximations of "Home," but there is no obvious connection between "Relatives" and "Mars" themselves. Furthermore, semantically speaking, "University" or "Comfortable" can also be considered secondary approximations of "Home." Clearly, with just a single unique ID, it is difficult to place these words in appropriate positions.</strong></p>

<p><i>The divergence of words</i></p>

<h3>Word2Vec: High Dimensions Have Arrived <a name="Word2Vec：高维来了" href="https://kexue.fm/archives/3414#Word2Vec%EF%BC%9A%E9%AB%98%E7%BB%B4%E6%9D%A5%E4%BA%86">#</a></h3>

<p>From the above discussion, we know that the meanings of many words diverge in various directions rather than just one direction; therefore, a single ID is not ideal. So, how about multiple IDs? In other words, mapping a word to a multi-dimensional vector? Exactly, this is a very correct line of thought.</p>

<p>Why are multi-dimensional vectors feasible? First, multi-dimensional vectors solve the multi-directional divergence of words; even a 2D vector can rotate 360 degrees, let alone higher dimensions (typically hundreds of dimensions in practical applications). Second, there is a practical benefit: multi-dimensional vectors allow us to represent words using numbers that change within a small range. What does this mean? We know that in Chinese, the number of words is in the hundreds of thousands. If each word is given a unique ID, the IDs range from 1 to several hundred thousand. With such a large range of variation, model stability is difficult to guarantee. With high-dimensional vectors, say 20 dimensions, then only 0s and 1s are needed to represent $2^{20} = 1,048,576$ (1 million) words. Smaller variations help ensure model stability.</p>

<p>Having said all that, we haven't yet reached the core point. Now that we have the idea, the question is: how do we place these words into the correct high-dimensional vectors? And importantly, how do we do this without a linguistic background? (In other words, if I want to process English tasks, I shouldn't need to learn English first; I only need to collect a large number of English articles. How convenient!) We won't expand more on the theoretical principles here; instead, we introduce a famous open-source tool from Google based on this idea—<a href="https://code.google.com/p/word2vec/">Word2Vec</a>.</p>

<p>Simply put, Word2Vec does exactly what we want—it represents words using high-dimensional vectors (Word Embeddings) and puts words with similar meanings in similar positions, using real-valued vectors (not limited to integers). We only need a large corpus of a certain language to train the model and obtain word vectors. The benefits of word vectors have been mentioned; essentially, they were created to solve the problems discussed earlier. Other benefits include: word vectors can easily be used for clustering, and Euclidean distance or cosine similarity can be used to find words with similar meanings. This essentially solves the "synonym" problem (unfortunately, there doesn't seem to be a good way yet to solve the "polysemy" problem).</p>

<p>Regarding the mathematical principles of Word2Vec, readers can refer to <a href="http://blog.csdn.net/itplus/article/details/37969519">this series of articles</a>. For the implementation, Google provides the official C source code, which readers can compile themselves. The Python Gensim library also provides Word2Vec as a sub-library (in fact, this version seems more powerful than the official one).</p>

<h3>Representing Sentences: Sentence Vectors <a name="表达句子：句向量" href="https://kexue.fm/archives/3414#%E8%A1%A8%E8%BE%BE%E5%8F%A5%E5%AD%90%EF%BC%9A%E5%8F%A5%E5%90%91%E9%87%8F">#</a></h3>

<p>The next problem to solve is: we have segmented the text into words and converted the words into high-dimensional vectors. A sentence then corresponds to a set of word vectors, which is a matrix, similar to image processing where a digitized image corresponds to a pixel matrix. However, model inputs generally only accept one-dimensional features. What should we do? One simple idea is to flatten the matrix, i.e., concatenate word vectors one after another to form a longer vector. This idea is feasible, but it would result in input dimensions as high as several thousand or even tens of thousands. In fact, this is difficult to implement. (If tens of thousands of dimensions aren't a problem for today's computers, consider that for a $1000 \times 1000$ image, it would be as high as 1 million dimensions!)</p>

<p>In fact, for image processing, there is already a mature method called <strong>Convolutional Neural Networks</strong> (CNNs). It is a type of neural network specifically designed to handle matrix inputs, capable of encoding matrix-form inputs into lower-dimensional one-dimensional vectors while retaining most useful information. The CNN approach can be directly applied to NLP, especially in text sentiment classification, with good results. Related articles include <a href="http://www.aclweb.org/anthology/C14-1008">"Deep Convolutional Neural Networks for Sentiment Analysis of Short Texts"</a>. However, the principles of sentences are different from images. Applying the image approach directly to language, while somewhat successful, feels slightly out of place. Therefore, it is not the mainstream method in NLP.</p>

<p>In NLP, the methods usually used are <strong>Recursive Neural Networks</strong> or <strong>Recurrent Neural Networks</strong> (both called RNNs). Their role is the same as CNNs: encoding matrix inputs into lower-dimensional one-dimensional vectors while retaining most useful information. The difference from CNNs is that CNNs focus more on global fuzzy perception (like looking at a photo; we don't actually see every pixel clearly, but grasp the overall content), while RNNs focus on the reconstruction of neighboring positions. From this, it is clear that for language tasks, RNNs are more persuasive (language is always composed of adjacent characters forming words, adjacent words forming phrases, adjacent phrases forming sentences, etc.; thus, it is necessary to effectively integrate or reconstruct information from neighboring positions).</p>

<p>Speaking of model classification, they are truly endless. Within the RNNs subset, there are many variants, such as standard RNNs, as well as GRU, LSTM, etc. Readers can refer to the Keras official documentation: <a href="http://keras.io/models/">http://keras.io/models/</a>. This is a deep learning library for Python that provides a large number of deep learning models. Its official documentation serves as both a help tutorial and a list of models—it basiclly implements the currently popular deep learning models.</p>

<h3>Building an LSTM Model <a name="搭建LSTM模型" href="https://kexue.fm/archives/3414#%E6%90%AD%E5%BB%BALSTM%E6%A8%A1%E5%9E%8B">#</a></h3>

<p>After so much talk, it’s time to do some real work. Now we build a deep learning model for text sentiment classification based on LSTM (Long Short-Term Memory), with the structure shown below:</p>

<p><i>LSTM for Sentiment Classification</i></p>

<p>The model structure is simple, nothing complicated, and implementation is easy using Keras, which has already implemented the algorithms for us.</p>

<p>Now let's talk about two interesting steps.</p>

<p><strong>The first step is the collection of labeled corpora.</strong> Note that our model is supervised (or at least semi-supervised), so we need to collect some already-classified sentences. As for the quantity, the more the better. For Chinese text sentiment classification, this step is not easy, as Chinese materials are often quite scarce. While building the model, I pieced together more than 20,000 labeled Chinese sentences (involving six domains) from various channels (searching and downloading online, purchasing from Datatang, etc.) to train the model. (Shared at the end of the text)</p>

<p><i>Training Corpora</i></p>

<p><strong>The second step is the selection of the model threshold.</strong> In fact, the predicted result of the training is a continuous real number in the $[0, 1]$ interval. By default, the program sets 0.5 as the threshold; that is, results greater than 0.5 are judged as positive, and those less than 0.5 as negative. This default value is not always the best. As shown below, while studying the impact of different thresholds on the True Positive Rate and True Negative Rate, we found an abrupt change in the curve within the interval $(0.391, 0.394)$.</p>

<p><i>Threshold Selection</i></p>

<p>Although looking at the absolute values, it only dropped from 0.99 to 0.97—a small change—the rate of change is very large. Normally, changes are smooth. An abrupt change implies that something unusual must have occurred, and obviously, the reason for this exception is hard for us to discover. In other words, there is an unstable region here, and prediction results within this region are actually unreliable. Therefore, to be safe, we discard this interval. We only consider results greater than 0.394 as positive, and those less than 0.391 as negative. Results between 0.391 and 0.394 are marked as "undetermined." Experiments show that this practice helps improve the model's application accuracy.</p>

<h3>Summary <a name="说点总结" href="https://kexue.fm/archives/3414#%E8%AF%B4%E7%82%B9%E6%80%BB%E7%BB%93">#</a></h3>

<p>This article is long and provides a rough introduction to the ideas and practical applications of deep learning in text sentiment classification. Many things were discussed broadly. I am not intending to write a deep learning tutorial; I only want to point out the key points, at least those I consider critical. There are many good tutorials on deep learning. It's best to read English papers. A relatively good Chinese source is the blog <a href="http://blog.csdn.net/itplus">http://blog.csdn.net/itplus</a>. I won't make a fool of myself in that regard.</p>

<p>Below are my corpora and code. Readers might wonder why I share these "private collections." It's simple: because I don't work in this industry. Data mining is just a hobby for me—a hobby combining math and Python. Therefore, I don't have to worry about anyone getting ahead of me in this area.</p>

<p>Corpus Download: <a href="https://kexue.fm/usr/uploads/2015/08/646864264.zip">sentiment.zip</a></p>

<p>Collected review data: <a href="https://kexue.fm/usr/uploads/2015/09/829078856.zip">sum.zip</a></p>

<p>Code for building LSTM for text sentiment classification:</p>

<pre><code>import pandas as pd # Import Pandas
import numpy as np # Import Numpy
import jieba # Import Jieba segmentation

from keras.preprocessing import sequence
from keras.optimizers import SGD, RMSprop, Adagrad
from keras.utils import np_utils
from keras.models import Sequential
from keras.layers.core import Dense, Dropout, Activation
from keras.layers.embeddings import Embedding
from keras.layers.recurrent import LSTM, GRU

from __future__ import absolute_import # Import 3.x features
from __future__ import print_function

neg=pd.read_excel('neg.xls',header=None,index=None)
pos=pd.read_excel('pos.xls',header=None,index=None) # Finished reading training corpora
pos['mark']=1
neg['mark']=0 # Labelling training corpora
pn=pd.concat([pos,neg],ignore_index=True) # Merge corpora
neglen=len(neg)
poslen=len(pos) # Count corpora size

cw = lambda x: list(jieba.cut(x)) # Define segmentation function
pn['words'] = pn[0].apply(cw)

comment = pd.read_excel('sum.xls') # Read review content
#comment = pd.read_csv('a.csv', encoding='utf-8')
comment = comment[comment['rateContent'].notnull()] # Only read non-empty reviews
comment['words'] = comment['rateContent'].apply(cw) # Review segmentation

d2v_train = pd.concat([pn['words'], comment['words']], ignore_index = True)

w = [] # Integrate all words together
for i in d2v_train:
 w.extend(i)

dict = pd.DataFrame(pd.Series(w).value_counts()) # Count word frequencies
del w,d2v_train
dict['id']=list(range(1,len(dict)+1))

get_sent = lambda x: list(dict['id'][x])
pn['sent'] = pn['words'].apply(get_sent) # Speed is quite slow

maxlen = 50

print("Pad sequences (samples x time)")
pn['sent'] = list(sequence.pad_sequences(pn['sent'], maxlen=maxlen))

x = np.array(list(pn['sent']))[::2] # Training set
y = np.array(list(pn['mark']))[::2]
xt = np.array(list(pn['sent']))[1::2] # Test set
yt = np.array(list(pn['mark']))[1::2]
xa = np.array(list(pn['sent'])) # Full set
ya = np.array(list(pn['mark']))

print('Build model...')
model = Sequential()
model.add(Embedding(len(dict)+1, 256))
model.add(LSTM(128)) # try using a GRU instead, for fun
model.add(Dropout(0.5))
model.add(Dense(1))
model.add(Activation('sigmoid'))

model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

model.fit(x, y, batch_size=16, nb_epoch=10) # Training time takes several hours

classes = model.predict_classes(xt)
acc = np_utils.accuracy(classes, yt)
print('Test accuracy:', acc)
</code></pre>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/3414" style="color: #005fcc;">https://kexue.fm/archives/3414</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
