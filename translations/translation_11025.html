
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    macros: {
      msign: ["\\mathop{\\text{msign}}"],
      mcsgn: ["\\mathop{\\text{mcsgn}}"],
      sign: ["\\mathop{\\text{sign}}"],
      csgn: ["\\mathop{\\text{csgn}}"],
      tr: ["\\mathop{\\text{tr}}"]
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/11025">The Derivative of msign</a></h1>

<p>By 苏剑林 | June 13, 2025</p>

<p>In this article, we will derive the derivative formula for the $\msign$ operator. If you are looking to combine <a href="https://papers.cool/arxiv/2407.04620">TTT</a> (Test-Time Training) with <a href="translation_10592.html">Muon</a>, as seen in <a href="https://papers.cool/arxiv/2505.23884">"Test-Time Training Done Right"</a>, then this article may be helpful to you.</p>

<h2>Two Definitions <a id="两种定义" href="#%E4%B8%A4%E7%A7%8D%E5%AE%9A%E4%B9%89">#</a></h2>

<p>This article assumes that readers already have some understanding of $\msign$. If not, you can first read <a href="translation_10592.html">"Appreciating the Muon Optimizer: The Essential Leap from Vectors to Matrices"</a> and <a href="translation_10922.html">"Newton-Schulz Iteration for the msign Operator (Part 1)"</a>. Let there be a matrix $\boldsymbol{M}\in\mathbb{R}^{n\times m}$, then:</p>

\begin{equation}\boldsymbol{U},\boldsymbol{\Sigma},\boldsymbol{V}^{\top} = \text{SVD}(\boldsymbol{M}) \quad\Rightarrow\quad \msign(\boldsymbol{M}) = \boldsymbol{U}_{[:,:r]}\boldsymbol{V}_{[:,:r]}^{\top}\end{equation}

<p>where $\boldsymbol{U}\in\mathbb{R}^{n\times n}, \boldsymbol{\Sigma}\in\mathbb{R}^{n\times m}, \boldsymbol{V}\in\mathbb{R}^{m\times m}$, and $r$ is the rank of $\boldsymbol{M}$. Simply put, $\msign$ is the new matrix obtained by changing all non-zero singular values of the matrix to 1. Based on SVD, we can also prove:</p>

\begin{equation}\msign(\boldsymbol{M}) = (\boldsymbol{M}\boldsymbol{M}^{\top})^{-1/2}\boldsymbol{M}= \boldsymbol{M}(\boldsymbol{M}^{\top}\boldsymbol{M})^{-1/2}\end{equation}

<p>Here, $^{-1/2}$ represents the inverse of the square root of the matrix. Since $\boldsymbol{M}\boldsymbol{M}^{\top}$ and $\boldsymbol{M}^{\top}\boldsymbol{M}$ are (semi-)positive definite symmetric matrices, the square root can always be found, but the inverse might not exist. When it is not invertible, we can use the "<a href="translation_10366.html">pseudo-inverse</a>". The name $\msign$ comes from the similarity of the above formula to the real-valued sign function $\sign(x) = x/\sqrt{x^2}$. However, as mentioned before, there is <a href="https://en.wikipedia.org/wiki/Matrix_sign_function">another matrix version</a> of the sign function, which we denote here as $\mcsgn$:</p>

\begin{equation}\mcsgn(\boldsymbol{M}) = \boldsymbol{M}(\boldsymbol{M}^2)^{-1/2}\end{equation}

<p>This is the same as $\msign$ but with $\boldsymbol{M}^{\top}\boldsymbol{M}$ replaced by $\boldsymbol{M}^2$. Since only square matrices can have a square, this definition only applies to square matrices. Introducing two similar but different definitions in one article can be confusing, but unfortunately, both definitions are needed in the following calculations, so they must appear simultaneously.</p>

<p>$\mcsgn$ possesses similarity invariance. If $\boldsymbol{M}=\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^{-1}$, then $\mcsgn(\boldsymbol{M})=\boldsymbol{P}\mcsgn(\boldsymbol{\Lambda})\boldsymbol{P}^{-1}$. Furthermore, if $\boldsymbol{\Lambda}$ is a diagonal matrix (which can almost always be achieved in the complex domain), then we have:</p>

\begin{equation}\mcsgn(\boldsymbol{M}) = \boldsymbol{P}\csgn(\boldsymbol{\Lambda})\boldsymbol{P}^{-1}\end{equation}

<p>$\csgn(\boldsymbol{\Lambda})$ indicates that the sign function is applied to each element on the diagonal, where $\csgn(z) = z/\sqrt{z^2}$ is the complex version of the sign function; if the real part of $z$ is non-zero, it equals $\sign(\text{Re}[z])$. Thus, the difference between $\msign$ and $\mcsgn$ is that the former applies the sign function to the singular values based on Singular Value Decomposition, while the latter applies it to the eigenvalues based on Eigenvalue Decomposition. When $\boldsymbol{M}$ is a symmetric matrix, they are equal.</p>

<h2>Unified Computation <a id="同一计算" href="#%E5%90%8C%E4%B8%80%E8%AE%A1%E7%AE%97">#</a></h2>

<p>Currently, the numerical calculation of $\msign$ mainly relies on the following format of "Newton-Schulz iteration":</p>

\begin{equation}\boldsymbol{X}_0 = \frac{\boldsymbol{M}}{\Vert\boldsymbol{M}\Vert_F},\qquad \boldsymbol{X}_{t+1} = a_{t+1}\boldsymbol{X}_t + b_{t+1}\boldsymbol{X}_t(\boldsymbol{X}_t^{\top}\boldsymbol{X}_t) + c_{t+1}\boldsymbol{X}_t(\boldsymbol{X}_t^{\top}\boldsymbol{X}_t)^2\end{equation}

<p>As for the choice of coefficients, we have discussed this in detail in <a href="translation_10922.html">"Newton-Schulz Iteration for the msign Operator (Part 1)"</a> and <a href="translation_10996.html">"Newton-Schulz Iteration for the msign Operator (Part 2)"</a>. A newer result from the second part is:</p>

$$ \begin{array}{c|ccc}
\hline
t & a\times 1.01 & b\times 1.01^3 & c\times 1.01^5 \\
\hline
\quad 1\quad & 8.28721 & -23.5959 & 17.3004 \\
2 & 4.10706 & -2.94785 & 0.544843 \\
3 & 3.94869 & -2.9089 & 0.551819 \\
4 & 3.31842 & -2.48849 & 0.510049 \\
5 & 2.30065 & -1.6689 & 0.418807 \\
6 & 1.8913 & 1.268 & 0.376804 \\
7 & 1.875 & -1.25 & 0.375 \\
8 & 1.875 & -1.25 & 0.375 \\
\hline
\end{array} $$

<p>The advantage of this result is that it can be truncated and superposed arbitrarily. For example, if only the first 5 rows are kept, it is the optimal 5-step iteration; if the first 6 rows are kept, it is the optimal 6-step iteration, and the degree of approximation is guaranteed to be better than the 5-step iteration, and so on.</p>

<p>As for $\mcsgn$, it simply replaces $\boldsymbol{M}^{\top}\boldsymbol{M}$ in $\msign$ with $\boldsymbol{M}^2$. Therefore, in theory, Newton-Schulz iteration can also be used. however, since eigenvalues can be complex, general convergence is much more difficult. Nevertheless, if we can confirm that the eigenvalues of the matrix $\boldsymbol{M}$ are all real (such as the block triangular matrix to which we will apply $\mcsgn$ later in this article), then we can reuse the $\msign$ iteration and coefficients:</p>

\begin{equation}\boldsymbol{X}_0 = \frac{\boldsymbol{M}}{\sqrt{\tr(\boldsymbol{M}^2)}},\qquad \boldsymbol{X}_{t+1} = a_{t+1}\boldsymbol{X}_t + b_{t+1}\boldsymbol{X}_t^3 + c_{t+1}\boldsymbol{X}_t^5\end{equation}

<h2>Derivation Process <a id="推导过程" href="#%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B">#</a></h2>

<p>Now we formally enter the main topic — calculating the derivative of $\boldsymbol{O}=\msign(\boldsymbol{M})$. If you are just using Muon as a regular optimizer, this article probably has nothing to do with you. When we need to refer to TTT and use the Muon optimizer to build an RNN model, we need the derivative of $\msign$. In this case, $\msign$ acts as part of the forward propagation in the model, and to backpropagate through the entire model, the derivative of $\msign$ is naturally involved.</p>

<p>Since $\msign$ is calculated through Newton-Schulz iteration, it can actually be backpropagated directly. Therefore, numerical differentiation of $\msign$ itself is not a problem. However, backpropagating through iterations means many intermediate states must be stored, which often leads to memory explosion. Thus, we hope to obtain an analytical solution for the derivative to simplify things. On the other hand, in <a href="translation_10878.html">"Derivative of SVD"</a>, we actually derived the derivative of $\msign$, but that was based on the SVD expression, and SVD is not a GPU-efficient algorithm.</p>

<p>Therefore, our goal is to seek a result that does not rely on SVD and can be computed efficiently. We start from the identity:</p>

\begin{equation}\boldsymbol{M} = \boldsymbol{O}\boldsymbol{M}^{\top}\boldsymbol{O}\end{equation}

<p>(which can be proven by the definition of $\msign$). Differentiating both sides gives:</p>

\begin{equation}d\boldsymbol{M} = (d\boldsymbol{O})\boldsymbol{M}^{\top}\boldsymbol{O} + \boldsymbol{O}(d\boldsymbol{M}^{\top})\boldsymbol{O} + \boldsymbol{O}\boldsymbol{M}^{\top}(d\boldsymbol{O})\label{eq:dm-do}\end{equation}

<p>The difficulty with this result is that it is not easy to isolate $d\boldsymbol{M}=f(d\boldsymbol{O})$ or $d\boldsymbol{O}=f(d\boldsymbol{M})$, making it hard to see the relationship between $\nabla_{\boldsymbol{O}}\mathcal{L}$ and $\nabla_{\boldsymbol{M}}\mathcal{L}$ ($\mathcal{L}$ being the loss function). In this case, the best way is to return to the fundamental approach of matrix differentiation — the "trace trick":</p>

<blockquote>
    <strong>Trace trick:</strong> If we can find a matrix $\boldsymbol{G}$ of the same shape as $\boldsymbol{M}$ that satisfies
    \begin{equation}d\mathcal{L}=\langle \boldsymbol{G}, d\boldsymbol{M}\rangle_F = \tr(\boldsymbol{G}^{\top} (d\boldsymbol{M}))\end{equation}
    then $\boldsymbol{G} = \nabla_{\boldsymbol{M}}\mathcal{L}$.
</blockquote>

<p>The essence of the trace trick is to convert matrices/vectors into scalars, and then convert scalars into traces, which then allows the use of trace identities:</p>

\begin{equation}\tr(\boldsymbol{A}\boldsymbol{B}) = \tr(\boldsymbol{B}\boldsymbol{A}) = \tr(\boldsymbol{A}^{\top}\boldsymbol{B}^{\top}) = \tr(\boldsymbol{B}^{\top}\boldsymbol{A}^{\top})\end{equation}

<p>Now let $\boldsymbol{X}$ be any matrix of the same shape as $\boldsymbol{M}$. Multiply both sides of equation $\eqref{eq:dm-do}$ by $\boldsymbol{X}^{\top}$ and then take the trace:</p>

\begin{equation}\begin{aligned}
\tr(\boldsymbol{X}^{\top}(d\boldsymbol{M})) =&\, \tr(\boldsymbol{X}^{\top}(d\boldsymbol{O})\boldsymbol{M}^{\top}\boldsymbol{O}) + \tr(\boldsymbol{X}^{\top}\boldsymbol{O}(d\boldsymbol{M}^{\top})\boldsymbol{O}) + \tr(\boldsymbol{X}^{\top}\boldsymbol{O}\boldsymbol{M}^{\top}(d\boldsymbol{O})) \\[7pt]
=&\, \tr(\boldsymbol{M}^{\top}\boldsymbol{O}\boldsymbol{X}^{\top}(d\boldsymbol{O})) + \tr(\boldsymbol{O}\boldsymbol{X}^{\top}\boldsymbol{O}(d\boldsymbol{M}^{\top})) + \tr(\boldsymbol{X}^{\top}\boldsymbol{O}\boldsymbol{M}^{\top}(d\boldsymbol{O})) \\[7pt]
=&\, \tr(\boldsymbol{M}^{\top}\boldsymbol{O}\boldsymbol{X}^{\top}(d\boldsymbol{O})) + \tr(\boldsymbol{O}^{\top}\boldsymbol{X}\boldsymbol{O}^{\top}(d\boldsymbol{M})) + \tr(\boldsymbol{X}^{\top}\boldsymbol{O}\boldsymbol{M}^{\top}(d\boldsymbol{O})) \\[7pt]
\end{aligned}\end{equation}

<p>From this, we obtain:</p>

\begin{equation}\tr((\boldsymbol{X}^{\top} - \boldsymbol{O}^{\top}\boldsymbol{X}\boldsymbol{O}^{\top})(d\boldsymbol{M})) = \tr((\boldsymbol{M}^{\top}\boldsymbol{O}\boldsymbol{X}^{\top} + \boldsymbol{X}^{\top}\boldsymbol{O}\boldsymbol{M}^{\top})(d\boldsymbol{O}))\end{equation}

<p>If we let $\boldsymbol{M}^{\top}\boldsymbol{O}\boldsymbol{X}^{\top} + \boldsymbol{X}^{\top}\boldsymbol{O}\boldsymbol{M}^{\top}=(\nabla_{\boldsymbol{O}}\mathcal{L})^{\top}$, then the above equation has the meaning of $d\mathcal{L}$, and according to the trace trick, we have $\boldsymbol{X}^{\top} - \boldsymbol{O}^{\top}\boldsymbol{X}\boldsymbol{O}^{\top}=(\nabla_{\boldsymbol{M}}\mathcal{L})^{\top}$. This indicates that the relationship between $\nabla_{\boldsymbol{M}}\mathcal{L}$ and $\nabla_{\boldsymbol{O}}\mathcal{L}$ is described by the following system of equations:</p>

\begin{gather}\boldsymbol{X} - \boldsymbol{O}\boldsymbol{X}^{\top}\boldsymbol{O} = \nabla_{\boldsymbol{M}}\mathcal{L} \label{eq:g-m}\\[7pt]
\boldsymbol{X}\boldsymbol{O}^{\top}\boldsymbol{M} + \boldsymbol{M}\boldsymbol{O}^{\top}\boldsymbol{X} = \nabla_{\boldsymbol{O}}\mathcal{L}\label{eq:g-o}\end{gather}

<h2>Theoretical Form <a id="理论形式" href="#%E7%90%86%E8%AE%BA%E5%BD%A2%E5%BC%8F">#</a></h2>

<p>So, the problem now becomes solving for $\boldsymbol{X}$ from equation $\eqref{eq:g-o}$, and then substituting it into equation $\eqref{eq:g-m}$ to obtain $\nabla_{\boldsymbol{M}}\mathcal{L}$, which expresses $\nabla_{\boldsymbol{M}}\mathcal{L}$ as a function of $\nabla_{\boldsymbol{O}}\mathcal{L}$, avoiding the direct calculation of $\nabla_{\boldsymbol{M}}\boldsymbol{O}$. Obviously, the only difficulty is solving equation $\eqref{eq:g-o}$.</p>

<p>In this section, we first seek a theoretical solution based on SVD, which is not very practical but helps us understand the properties of equation $\eqref{eq:g-o}$ and aligns with previous results. Let $\boldsymbol{X}=\boldsymbol{U}\boldsymbol{Y}\boldsymbol{V}^{\top}$, and we also have $\boldsymbol{O}^{\top}\boldsymbol{M} = (\boldsymbol{M}^{\top}\boldsymbol{M})^{1/2} = \boldsymbol{V}(\boldsymbol{\Sigma}^{\top}\boldsymbol{\Sigma})^{1/2}\boldsymbol{V}^{\top}$ and $\boldsymbol{M}\boldsymbol{O}^{\top}=(\boldsymbol{M}\boldsymbol{M}^{\top})^{1/2} = \boldsymbol{U}(\boldsymbol{\Sigma}\boldsymbol{\Sigma}^{\top})^{1/2}\boldsymbol{U}^{\top}$. Substituting these identities into equation $\eqref{eq:g-o}$ gives:</p>

\begin{equation}\boldsymbol{U}\boldsymbol{Y}(\boldsymbol{\Sigma}^{\top}\boldsymbol{\Sigma})^{1/2}\boldsymbol{V}^{\top} + \boldsymbol{U}(\boldsymbol{\Sigma}\boldsymbol{\Sigma}^{\top})^{1/2}\boldsymbol{Y}\boldsymbol{V}^{\top} = \nabla_{\boldsymbol{O}}\mathcal{L}\end{equation}

<p>which is:</p>

\begin{equation}\boldsymbol{Y}(\boldsymbol{\Sigma}^{\top}\boldsymbol{\Sigma})^{1/2} + (\boldsymbol{\Sigma}\boldsymbol{\Sigma}^{\top})^{1/2}\boldsymbol{Y} = \boldsymbol{U}^{\top}(\nabla_{\boldsymbol{O}}\mathcal{L})\boldsymbol{V}\label{eq:g-o-2}\end{equation}

<p>If written in component form, the left side is $\boldsymbol{Y}_{i,j}\sigma_j + \sigma_i \boldsymbol{Y}_{i,j} = (\sigma_i + \sigma_j)\boldsymbol{Y}_{i,j}$, where $\sigma_1, \sigma_2, \dots, \sigma_r$ are the non-zero singular values of $\boldsymbol{M}$, and $0 = \sigma_{r+1} = \sigma_{r+2} = \dots$. Clearly, if $\boldsymbol{M}$ is a full-rank square matrix, we can solve for:</p>

\begin{equation}\boldsymbol{Y} = (\boldsymbol{U}^{\top}(\nabla_{\boldsymbol{O}}\mathcal{L})\boldsymbol{V}) \oslash \boldsymbol{S}\end{equation}

<p>where $\boldsymbol{S}_{i,j} = \sigma_i + \sigma_j$, and $\oslash$ is the Hadamard division (element-wise division). If we then substitute $\boldsymbol{X}=\boldsymbol{U}\boldsymbol{Y}\boldsymbol{V}^{\top}$ into equation $\eqref{eq:g-m}$, we get a result consistent with that in <a href="translation_10878.html">"Derivative of SVD"</a>. This convergence from different paths also strengthens our confidence that our derivation so far is correct.</p>

<p>What if $\boldsymbol{M}$ is not full-rank or not square? In this case, if the $\boldsymbol{U}^{\top}(\nabla_{\boldsymbol{O}}\mathcal{L})\boldsymbol{V}$ on the right side doesn't "cooperate," equation $\eqref{eq:g-o-2}$ will have no solution. However, since equation $\eqref{eq:g-o-2}$ is derived from a physical problem, it must have a solution, meaning the right side "must cooperate"! What does cooperation mean? If the rank of $\boldsymbol{M}$ is $r$, then the matrix $\boldsymbol{S}$ is non-zero only within $\boldsymbol{S}_{[:r,:r]}$. For equation $\eqref{eq:g-o-2}$ to have a solution, the parts beyond $(\boldsymbol{U}^{\top}(\nabla_{\boldsymbol{O}}\mathcal{L})\boldsymbol{V})_{[:r,:r]}$ must be zero. Under this condition, we can write:</p>

\begin{equation}\boldsymbol{Y} = \lim_{\epsilon\to 0}\,\, (\boldsymbol{U}^{\top}(\nabla_{\boldsymbol{O}}\mathcal{L})\boldsymbol{V}) \oslash (\boldsymbol{S} + \epsilon) \end{equation}

<p>This is equivalent to saying that we can add some perturbation to the singular values, converting it to a case where all singular values are non-zero, and then let the perturbation approach zero after the calculation is complete to obtain the correct result.</p>

<h2>Efficient Solution <a id="高效求解" href="#%E9%AB%98%E6%95%88%E6%B1%82%E8%A7%A3">#</a></h2>

<p>The SVD solution in the previous section often only has theoretical value. To compute efficiently on a GPU, we still need to seek other forms of solutions. Introducing the notation $\boldsymbol{M}\boldsymbol{O}^{\top}=\boldsymbol{A}, \boldsymbol{O}^{\top}\boldsymbol{M}=\boldsymbol{B}, \nabla_{\boldsymbol{O}}\mathcal{L}=\boldsymbol{C}$, equation $\eqref{eq:g-o}$ is actually a <a href="https://en.wikipedia.org/wiki/Sylvester_equation">Sylvester equation</a>:</p>

\begin{equation}\boldsymbol{A}\boldsymbol{X}+\boldsymbol{X}\boldsymbol{B} = \boldsymbol{C}\end{equation}

<p>There are many methods to solve the Sylvester equation. Among them, the most elegant and GPU-efficient might be the solution scheme based on $\mcsgn$ (not $\msign$) (referenced here from <a href="https://papers.cool/arxiv/2201.08663">"Fast Differentiable Matrix Square Root"</a>). First, starting from the above equation, we can verify that the following equation holds:</p>

\begin{equation}\begin{bmatrix} \boldsymbol{A} & -\boldsymbol{C} \\ \boldsymbol{0} & -\boldsymbol{B}\end{bmatrix} = \begin{bmatrix} \boldsymbol{I} & \boldsymbol{X} \\ \boldsymbol{0} & \boldsymbol{I}\end{bmatrix}\begin{bmatrix} \boldsymbol{A} & \boldsymbol{0} \\ \boldsymbol{0} & -\boldsymbol{B}\end{bmatrix}\begin{bmatrix} \boldsymbol{I} & \boldsymbol{X} \\ \boldsymbol{0} & \boldsymbol{I}\end{bmatrix}^{-1}
\end{equation}

<p>Taking $\mcsgn$ on both sides, according to the properties of $\mcsgn$, we have:</p>

\begin{equation}\mcsgn\left(\begin{bmatrix} \boldsymbol{A} & -\boldsymbol{C} \\ \boldsymbol{0} & -\boldsymbol{B}\end{bmatrix}\right) = \begin{bmatrix} \boldsymbol{I} & \boldsymbol{X} \\ \boldsymbol{0} & \boldsymbol{I}\end{bmatrix}\begin{bmatrix} \mcsgn(\boldsymbol{A}) & \boldsymbol{0} \\ \boldsymbol{0} & -\mcsgn(\boldsymbol{B})\end{bmatrix}\begin{bmatrix} \boldsymbol{I} & \boldsymbol{X} \\ \boldsymbol{0} & \boldsymbol{I}\end{bmatrix}^{-1}
\end{equation}

<p>Note that $\boldsymbol{A}=\boldsymbol{M}\boldsymbol{O}^{\top}=(\boldsymbol{M}\boldsymbol{M}^{\top})^{1/2}$ and $\boldsymbol{B}=\boldsymbol{O}^{\top}\boldsymbol{M}=(\boldsymbol{M}^{\top}\boldsymbol{M})^{1/2}$. Assuming $\boldsymbol{M}$ is a full-rank square matrix, then $\boldsymbol{A}$ and $\boldsymbol{B}$ are both positive definite symmetric matrices. The $\mcsgn$ of a positive definite symmetric matrix is the identity matrix $\boldsymbol{I}$, so:</p>

\begin{equation}\mcsgn\left(\begin{bmatrix} \boldsymbol{A} & -\boldsymbol{C} \\ \boldsymbol{0} & -\boldsymbol{B}\end{bmatrix}\right) = \begin{bmatrix} \boldsymbol{I} & \boldsymbol{X} \\ \boldsymbol{0} & \boldsymbol{I}\end{bmatrix}\begin{bmatrix} \boldsymbol{I} & \boldsymbol{0} \\ \boldsymbol{0} & -\boldsymbol{I}\end{bmatrix}\begin{bmatrix} \boldsymbol{I} & \boldsymbol{X} \\ \boldsymbol{0} & \boldsymbol{I}\end{bmatrix}^{-1} = \begin{bmatrix} \boldsymbol{I} & -2\boldsymbol{X} \\ \boldsymbol{0} & -\boldsymbol{I}\end{bmatrix}
\end{equation}

<p>The final simplification uses the equality $\begin{bmatrix} \boldsymbol{I} & \boldsymbol{X} \\ \boldsymbol{0} & \boldsymbol{I}\end{bmatrix}^{-1}=\begin{bmatrix} \boldsymbol{I} & -\boldsymbol{X} \\ \boldsymbol{0} & \boldsymbol{I}\end{bmatrix}$. From this result, it can be seen that we only need to calculate $\mcsgn$ for the block matrix $\begin{bmatrix} \boldsymbol{A} & -\boldsymbol{C} \\ \boldsymbol{0} & -\boldsymbol{B}\end{bmatrix}$, and then we can read $\boldsymbol{X}$ from the upper-right corner of the result. $\mcsgn$ can be efficiently calculated through Newton-Schulz iteration, so this scheme is GPU-friendly.</p>

<p>When $\boldsymbol{M}$ is not full-rank or not square, $\boldsymbol{A}$ and $\boldsymbol{B}$ are only semi-positive definite, so their $\mcsgn$ is not $\boldsymbol{I}$. However, our experience from the previous section tells us that since $\nabla_{\boldsymbol{O}}\mathcal{L}$ "must cooperate," we only need to add some perturbation to $\boldsymbol{\Sigma}$ to make it positive definite. Adding perturbation here is equivalent to adding $\epsilon \boldsymbol{I}$ to $\boldsymbol{A}$ and $\boldsymbol{B}$, so:</p>

\begin{equation}\boldsymbol{X} = -\frac{1}{2} \left(\lim_{\epsilon \to 0}\,\, \mcsgn\left(\begin{bmatrix} \boldsymbol{A} + \epsilon \boldsymbol{I} & -\boldsymbol{C} \\ \boldsymbol{0} & -\boldsymbol{B} - \epsilon \boldsymbol{I}\end{bmatrix}\right)\right)_{[:n,n:]}
\end{equation}

<p>In actual calculation, we can only choose a relatively small $\epsilon > 0$ for approximate calculation. $\epsilon=10^{-3}$ can be considered, as it is within the range of the lower bound for the Newton-Schulz iteration we found previously.</p>

<h2>Article Summary <a id="文章小结" href="#%E6%96%87%E7%AB%A0%E5%B0%8F%E7%BB%93">#</a></h2>

<p>This article has discussed the calculation of the derivative of the $\msign$ operator. If you are interested in the "TTT + Muon" combination, then this article may be helpful to you.</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/11025" style="color: #005fcc;">https://kexue.fm/archives/11025</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
