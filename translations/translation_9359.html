
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    tags: 'ams',
    packages: {'[+]': ['ams']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/9359">Using the Heat Equation to Guide Self-Supervised Learning</a></h1>

    <p>By 苏剑林 | November 30, 2022</p>


<p>Leveraging theoretical physics to push machine learning is no longer a new phenomenon. For example, the article introduced last month, <a href="translation_9206.html">"General Discourse on Generative Diffusion Models (13): From Universal Gravitation to Diffusion Models,"</a> is a classic case. Recently, a new paper titled <a href="https://arxiv.org/abs/2211.12780">"Self-Supervised Learning based on Heat Equation"</a> has piqued my interest. As the name suggests, it uses the heat conduction equation for self-supervised learning in the field of computer vision. How do these physical equations play a role in machine learning? Can the same ideas be transferred to NLP? Let's read the paper together.</p>

<h2>Basic Equations #</h2>

<p>As shown in the figure below, on the left is the solution to the heat conduction equation in physics, and on the right is the attribution heatmap obtained through saliency methods such as CAM and Integrated Gradients. It can be seen that there is a certain similarity between the two. Consequently, the authors believe that the heat conduction equation can serve as a good prior for visual features.</p>

<p><em>Heatmap of the heat equation (left) and heatmap of a vision model (right)</em></p>

<p>Specifically, the physical heat conduction equation is:</p>

\begin{equation}\frac{\partial u}{\partial t} = \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\end{equation}

<p>where $x, y$ correspond to the "width" and "height" dimensions of the image, and $u$ corresponds to the feature value at that location. Since this paper mainly deals with static images rather than videos, there is no time dimension $t$. For this, we can simply let $\frac{\partial u}{\partial t}=0$. Since features are usually multi-dimensional vectors rather than scalars, we replace $u$ with $\boldsymbol{z}$, obtaining:</p>

\begin{equation}\frac{\partial^2 \boldsymbol{z}}{\partial x^2} + \frac{\partial^2 \boldsymbol{z}}{\partial y^2} = 0\label{eq:laplace}\end{equation}

<p>This is known as the "Laplace Equation." It is isotropic, but images are not always isotropic. Therefore, we can supplement it with an $\boldsymbol{S}$ matrix to capture this anisotropy:</p>

\begin{equation}\frac{\partial^2 \boldsymbol{z}}{\partial x^2} + \boldsymbol{S}\frac{\partial^2 \boldsymbol{z}}{\partial y^2} = 0\label{eq:laplace-s}\end{equation}

<p>However, this is a second-order equation, and as we will see later, it would be troublesome to discretize. Thus, the authors propose further transforming it into a system of first-order equations:</p>

\begin{equation}\frac{\partial \boldsymbol{z}}{\partial x} = \boldsymbol{A}\boldsymbol{z},\quad \frac{\partial \boldsymbol{z}}{\partial y} = \boldsymbol{B}\boldsymbol{z}\label{eq:laplace-1o}\end{equation}

<p>It can be verified that as long as $\boldsymbol{S} = -\boldsymbol{A}^2(\boldsymbol{B}^2)^{-1}$, the solution to the above equation must also be a solution to equation $\eqref{eq:laplace-s}$. Therefore, the original paper takes equation $\eqref{eq:laplace-1o}$ as its starting point.</p>

<h2>Discrete Reconstruction #</h2>

<p>Despite all the setup, the core idea of the original paper is quite simple: it assumes that the features obtained from the original image after passing through an encoder should satisfy equation $\eqref{eq:laplace-1o}$ as much as possible. Specifically, after the image passes through the encoder and before global pooling, we obtain a feature map of size $w \times h \times d$. We view this as $m \times n$ vectors of $d$-dimensions, or a function $\boldsymbol{z}(x, y) \in \mathbb{R}^d$, where $(x, y)$ is the position of the vector. Then the function $\boldsymbol{z}(x, y)$ should satisfy equation $\eqref{eq:laplace-1o}$ as much as possible.</p>

<p>How do we facilitate this? According to equation $\eqref{eq:laplace}$, we can derive the discretization format:</p>

\begin{equation}\begin{aligned} 
&\,\boldsymbol{z}(x+\Delta x, y) \approx \boldsymbol{z}(x, y) + \Delta x \boldsymbol{A}\boldsymbol{z}(x,y) = (\boldsymbol{I} + \Delta x \boldsymbol{A})\boldsymbol{z}(x,y) \\ 
&\,\boldsymbol{z}(x, y+\Delta y) \approx \boldsymbol{z}(x, y) + \Delta y \boldsymbol{B}\boldsymbol{z}(x,y) = (\boldsymbol{I} + \Delta y \boldsymbol{B})\boldsymbol{z}(x,y) 
\end{aligned}\label{eq:laplace-delta}\end{equation}

<p>This means we can predict the features of adjacent positions through the features of the current position. Thus, the original paper proposes a self-supervised learning method named "QB-Heat": only a small portion of the image is input at a time, corresponding features are obtained via the encoder, features for the complete image are predicted through discretized equation $\eqref{eq:laplace-delta}$, and then the features are passed to a small decoder to reconstruct the complete image.</p>

<p>The schematic diagram is as follows:</p>

<p><em>Schematic of the QB-Heat framework</em></p>

<h2>Comparative Analysis #</h2>

<p>That concludes the introduction to QB-Heat. The remainder of the original paper consists of experimental results and some (in my opinion) largely irrelevant analysis, which I will skip here. Interested readers can refer directly to the original paper.</p>

<p>If readers have read about the MAE model (refer to <a href="translation_9039.html">"MLM and MAE from the Perspective of Dropout: Some New Insights"</a>), they should feel that QB-Heat bears many similarities to MAE—both input partial images into an encoder and then reconstruct the full image, and both use a large encoder and a small decoder. Besides the masking method, the biggest difference lies in the input to the decoder: QB-Heat predicts features for the remaining parts of the image by approximating $\eqref{eq:laplace-delta}$, whereas MAE simply treats the remaining features as the same [MASK]. It is conceivable that approximating through $\eqref{eq:laplace-delta}$ is naturally more reasonable than crudely filling with [MASK], so it is within reason that QB-Heat performs better than MAE.</p>

<p><em>Schematic of the MAE model</em></p>

<p>Equation $\eqref{eq:laplace-delta}$ dictates that QB-Heat can only predict the surroundings from the center (otherwise handling interpolation in the middle is more troublesome). Therefore, the masking method for QB-Heat is limited to retaining a continuous square area and masking the surrounding area, as shown in the figure below. Precisely because the input for QB-Heat is a continuous sub-image of the original image, its encoder can be built using either a Transformer or a pure CNN model. In contrast, MAE randomly masks some pixels of the original image. Consequently, to achieve the effect of reducing encoder computation, MAE's encoder can only use a Transformer model, because only the Transformer model can reduce sequence length while retaining positional information.</p>

<p><em>Schematic of the Masking method in QB-Heat</em></p>

<h2>Personal Reflections #</h2>

<p>The physics perspective looks beautiful, but often it serves as a "guise" (in a non-derogatory sense). It is more important for us to see through the phenomenon to the essence and consider the actual mechanism that makes it work.</p>

<p>First, an obvious "point of critique" for QB-Heat is that while the title and the method are crowned with the name of the heat conduction equation, the heat equation's actual appearance time "doesn't exceed 3 seconds," giving it a feeling of being optional. In fact, the starting point of the paper should be equation $\eqref{eq:laplace}$, which is the Laplace equation. Although the Laplace equation is mathematically equivalent to the steady-state solution of the heat conduction equation, they belong to two different branches in both mathematical and physical classification and research. Therefore, the name "heat conduction equation" is a bit forced. Secondly, it wasn't the original formula $\eqref{eq:laplace}$ or $\eqref{eq:laplace-s}$ that was used, but rather the simplified formula $\eqref{eq:laplace-1o}$, and during application, it corresponded to the approximation formula $\eqref{eq:laplace-delta}$. Leaving the physical background aside and looking directly at equation $\eqref{eq:laplace-delta}$, it states the following hypothesis: <strong>adjacent feature vectors should be as similar as possible, and the difference between them should ideally be the same linear transformation.</strong></p>

<p>Simply put, it applies explicit prediction to feature vectors through assumptions of continuity and linearity, thereby playing an implicit role of regularization. This reminds me of <a href="translation_5693.html">mixup</a>, introduced in "From SamplePairing to mixup: Miraculous Regularization Terms," which also adds implicit linear regularization to the model by explicitly constructing data, thereby enhancing the final generalization ability of the model.</p>

<p>For me, whenever I see a method in CV, I usually wonder if it can be transferred to NLP. Is it possible for QB-Heat to make this migration? Compared to MAE, the biggest change QB-Heat makes is that the features of the remaining part of the original image should be predicted through certain hypotheses rather than uniformly replaced by [MASK]. QB-Heat uses continuity and linearity assumptions for CV; can this be replicated for NLP? Language is essentially a time series with only one dimension of change. This is equivalent to asking: can we assume that the sentence vectors of adjacent sentences differ by the same linear transformation? It seems that natural language shouldn't possess such good continuity, but if understood purely from the perspective of linear regularization, it doesn't seem unfeasible, especially since mixup works well in many NLP tasks.</p>

<p>Additionally, if we randomly mask a part of the tokens instead of retaining only one continuous sub-interval like QB-Heat, it seems we could also directly use linear interpolation of feature vectors from both sides to predict the features of the middle positions. In this way, it would also satisfy the continuity and linearity assumptions. I wonder if this treatment would yield better results? These are relatively shallow thoughts that await experimental verification.</p>

<h2>Summary #</h2>

<p>This article introduced QB-Heat, a scheme that uses the heat conduction equation to guide self-supervised learning. Its difference from MAE lies in using simple prediction instead of [MASK] as the features for the remaining parts of the image passed to the decoder.</p>

<hr />
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/9359" style="color: #005fcc;">https://kexue.fm/archives/9359</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
