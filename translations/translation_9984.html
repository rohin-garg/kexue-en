
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    tags: 'ams',
    processEscapes: true,
    packages: {'[+]': ['ams']}
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
    <h1><a href="https://kexue.fm/archives/9984">Reflections on "Building Behind Closed Doors": Shallow Thoughts on Multimodal Approaches (1): Lossless Input</a></h1>

    <p>By 苏剑林 | February 21, 2024</p>

    <p>In this article, I want to share some of my "behind closed doors" thoughts—or rather, some conjectures—regarding multimodal model architectures. The recent releases of Google's Gemini 1.5 and OpenAI's Sora have once again ignited many people's passion for multimodality. The sparse technical reports have also led to intense speculation about the architectures behind them. However, this article is not being published just to join the hype; in fact, some of these ideas have been brewing for a long time and have only recently been organized into a coherent form. It just so happens that their release coincided with these thoughts. </p>

    <p>A disclaimer beforehand: the term "building behind closed doors" is not false modesty. My experience with large models is "unremarkable," and my practice in multimodality is almost a "total blank." This article is indeed just a "subjective conjecture" based on previous experiences in text and image generation.</p>

    <h2>Problem Background</h2>
    <p>First, let's simplify the problem. The "multimodality" discussed in this article primarily refers to dual-modality mixing of text and images—that is, both input and output can be text and images. Many readers might initially feel that multimodal models are just about burning money on GPUs, using Transformer for everything, and moving towards "great power producing miracles" (scaling laws). </p>

    <p>Actually, it's not that simple. Looking at text generation, there has essentially been only one mainstream path from the beginning: the Language Model, which models the conditional probability $p(x_t|x_1,\cdots,x_{t-1})$. Whether it was the early n-gram models, or later Seq2Seq and GPT, all are approximations of this conditional probability. In other words, people have always been clear about "which direction to go" to achieve text generation; the only differences were the models used, such as LSTM, CNN, Attention, or the recently revived Linear RNNs. Thus, text generation can indeed "All in Transformer" to achieve miracles because the direction is standard and clear.</p>

    <p>However, for image generation, there is no such "standard direction." Among the image generation models discussed on this site, we have <a href="translation_5343.html">VAE</a>, <a href="translation_6068.html">GAN</a>, <a href="translation_6482.html">Flow</a>, <a href="translation_9164.html">Diffusion</a>, and niche ones like <a href="translation_7815.html">EBM</a>, PixelRNN/PixelCNN, etc. The distinctions between these methods are not because they use RNN, CNN, or Attention leading to different effects, but because their underlying modeling theories are fundamentally different. The root cause of this diversity in image generation methods is the difficulty of probability modeling for continuous variables.</p>

    <p>For a sentence $(x_1,x_2,\cdots,x_l)$ of length $l$, each $x_t$ comes from a finite vocabulary. Therefore, $p(x_t|x_1,\cdots,x_{t-1})$ is essentially a classification task. Given the combination of "the universal approximation capability of neural networks + Softmax," any classification task can theoretically be modeled precisely. This is the theoretical guarantee behind text generation. However, we usually treat images as continuous vectors, where $x_t$ is a real number. Even if we perform the same conditional decomposition, how do we model $p(x_t|x_1,\cdots,x_{t-1})$? Note that at this point, $p(x_t|x_1,\cdots,x_{t-1})$ is a probability density, and a necessary condition for a probability density is that it is non-negative and integrates to 1:</p>

    \begin{equation}\int p(x_t|x_1,\cdots,x_{t-1}) dx_t = 1\end{equation}

    <p>Aside from the normal distribution, how many functions can we write whose integral is always 1? And the functions we can write, like the normal distribution, are not sufficient to fit arbitrarily complex distributions. To put it bluntly: neural networks are universal function approximators, but they are not universal probability density approximators. This is the inherent difficulty of generative modeling for continuous variables. Various image generation schemes are essentially different ways to "show their special prowess" to bypass direct modeling of the probability density (except for Flow). Discrete variables do not have this difficulty because the constraint for discrete probability is that the sum is 1, which can be easily achieved through Softmax.</p>

    <h2>The Path of Discreteness</h2>
    <p>Some readers might wonder: can we discretize images and then apply the text generation framework? Yes, this is one of the mainstream ideas (perhaps the only one).</p>

    <p>In fact, images are naturally discrete. An RGB image of size $n\times n$ is essentially $3n^2$ integers ranging from 0 to 255. That is, it's equivalent to a sentence with a length of $3n^2$ and a vocab_size of 256. Broadly speaking, computers are inherently discrete; everything they represent—text, images, audio, video—is discrete. So, directly using their original discrete representations in a text generation framework is theoretically sound. Early works like <a href="https://arxiv.org/abs/1601.06759">PixelRNN</a> and <a href="https://arxiv.org/abs/1606.05328">PixelCNN</a> performed autoregressive generation directly in the pixel space. One of the main experiments of OpenAI's <a href="translation_6913.html">Sparse Transformer</a>, which we introduced in "Born for Thrift: From Standard Attention to Sparse Attention," was also pixel-level image autoregression.</p>

    <p>However, the biggest problem with operating directly in pixel space is the sequence length—it's too long, and generation is too slow. In most application scenarios, image resolution needs to be at least 256 to be practical (unless it's just for generating small emoticons). Even if $n=256$, there are $3n^2 \approx 200,000$ elements. To generate one 256-sized image, we would need 200,000 autoregressive decoding steps! Although Long Context technology has made great strides recently, this cost is still very extravagant, and the generation time is hard to accept.</p>

    <p>To this end, an obvious idea is "compress first, generate later"—that is, use another model to compress the sequence length, generate in the compressed space, and then restore the image through a model. Compression naturally relies on an AE (AutoEncoder). But since we want to apply the modeling method of text generation, we must ensure discreteness after compression. This requires <a href="translation_6760.html">VQ-VAE</a> and later <a href="https://arxiv.org/abs/2012.09841">VQ-GAN</a>, where VQ can also be replaced by the recent <a href="https://arxiv.org/abs/2309.15505">FSQ</a>. Similar to a text Tokenizer, VQ-VAE/GAN acts as an "Image Tokenizer." It maintains the discreteness of the encoding result but significantly reduces the sequence length (e.g., if resolution is reduced to $1/4$, then $3n^2 \to (n/4)^2$, a 48-fold reduction), and can restore the original image through a corresponding Decoder (DeTokenize). Many multimodal works based on the "Image Tokenizer" idea exist, such as the recent <a href="https://arxiv.org/abs/2402.08268">LWM</a> and <a href="https://arxiv.org/abs/2402.12251">AnyGPT</a>.</p>

    <p>Whether in the original pixel space or the compressed encoding space, they share a common trait: they are 2D features. Unlike text, which has only one left-right dimension, images have both left-right and up-down dimensions. During autoregressive generation, a generation order must be manually designed—such as left-to-right then top-to-bottom, top-to-bottom then left-to-right, counter-clockwise from the center, or sorted by distance from the top-left corner. Different generation directions can significantly impact results, introducing extra hyperparameters and making it feel less "end-to-end" and elegant. To address this, we can use Cross Attention to combine 2D features and output a single-dimensional encoding result. Related work can be found in <a href="translation_9738.html">"Planting a SEED of Vision in Large Language Model"</a>.</p>

    <h2>Compression Loss</h2>
    <p>It seems that through "Image Tokenizers," multimodal generation has been "solved"? Not quite; the problems are just beginning.</p>

    <p>The biggest problem with Image Tokenizers like VQ-VAE and VQ-GAN is that to significantly improve generation speed and shorten sequence length, the encoding resolution is highly compressed (the mainstream is $256\times 256 \to 32\times 32$ or even $256\times 256 \to 16\times 16$). This leads to severe loss of image information. To perceive this intuitively, we can refer to the reconstruction effect in the SEED paper:</p>

    <div style="text-align: center;">
        <img src="https://kexue.fm/usr/uploads/2024/02/1944896939.png" alt="SEED Reconstruction Effect" style="max-width: 100%;">
        <p><em>Reconstruction effect of SEED</em></p>
    </div>

    <p>As can be seen, although the reconstructed images are clear and maintain the overall semantics of the input image, the local details are completely different. This means it is impossible to complete arbitrary mixed text-image tasks (such as OCR) based on this Image Tokenizer.</p>

    <p>Furthermore, we can perform a simple "information audit" to see how serious the information loss is. First, referring to the experimental results in <a href="https://arxiv.org/abs/1904.10509">"Generating Long Sequences with Sparse Transformers"</a>, the average entropy of ImageNet-64 is 3.44 bits/byte. Models at that time were not big enough; theoretically, increasing the model could lower this further. Let's assume it is 3 bits/byte. Thus, a $64 \times 64$ ImageNet image has an average total entropy of $64\times 64\times 3\times 3$ bits. Next, we know that for a vocabulary with $V$ tokens, the average entropy per token is $\log_2 V$ bits. If we want to compress the encoding length to $L$ and achieve lossless compression, we must have:</p>

    \begin{equation}L\times \log_2 V \geq 64\times 64\times 3\times 3\end{equation}

    <p>If $L=1024=32\times 32$, then at least $V\geq 2^{36}\approx 7\times 10^{10}$. If $L=256=16\times 16$, then it requires at least $V\geq 2^{144}\approx 2\times 10^{43}$! Clearly, the codebook sizes of current Image Tokenizers have not reached such astronomical magnitudes. Consequently, the result is inevitably severe information loss!</p>

    <p>A natural question is: why must it be lossless? Indeed, humans cannot achieve perfect losslessness either. In fact, human understanding of images might involve more severe information loss than an Image Tokenizer. However, the requirement for a model is to align with human cognition. In other words, lossy compression is fine, but it should be "lossless to humans," much like how discarding infrared and ultraviolet light is lossless to the human eye. However, "lossless to humans" is a very broad concept without calculable metrics. VQ-VAE uses L2 distance to reconstruct images; due to information loss, blurring is inevitable. VQ-GAN adds a GAN loss to improve clarity, but it can only maintain global semantics and cannot perfectly align with human standards. Moreover, no one knows when humans will propose new image tasks that rely more on detail. Therefore, from the perspective of general intelligence, lossless compression is the inevitable final choice.</p>

    <p>Thus, in a truly universal multimodal model, the image part is bound to be much more difficult than the text part because the information content of images is far greater than that of text. But actually, images created by humans (like painting) are not much more complex than text (like writing). The truly complex images are those captured directly from nature. So ultimately, text is a product of humanity, while images are a product of nature. Humans are not as "smart" as nature, so text is not as difficult as images. A truly universal artificial intelligence must aim to surpass humans in every aspect.</p>

    <h2>Diffusion Models</h2>
    <p>Back to the point. Regarding current image generation technology, if we insist on lossless compression, we either go back to autoregressing in pixel space—which, as analyzed, is unacceptably slow—or we return to continuous space. This treats images as continuous vectors. Under the constraint of lossless compression, the only two choices are Flow models and Diffusion models.</p>

    <p>Flow is designed to be reversible, and Diffusion models can also derive reversible ODE equations. Both map a standard Gaussian distribution to the target distribution, meaning they have sufficient entropy sources. </p>

    <p>Discrete and continuous generation differ: the entropy source of discrete autoregressive generation is the product of seqlen and $\log(\text{vocab\_size})$. Since vocab_size's contribution grows logarithmically, it mainly relies on seqlen. But seqlen equals cost, so discrete entropy sources are expensive. The entropy source for transformation-based continuous generation is Gaussian noise, which can be infinite in principle, is cheap, and can be parallelized.</p>

    <p>However, to ensure reversibility in every layer, Flow models significantly modify the architecture, which likely limits their performance upper bound (no direct evidence, but Flow models haven't produced stunning results yet). Therefore, the only remaining choice is Diffusion models.</p>

    <p>Note that Diffusion is just the choice for the image <i>generation</i> scheme. For image <i>understanding</i>, from a lossless perspective, any encoding method carries the risk of distortion, so the most reliable input is definitely the original image. Therefore, the safest way should be to input the original image directly in the form of Patches, similar to the approach used by <a href="https://adept.ai/blog/fuyu-8b">Fuyu-8b</a>:</p>

    <div style="text-align: center;">
        <img src="https://kexue.fm/usr/uploads/2024/02/2529124233.png" alt="Fuyu-8b Model Diagram" style="max-width: 100%;">
        <p><em>Model diagram of Fuyu-8b</em></p>
    </div>

    <p>However, Fuyu-8b only handles multimodal input; the output is still single-modality text. How can we add image generation capability to it? Considering that the Diffusion model in the training phase is a denoising task, a possible approach would be:</p>

    <div style="text-align: center;">
        <img src="https://kexue.fm/usr/uploads/2024/02/751306354.png" alt="Imagined Multimodal Generation Approach" style="max-width: 100%;">
        <p><em>Personal imagination of a multimodal generation method</em></p>
    </div>

    <p>During training, the input is text and a noisy image. The training goal for text is to predict the next token, while for the image, it's to predict the original image (or noise). For prediction, the text part is still generated token-by-token recursively until `[IMG]` is predicted. Then, several noise vectors are input in parallel, and an image is sampled according to the Diffusion model. Note that the image generation part is parallel, so in principle, it's better if it's not Decoder-Only, because Decoder-Only necessitates a manually specified order, and different orders might significantly affect performance. With current Diffusion acceleration techniques, generation can be completed in roughly 10 steps, making the generation speed acceptable. </p>

    <p><i>(Update 2024.08.26: Meta's new <b>Transfusion</b> uses a scheme basically identical to the one above, just adding a Latent Encoder step for the image, with excellent results; furthermore, the slightly later <b>Show-o</b> is also very similar, with the difference being the discretization of Diffusion.)</i></p>

    <h2>Patch Input</h2>
    <p>A key aspect of the above approach is the use of a Patch-based Diffusion model, so the most fundamental thing is to verify if such a Diffusion model design is feasible (since it was previously said that Diffusion models rely heavily on existing U-Net architectures). To this end, I conducted some experiments and surveyed some literature. Below is a summary of my preliminary conclusions.</p>

    <p>According to my research, the earliest attempts to combine "Patch input + Transformer" for Diffusion models were likely <a href="https://arxiv.org/abs/2209.12152">"All are Worth Words: A ViT Backbone for Diffusion Models"</a> and <a href="https://arxiv.org/abs/2212.09748">"Scalable Diffusion Models with Transformers"</a>. These two papers were released roughly at the same time and used similar methods. The former (U-ViT) emphasized the role of the "Long skip connection" found in U-Net, while the latter (DiT) emphasized the necessity of incorporating the diffusion time $t$ and condition label $y$ into the model via adaLN. However, only U-ViT tried the approach of using original image patches directly as input, and even then, only for $64\times 64$ resolution. For $256\times 256$ and $512\times 512$ resolutions, both U-ViT and DiT performed diffusion in the feature space reduced by an <a href="https://arxiv.org/abs/2112.10752">LDM</a> autoencoder. This is indeed the current mainstream, but as stated earlier, this level of compression comes with severe information loss and can't be called a truly universal feature.</p>

    <p>Directly using raw image patches instead of pre-trained encoder features also has the advantage of avoiding isolation between features. For example, when we need to input two images $I_1$ and $I_2$ simultaneously, the usual approach based on encoder features is to input $encoder(I_1)$ and $encoder(I_2)$. The problem is that the $encoder$ itself performs a layer of semantic interaction within the image. By inputting $encoder(I_1)$ and $encoder(I_2)$, this layer of interaction between $I_1$ and $I_2$ is missing. This is the problem of feature isolation between images; more details can be found in <a href="https://arxiv.org/abs/2402.12204">"Browse and Concentrate: Comprehending Multimodal Content via prior-LLM Context Fusion"</a>. Thus, it's better to input the original forms of both text and images and let the multimodal model determine all interactions itself, thus eliminating this barrier.</p>

    <p>Of course, there is a reason why directly inputting raw image patches hasn't become mainstream. I experimented with it myself. The task was CelebA-HQ diffusion generation at $64\times 64$ and $128\times 128$ resolutions, reshaped respectively into $16\times 16\times 48$ and $16\times 16\times 192$ and projected into the model. The model was a standard Transformer with Pre-Norm, no Long skip connections, using <a href="translation_8333.html">GAU</a> instead of MHA for the backbone. Position encoding was <a href="translation_8265.html">2D-RoPE</a>, and the Time Embedding was added directly to the Patch input. Code reference: <a href="https://github.com/bojone/patch-diffusion">GitHub - bojone/patch-diffusion</a>.</p>

    <p>My experimental results show that both $64\times 64$ and $128\times 128$ resolutions can converge normally and eventually generate effects comparable to a standard U-Net (visually, without calculating FID). However, they require many more training steps to converge. For instance, on a single A800, a standard U-Net yields passable results in about 1-2 days at $128\times 128$ resolution, whereas the Transformer-based architecture required more than 10 days to even look decent. The reason is likely the lack of the inductive bias of CNNs; the model needs more training steps to learn the image priors. However, for large multimodal models, this is probably not an issue, as the number of training steps required for LLMs is already sufficiently high.</p>

    <h2>Article Summary</h2>
    <p>This article introduced my conception of multimodal model design—using original image patches directly as image input, while the text part follows the conventional next-token prediction, and the image part reconstructs the original image from added noise. Theoretically, this combination achieves multimodal generation in the most high-fidelity way. Preliminarily, it seems that a Transformer taking raw image patches as input can indeed train a successful image diffusion model. Thus, such a design mixing diffusion and text has the possibility of success. Of course, these are just some rough ideas about the multimodal path, most of which have not been verified through extensive practice. Please read with discretion~</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="translation_9984.html" style="color: #005fcc;">https://kexue.fm/archives/9984</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
