
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams'
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
  <h1><a href="https://kexue.fm/archives/6985">"Make Keras a Bit Cooler!": Reuse Techniques for Layers and Models</a></h1>

  <p>By 苏剑林 | September 29, 2019</p>

  <p>Today we continue to dig deep into Keras, once again experiencing its unparalleled elegant design. This time, our focus is on "reuse," primarily the repetitive use of layers and models.</p>

  <p>Generally, reuse is pursued for two goals: first, to share weights—meaning that two layers not only function the same but also share weights and update synchronously; second, to avoid rewriting code—for example, when we have already built a model and want to decompose it to construct sub-models, etc.</p>

  <h2>Basics</h2>

  <p>In fact, Keras has already considered many of these aspects for us, so in many cases, mastering the basic usage is sufficient to meet most of our needs.</p>

  <h3>Layer Reuse</h3>

  <p>Layer reuse is the simplest: initialize a layer, store it, and then call it repeatedly:</p>

  <pre><code>x_in = Input(shape=(784,))
x = x_in

layer = Dense(784, activation='relu') # Initialize a layer and store it

x = layer(x) # First call
x = layer(x) # Subsequent call
x = layer(x) # Subsequent call
</code></pre>

  <p>It is important to note that you must first initialize a layer and store it as a variable before calling it to ensure that the repeated calls share weights. Conversely, if the code follows the form below, the weights are not shared:</p>

  <pre><code>x = Dense(784, activation='relu')(x)
x = Dense(784, activation='relu')(x) # Does not share weights with the previous one
x = Dense(784, activation='relu')(x) # Does not share weights with the previous ones
</code></pre>

  <h3>Model Reuse</h3>

  <p>Keras models behave similarly to layers; they can be called in the same way as layers. For example:</p>

  <pre><code>x_in = Input(shape=(784,))
x = x_in

x = Dense(10, activation='softmax')(x)

model = Model(x_in, x) # Build model

x_in = Input(shape=(100,))
x = x_in

x = Dense(784, activation='relu')(x)
x = model(x) # Use the model like a layer

model2 = Model(x_in, x)
</code></pre>

  <p>Friends who have read the Keras source code will understand that the reason a model can be used like a layer is that <code>Model</code> itself inherits from the <code>Layer</code> class, so models naturally inherit certain characteristics from layers.</p>

  <h3>Model Cloning</h3>

  <p>Model cloning is similar to model reuse, except that the resulting new model does not share weights with the original model. In other words, only the exact same model structure is preserved, and the updates between the two models are independent. Keras provides a dedicated function for cloning models, which can be called directly:</p>

  <pre><code>from keras.models import clone_model

model2 = clone_model(model1)
</code></pre>

  <p>Note that <code>clone_model</code> completely copies the architecture of the original model and reconstructs a new model, but it does not copy the values of the original model's weights. That is to say, for the same input, the results of <code>model1.predict</code> and <code>model2.predict</code> will be different.</p>

  <p>If you need to transfer the weights as well, you need to manually <code>set_weights</code> them:</p>

  <pre><code>model2.set_weights(K.batch_get_value(model1.weights))
</code></pre>

  <h2>Advanced</h2>

  <p>The above discussions involved calling existing layers or models exactly as they are, which is relatively straightforward as Keras has already prepared for it. Below are some more complex examples.</p>

  <h3>Cross-referencing</h3>

  <p>Cross-referencing here refers to using the weights of an existing layer when defining a new layer. Note that this custom layer might have a completely different function from the original layer; they simply share a certain weight. For example, in BERT, when training the MLM (Masked Language Model), the final fully connected layer that predicts word probabilities shares its weights with the Embedding layer.</p>

  <p>A reference implementation is as follows:</p>

  <pre><code>class EmbeddingDense(Layer):
    """Operation identical to Dense, but the kernel uses the embedding matrix from an Embedding layer
    """
    def __init__(self, embedding_layer, activation='softmax', **kwargs):
        super(EmbeddingDense, self).__init__(**kwargs)
        self.kernel = K.transpose(embedding_layer.embeddings)
        self.activation = activation
        self.units = K.int_shape(self.kernel)[1]

    def build(self, input_shape):
        super(EmbeddingDense, self).build(input_shape)
        self.bias = self.add_weight(name='bias',
                                    shape=(self.units,),
                                    initializer='zeros')

    def call(self, inputs):
        outputs = K.dot(inputs, self.kernel)
        outputs = K.bias_add(outputs, self.bias)
        outputs = Activation(self.activation).call(outputs)
        return outputs

    def compute_output_shape(self, input_shape):
        return input_shape[:-1] + (self.units,)

# Usage
embedding_layer = Embedding(10000, 128)
x = embedding_layer(x) # Call Embedding layer
x = EmbeddingDense(embedding_layer)(x) # Call EmbeddingDense layer
</code></pre>

  <h3>Extracting Intermediate Layers</h3>

  <p>Sometimes we need to extract features from intermediate layers of a pre-built model and construct a new model. In Keras, this is also a very simple operation:</p>

  <pre><code>from keras.applications.resnet50 import ResNet50
model = ResNet50(weights='imagenet')

Model(
    inputs=model.input,
    outputs=[
        model.get_layer('res5a_branch1').output,
        model.get_layer('activation_47').output,
    ]
)
</code></pre>

  <h3>Splitting from the Middle</h3>

  <p>Finally, we come to the most challenging part of this article: splitting a model from the middle. Once you understand this, you can also implement operations like inserting or replacing layers in an existing model. This requirement might seem unusual, but believe it or not, <a href="https://stackoverflow.com/questions/49492255/how-to-replace-or-insert-intermediate-layer-in-keras-model">someone has asked about it on StackOverflow</a>, suggesting it certainly has value.</p>

  <p>Suppose we have an existing model that can be decomposed as:
  $$ \text{inputs} \to h_1 \to h_2 \to h_3 \to h_4 \to \text{outputs} $$
  We might need to replace $h_2$ with a new input and then connect the subsequent layers to build a new model, i.e., the function of the new model would be:
  $$ \text{inputs} \to h_3 \to h_4 \to \text{outputs} $$
  If it were a <code>Sequential</code> model, it would be quite simple: just iterate through <code>model.layers</code> to build the new model:</p>

  <pre><code>x_in = Input(shape=(100,))
x = x_in

for layer in model.layers[2:]:
    x = layer(x)

model2 = Model(x_in, x)
</code></pre>

  <p>However, if the model has a more complex structure, such as a residual structure that doesn't follow a single linear path, it’s not that simple. In reality, this task isn't inherently difficult; the required code is already part of Keras, but a ready-made interface isn't provided. Why do I say this? Because when we call an existing model using code like <code>model(x)</code>, Keras essentially reconstructs the entire existing <code>model</code> from start to finish. Since it can rebuild the entire model, building "half" a model is technically feasible; there just isn't a public API for it. For technical details, refer to the <code>run_internal_graph</code> function in <code>keras/engine/network.py</code> within the <a href="https://github.com/keras-team/keras/blob/master/keras/engine/network.py">Keras source code</a>.</p>

  <p>The logic for fully reconstructing a model resides in the <code>run_internal_graph</code> function. It’s not a simple function, so it’s best not to rewrite it. If we want to use that logic to split a model, the only way is to "graft" a solution: modify certain attributes of the existing model to trick the <code>run_internal_graph</code> function into thinking the model's input layer is an intermediate layer rather than the original input layer. With this idea in mind and a careful reading of the <code>run_internal_graph</code> code, one can derive the following reference code:</p>

  <pre><code>def get_outputs_of(model, start_tensors, input_layers=None):
    """start_tensors is the position to split from
    """
    # Create a new model for this operation
    model = Model(inputs=model.input,
                  outputs=model.output,
                  name='outputs_of_' + model.name)
    # Adaptation for convenience
    if not isinstance(start_tensors, list):
        start_tensors = [start_tensors]
    if input_layers is None:
        input_layers = [
            Input(shape=K.int_shape(x)[1:], dtype=K.dtype(x))
            for x in start_tensors
        ]
    elif not isinstance(input_layers, list):
        input_layers = [input_layers]
    # Core: Overwrite the model's input
    model.inputs = start_tensors
    model._input_layers = [x._keras_history[0] for x in input_layers]
    # Adaptation for convenience
    if len(input_layers) == 1:
        input_layers = input_layers[0]
    # Organize layers, referenced from Model's run_internal_graph function
    layers, tensor_map = [], set()
    for x in model.inputs:
        tensor_map.add(str(id(x)))
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            n = 0
            for x in node.input_tensors:
                if str(id(x)) in tensor_map:
                    n += 1
            if n == len(node.input_tensors):
                if node.outbound_layer not in layers:
                    layers.append(node.outbound_layer)
                for x in node.output_tensors:
                    tensor_map.add(str(id(x)))
    model._layers = layers # Keep only the used layers
    # Calculate outputs
    outputs = model(input_layers)
    return input_layers, outputs
</code></pre>

  <p>Usage:</p>

  <pre><code>from keras.applications.resnet50 import ResNet50
model = ResNet50(weights='imagenet')

x, y = get_outputs_of(
    model,
    model.get_layer('add_15').output
)

model2 = Model(x, y)
</code></pre>

  <p>The code is a bit long, but the logic is actually simple. The truly core code consists of just three lines:</p>

  <pre><code>model.inputs = start_tensors
model._input_layers = [x._keras_history[0] for x in input_layers]
outputs = model(input_layers)
</code></pre>

  <p>By overriding the model's <code>model.inputs</code> and <code>model._input_layers</code>, we achieve the effect of tricking the model into rebuilding from an intermediate layer. The rest is mostly adaptation work, and <code>model._layers = layers</code> ensures that only the layers used starting from the middle are retained. This is used to ensure the accuracy of the model's parameter count; if this part were removed, the model's reported parameter count would still equal that of the original entire model.</p>

  <h2>Summary</h2>

  <p>Keras is the most aesthetically pleasing deep learning framework—at least in terms of code readability, it stands alone. While some readers might mention PyTorch, and granted PyTorch has its advantages, in terms of readability, I believe it does not equal Keras.</p>

  <p>Through deep investigation of Keras, I have not only marveled at the profound and elegant programming skills of its authors but also felt my own programming skills improve. Indeed, many of my Python programming techniques were learned from studying the Keras source code.</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="translation_6985.html" style="color: #005fcc;">https://kexue.fm/archives/6985</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
