
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    packages: {'[+]': ['base', 'ams', 'noerrors', 'noundefined']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  },
  loader: {load: ['[tex]/ams']}
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<article>
    <h1><a href="https://kexue.fm/archives/10757">MoE Tour: 3. A Different Approach to Allocation</a></h1>
    <p>By 苏剑林 | March 5, 2025</p>

    <p>In this article, we continue our exploration of the load balancing problem in Mixture-of-Experts (MoE). In the previous post, <a href="translation_10735.html">"MoE Tour: 2. Concern is Not with Scarcity, but with Inequality,"</a> we primarily discussed the approach of promoting load balance through Auxiliary Loss (Aux Loss). While Aux Loss is simple and intuitive, it has a significant drawback—the weight is difficult to tune. If the weight is too low, it fails to promote balance; if it is too high, it easily harms the Language Model (LM) Loss. Consequently, the industry has been constantly searching for alternative solutions.</p>

    <p>The method we want to share today is called the "Loss-Free" scheme, proposed by DeepSeek in <a href="https://papers.cool/arxiv/2408.15664">"Auxiliary-Loss-Free Load Balancing Strategy for Mixture-of-Experts."</a> Compared to DeepSeek's many dazzling open-source works, this paper might seem less prominent. However, in my view, its potential academic influence may far surpass other works because the proposed method is not only simple and effective but also highly universal, making it an instant classic.</p>

    <h2 id="general-idea">General Idea</h2>

    <p>Faced with load imbalance, the idea of Aux Loss is to guide the Router to produce balanced scores through an additional loss. In contrast, the idea of Loss-Free is to change the allocation method itself—that is, it does not change the Router's existing scores, but rather changes the $\mathop{\text{argtop}}_k \boldsymbol{\rho}$ allocation mechanism.</p>

    <p>There have been previous efforts in this direction. For example, in 2021, Facebook proposed <a href="https://papers.cool/arxiv/2103.16716">BASE Layer</a>, which treats Expert allocation as a <a href="https://en.wikipedia.org/wiki/Assignment_problem">linear assignment problem</a>. That is, it treats load balance as a constraint and seeks to find an allocation result where the total Router score is as high as possible under that constraint, which can be solved using the <a href="https://en.wikipedia.org/wiki/Hungarian_algorithm">Hungarian algorithm</a> or similar methods. However, such schemes require knowing the scores of all tokens simultaneously. For auto-regressive LLMs, this is only applicable during training; inference still has to rely on $\mathop{\text{argtop}}_k \boldsymbol{\rho}$, leading to training-inference inconsistency. Furthermore, due to the limitations of current solvers, it is typically only applicable to the $k=1$ scenario.</p>

    <p>In comparison, the Loss-Free approach is remarkably simple and effective. It notes the fact that we can always introduce a bias term $\boldsymbol{b}$ such that the allocation $\mathop{\text{argtop}}_k \boldsymbol{\rho} + \boldsymbol{b}$ is balanced. Therefore, it modifies the MoE form to:</p>
    
    \[\boldsymbol{y} = \sum_{i\in \mathop{\text{argtop}}_k \boldsymbol{\rho}} \rho_i \boldsymbol{e}_i\qquad\to\qquad \boldsymbol{y} = \sum_{i\in \mathop{\text{argtop}}_k \boldsymbol{\rho} + \boldsymbol{b}} \rho_i \boldsymbol{e}_i\]
    
    <p>Here, $\boldsymbol{b}$ is an input-independent vector determined during the training process. Once training is complete, it remains fixed, and therefore can be used during the inference stage as well. In other words, training and inference share identical forms. Note that the value multiplied by $\boldsymbol{e}_i$ is still $\rho_i$ and not $\rho_i + b_i$. This means $\boldsymbol{b}$ only participates in the allocation process and does not participate in the MoE forward computation. Thus, we have no special requirements regarding the positivity or negativity of $\boldsymbol{b}$ or $\boldsymbol{\rho} + \boldsymbol{b}$.</p>

    <h2 id="handcrafting-gradients">Handcrafting Gradients</h2>

    <p>How do we train $\boldsymbol{b}$? We know the optimization direction for $\boldsymbol{b}$ is naturally to promote load balance. To this end, following the notation of the previous article, we first define $\boldsymbol{f}=[f_1, f_2, \cdots, f_n]$:</p>
    
    \begin{equation}f_i = \left\{\begin{aligned}1/k, \quad i\in \mathop{\text{argtop}}\nolimits_k \boldsymbol{\rho}+\boldsymbol{b} \\ 0, \quad i\not\in \mathop{\text{argtop}}\nolimits_k \boldsymbol{\rho}+\boldsymbol{b}\end{aligned}\right.\end{equation}
    
    <p>And $\boldsymbol{F}=\mathbb{E}[\boldsymbol{f}]$. Here $\boldsymbol{F}$ naturally represents the current load distribution of experts under the bias $\boldsymbol{b}$. Next, we define the uniform distribution as $\boldsymbol{Q}=(1/n, 1/n, \cdots, 1/n)$. Load balancing then becomes equivalent to minimizing:</p>
    
    \begin{equation}\mathcal{L}_{\text{aux}} = \frac{1}{2}\Vert\boldsymbol{F} - \boldsymbol{Q}\Vert^2 = \frac{1}{2}\sum_{i=1}^n (F_i - 1/n)^2\end{equation}
    
    <p>This objective is non-differentiable. However, based on our experience from the previous post, we know that STE (Straight-Through Estimator) can solve this. The key to STE is finding a differentiable quantity that share the same trend of increase or decrease as $\boldsymbol{F}$ to serve as a smooth approximation. Here, our only optimization parameter is $\boldsymbol{b}$, and it possesses exactly the property we desire (increasing $b_i$ increases the probability of $i$ being selected, thus increasing $F_i$). So the answer reveals itself:</p>
    
    \begin{equation}\mathcal{L}_{\text{aux}} = \frac{1}{2}\Vert\boldsymbol{b} + \text{sg}[\boldsymbol{\rho}-\boldsymbol{b}] - \boldsymbol{Q}\Vert^2 = \frac{1}{2}\sum_{i=1}^n (b_i + \text{sg}[F_i - b_i] - 1/n)^2\end{equation}
    
    <p>Its gradient is:</p>
    
    \begin{equation}\nabla_{\boldsymbol{b}}\mathcal{L}_{\text{aux}} = \frac{1}{2}\nabla_{\boldsymbol{b}}\Vert\boldsymbol{b} + \text{sg}[\boldsymbol{F}-\boldsymbol{b}] - \boldsymbol{Q}\Vert^2 = \boldsymbol{F} - \boldsymbol{Q}\end{equation}
    
    <p>So, updating $\boldsymbol{b}$ using Stochastic Gradient Descent (SGD) gives:</p>
    
    \begin{equation}\boldsymbol{b}\leftarrow \boldsymbol{b} - \alpha (\boldsymbol{F} - \boldsymbol{Q})\end{equation}
    
    <p>Where $\alpha$ is the learning rate for $\boldsymbol{b}$. However, the rule eventually chosen by Loss-Free is slightly different; it chooses Sign Gradient Descent (SignSGD):</p>
    
    \begin{equation}\boldsymbol{b}\leftarrow \boldsymbol{b} - \alpha \mathop{\text{sign}}(\boldsymbol{F} - \boldsymbol{Q})\label{eq:aux-loss-free}\end{equation}
    
    <p>This result is also easy to understand: if $F_i$ is larger than $1/n$, then decrease $b_i$ a little; otherwise, increase $b_i$ a little.</p>

    <h2 id="improved-version">Improved Version</h2>

    <p>In addition to SignSGD, I found that applying RMS Norm (i.e., Normalized SGD) directly to $\boldsymbol{F} - \boldsymbol{Q}$ often achieves better balancing effects with the same $\alpha$:</p>
    
    \begin{equation}\boldsymbol{b}\leftarrow \boldsymbol{b} - \alpha\frac{\boldsymbol{F} - \boldsymbol{Q}}{\text{RMS}(\boldsymbol{F} - \boldsymbol{Q})}\end{equation}
    
    <p>Where RMS stands for "Root Mean Square," defined as:</p>
    
    \begin{equation}\text{RMS}(\boldsymbol{F} - \boldsymbol{Q}) = \sqrt{\frac{1}{n}\sum_{i=1}^n (F_i - Q_i)^2}\end{equation}
    
    <p>It is not hard to see that both $\mathop{\text{sign}}(\boldsymbol{F} - \boldsymbol{Q})$ and Normalized $\frac{\boldsymbol{F} - \boldsymbol{Q}}{\text{RMS}(\boldsymbol{F} - \boldsymbol{Q})}$ have an RMS of 1. Thus, they are roughly on the same scale, allowing us to use the same $\alpha$.</p>
    
    <p>In short, the problem with $\mathop{\text{sign}}$ is that it uses the same update magnitude regardless of how close $F_i$ is to the target $Q_i$. This causes $F_i$ that are already close to $Q_i$ to oscillate and deviate from balance. RMS Norm, however, preserves the relative relationship between $F_i - Q_i$, making the update magnitude more adaptive. Theoretically, this is more conducive to promoting balance, and in practice, it usually performs better.</p>

    <h2 id="in-the-same-lineage">In the Same Lineage</h2>

    <p>When the original paper introduced Loss-Free, it did not include the Aux Loss derivation provided above. Instead, it directly presented the update rule in Equation \eqref{eq:aux-loss-free}, giving the impression that they "handcrafted" the gradient $\mathop{\text{sign}}(\boldsymbol{F} - \boldsymbol{Q})$ for $\boldsymbol{b}$. This is where the name "Loss-Free" originates.</p>

    <p>However, from the derivation given in this post, we can see that the update rule \eqref{eq:aux-loss-free} can be derived entirely from an Aux Loss perspective. The two are deeply connected. It seems the most direct benefit of Loss-Free is that there's no need to tune the Aux Loss weight, although it actually still has a learning rate parameter $\alpha$. Although the original paper has already searched for the default value of $\alpha=0.001$, it cannot be denied that this hyperparameter exists.</p>

    <p>In my opinion, the essential innovation of Loss-Free is not the absence of an Aux Loss, but the isolation of the optimization parameters of the Aux Loss and the LM Loss, thereby achieving both load balance and model capability. The most critical step is noticing the fact that "a single bias term is sufficient to achieve load balance." Then, the Aux Loss is allowed to optimize only the newly introduced bias $\boldsymbol{b}$, while the LM Loss optimizes the remaining parameters, minimizing the negative impact of the Aux Loss on the LM Loss.</p>

    <p>In contrast, conventional Aux Loss schemes require all parameters to promote load balance, while LM Loss also optimizes all parameters. The optimization directions of the two might not be fully compatible, making it relatively more difficult to find an optimal balance point. Thus, Loss-Free's isolation of the two loss functions' optimization parameters based on "one bias term is enough" is a brilliant solution to the load balancing problem.</p>

    <h2 id="related-details">Related Details</h2>

    <p>Although Loss-Free is simple and clear enough, some details should be noted when using it.</p>

    <p>First, for each batch of data, we should first update the model parameters based on the LM Loss, and then update $\boldsymbol{b}$ according to Equation \eqref{eq:aux-loss-free}. This is because the update of $\boldsymbol{b}$ depends on the aggregate statistics $\boldsymbol{F}$ of all tokens in the batch. If we update $\boldsymbol{b}$ before the rest of the model parameters, there is technically a risk of leaking future information. Although it seems unlikely that a single vector $\boldsymbol{b}$ would leak much information, the risk exists, and it is better to avoid it.</p>

    <p>Second, we mentioned that the original paper tuned $\alpha=0.001$, but this result might be coupled with the choice of using Sigmoid as the Router activation function $\boldsymbol{\rho}$. The reason is simple: after Sigmoid, each $\rho_i$ is relatively independent and within $(0,1)$. $\alpha=0.001$ implies an update magnitude of about one-thousandth per step. If Softmax, ReLU, or other activation functions are used, $\alpha$ might need to be retuned.</p>
    
    <p>To address this problem, I suggest decoupling the activation functions used for the Gate and the Bias, i.e.:</p>
    
    \begin{equation}\boldsymbol{y} = \sum_{i\in \mathop{\text{argtop}}_k \boldsymbol{\rho} + \boldsymbol{b}} \rho_i \boldsymbol{e}_i\qquad\to\qquad \boldsymbol{y} = \sum_{i\in \mathop{\text{argtop}}_k \boldsymbol{\rho}^{(\sigma)} + \boldsymbol{b}} \rho_i^{(h)} \boldsymbol{e}_i\end{equation}
    
    <p>Where $\boldsymbol{\rho}^{(\sigma)} = \sigma(\boldsymbol{x}\boldsymbol{W}^{(R)})$ and $\boldsymbol{\rho}^{(h)} = h(\boldsymbol{x}\boldsymbol{W}^{(R)})$. Here $\sigma(\cdot)$ is the Sigmoid function, and $h(\cdot)$ is any monotonic function with a non-negative range. Simply put, the Sigmoid-activated score is what is added to $\boldsymbol{b}$, allowing us to reuse $\alpha=0.001$. As for the Gate multiplied by the Expert, we can use other activation functions as long as their monotonicity is consistent with Sigmoid.</p>

    <p>Additionally, because the update rule \eqref{eq:aux-loss-free} includes the $\text{sign}$ function, it is possible for the absolute value of $b_i$ to exceed 1 or for the overall absolute values to keep increasing. These are normal and will not affect the model's performance. In fact, $\boldsymbol{b}$ has a redundant degree of freedom, since the result of $\mathop{\text{argtop}}_k \boldsymbol{\rho} + \boldsymbol{b}$ remains unchanged if a constant is added to all $b_i$. This extra degree of freedom can be used for other interesting things (to be discussed in a later installment).</p>

    <h2 id="further-reflections">Further Reflections</h2>

    <p>Beyond MoE load balancing, the idea of Loss-Free can be applied to many similar problems. For example, Codebook Collapse in VQ-VAE can be solved using the same approach. Compared to the previously introduced <a href="translation_10489.html">"Rotation Trick"</a> or <a href="translation_10519.html">"Linear Transformation Trick,"</a> it appears more natural and universal. In fact, the evaluation at the beginning of this article—that "the potential academic influence of Loss-Free may far surpass other works"—is precisely based on this consideration of its universality.</p>

    <p>Setting aside specific application contexts and looking at it mathematically, the contribution of Loss-Free can be understood as providing a way to solve the assignment problem using gradient descent. A classic linear assignment problem can be expressed as:</p>
    
    \begin{equation}\min_f \sum_{i=1}^n c_{i, f(i)}\end{equation}
    
    <p>Where $c_{i,j}$ is a given cost function, and $f$ is a bijection from $\{1,2,\cdots,n\}$ to itself. In the context of this post, $c_{i,j}$ corresponds to the scores of $n$ tokens and $n$ experts, and the sought-after $f$ is exactly a balanced allocation scheme. The general idea for solving such problems is to search for the most optimal solution within the space that satisfies the constraints. Loss-Free, on the other hand, works backward. It first constructs an optimal solution that might not satisfy the constraints:</p>
    
    \begin{equation}f(i) = \mathop{\text{argmin}}_j c_{i,j}\end{equation}
    
    <p>This solution is definitely optimal in terms of score, but it is not necessarily a bijection (which, in this context, is equivalent to load imbalance). Thus, we introduce a bias:</p>
    
    \begin{equation}f(i) = \mathop{\text{argmin}}_j c_{i,j} + b_j\end{equation}
    
    <p>$\boldsymbol{b}_j$ is initialized to zero and then updated according to Equation \eqref{eq:aux-loss-free}. The update rule, simply put, is: if $j$ appears too frequently, decrease the corresponding $b_j$; otherwise, increase it until a bijection is achieved.</p>

    <h2 id="summary">Summary</h2>

    <p>This article introduced the Loss-Free method for the MoE load balancing problem proposed by DeepSeek. Its core lies in achieving load balance by introducing a simple bias term. This post further explored its connection with Aux Loss and its application potential in similar mathematical problems.</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="translation_10757.html" style="color: #005fcc;">https://kexue.fm/archives/10757</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
