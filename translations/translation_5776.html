
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    tags: 'ams',
    packages: {'[+]': ['ams']}
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/5776">NICE in "Steady" Flows: Basic Concepts and Implementation of Flow Models</a></h1>

<p>By 苏剑林 | August 11, 2018</p>

<p><strong>Preface:</strong> Ever since I saw the Glow model on Machine Heart (see <a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650745032&idx=1&sn=a889433dd4c4d9f62bfab347909d9d28&chksm=871aecb6b06d65a02625abdf4b21a2116251e311a49508db587b76ae8f76d7a9e03d4a6ab80a&scene=27#wechat_redirect">"The Next GAN? OpenAI Proposes Invertible Generative Model Glow"</a>), I have been thinking about it constantly. Machine learning models emerge one after another nowadays; I often follow new model trends, but few have moved me as much as the Glow model, giving me that "this is it" feeling. What's even more surprising is that this model, which produces such good results, was something I had never heard of before. I've re-read it several times over the past few days, and the more I read, the more interesting it becomes, feeling like it connects many of my previous ideas. Here is a summary of this stage.</p>

<h2>Background</h2>

<p>This article mainly introduces and implements <a href="https://papers.cool/arxiv/1410.8516">"NICE: Non-linear Independent Components Estimation"</a>. This paper is one of the foundational works for the Glow model—it could be called the cornerstone of Glow.</p>

<h3>Difficult Distributions</h3>

<p>As is well known, mainstream generative models currently include VAEs and GANs. In fact, besides these two, there are also flow-based models (the concept of "flow" will be introduced later). Flow models have a history as long as VAEs and GANs, but they are far less known. In my opinion, the reason is likely that flow models lack a straightforward explanation like the "counterfeiter-discriminator" analogy of GANs. Flow is entirely mathematical and, combined with the fact that early results weren't particularly good while computational costs were high, it was hard to generate interest. However, now OpenAI’s amazing Glow model, based on flow, will likely encourage more people to invest in flow models.</p>

<figure>
  <img src="https://kexue.fm/usr/uploads/2018/08/2199043217.png" alt="High-definition faces generated by Glow model">
  <figcaption>High-definition faces generated by the Glow model</figcaption>
</figure>

<p>The essence of a generative model is the hope of using a probability model we know to fit given data samples. That is, we must write a distribution $q_{\boldsymbol{\theta}}(\boldsymbol{x})$ with parameters $\boldsymbol{\theta}$. However, our neural networks are "universal function approximators," not "universal distribution approximators." While they can theoretically fit any function, they cannot arbitrarily fit a probability distribution because a distribution must satisfy "non-negativity" and "normalization" requirements. Consequently, the only distributions we can directly write down are discrete distributions or continuous Gaussian distributions.</p>

<p>Of course, from a strict perspective, an image should be a discrete distribution because it consists of a finite number of pixels, and each pixel value is also discrete and finite. Therefore, it can be described by a discrete distribution. This line of thought resulted in models like PixelRNN, which we call "autoregressive flows." Their characteristic is that they cannot be parallelized, so the computational cost is extremely high. Thus, we prefer to use continuous distributions to describe images. Of course, images are just one scenario; in other contexts, we also have a lot of continuous data, making research into continuous distributions very necessary.</p>

<h3>Each Showing Their Prowess</h3>

<p>So the problem arises: for continuous models, we can really only write down Gaussian distributions. Furthermore, for ease of processing, we often only write down Gaussian distributions where each component is independent. This is clearly only a tiny fraction of the vast array of continuous distributions and is obviously insufficient. To solve this dilemma, we create more distributions through integration:</p>

$$q(\boldsymbol{x})=\int q(\boldsymbol{z})q_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{z}) d\boldsymbol{z} \tag{1}$$

<p>Here $q(\boldsymbol{z})$ is generally a standard Gaussian distribution, and $q_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{z})$ can be any conditional Gaussian distribution or a Dirac distribution. Such integral forms can create many complex distributions. Theoretically, it can fit any distribution.</p>

<p>Now that the distribution form is established, we need to find the parameters $\boldsymbol{\theta}$. Usually, this involves maximum likelihood. Assuming the true data distribution is $\tilde{p}(\boldsymbol{x})$, we need to maximize the objective:</p>

$$\mathbb{E}_{\boldsymbol{x}\sim \tilde{p}(\boldsymbol{x})} \big[\log q(\boldsymbol{x})\big] \tag{2}$$

<p>However, since $q_{\boldsymbol{\theta}}(\boldsymbol{x})$ is in integral form, whether it can be computed is difficult to say.</p>

<p>Various experts have "crossed the sea like the Eight Immortals, each showing their own prowess." Among them, VAE and GAN bypassed this difficulty in different ways. VAE does not directly optimize objective (2); instead, it optimizes a stronger upper bound, making it only an approximate model that cannot achieve perfect generative results. GAN bypasses the difficulty through an alternating training method, preserving the model's precision, which is why it achieves such good generation effects. Regardless, GAN is not satisfactory in every respect, so exploring other solutions is meaningful.</p>

<h3>Directly Facing Probability Integrals</h3>

<p>Flow models choose a "hard road": <strong>computing the integral directly</strong>.</p>

<p>Specifically, flow models choose $q(\boldsymbol{x}|\boldsymbol{z})$ to be a Dirac distribution $\delta(\boldsymbol{x}-\boldsymbol{g}(\boldsymbol{z}))$, and $\boldsymbol{g}(\boldsymbol{z})$ must be invertible. In other words:</p>

$$\boldsymbol{x}=\boldsymbol{g}(\boldsymbol{z}) \Leftrightarrow \boldsymbol{z} = \boldsymbol{f}(\boldsymbol{x}) \tag{3}$$

<p>To realize invertibility theoretically (mathematically), $\boldsymbol{z}$ and $\boldsymbol{x}$ must have the same dimension. Assuming the forms of $\boldsymbol{f}$ and $\boldsymbol{g}$ are known, calculating $q(\boldsymbol{x})$ via (1) is equivalent to performing an integral transformation $\boldsymbol{z}=\boldsymbol{f}(\boldsymbol{x})$ on $q(\boldsymbol{z})$. That is, originally:</p>

$$q(\boldsymbol{z}) = \frac{1}{(2\pi)^{D/2}}\exp\left(-\frac{1}{2} \Vert \boldsymbol{z}\Vert^2\right) \tag{4}$$

<p>is a standard Gaussian distribution ($D$ is the dimension of $\boldsymbol{z}$). Now we perform the change of variables $\boldsymbol{z}=\boldsymbol{f}(\boldsymbol{x})$. Note that the change of variables for a probability density function is not as simple as replacing $\boldsymbol{z}$ with $\boldsymbol{f}(\boldsymbol{x})$; it also involves the absolute value of the "Jacobian determinant":</p>

$$q(\boldsymbol{x}) = \frac{1}{(2\pi)^{D/2}}\exp\left(-\frac{1}{2}\big\Vert \boldsymbol{f}(\boldsymbol{x})\big\Vert^2\right)\left|\det\left[\frac{\partial \boldsymbol{f}}{\partial \boldsymbol{x}}\right]\right| \tag{5}$$

<p>Thus, we have two requirements for $\boldsymbol{f}$:</p>

<blockquote>
<p>1. It must be invertible, and its inverse function must be easy to find (its inverse $\boldsymbol{g}$ is our desired generative model);</p>
<p>2. The corresponding Jacobian determinant must be easy to calculate.</p>
</blockquote>

<p>In this way:</p>

$$\log q(\boldsymbol{x}) = -\frac{D}{2}\log (2\pi) -\frac{1}{2}\big\Vert \boldsymbol{f}(\boldsymbol{x})\big\Vert^2 + \log \left|\det\left[\frac{\partial \boldsymbol{f}}{\partial \boldsymbol{x}}\right]\right| \tag{6}$$

<p>This optimization target is solvable. Furthermore, because $\boldsymbol{f}$ is easy to invert, once training is complete, we can randomly sample a $\boldsymbol{z}$ and then generate a sample via the inverse of $\boldsymbol{f}$: $\boldsymbol{f}^{-1}(\boldsymbol{z})=\boldsymbol{g}(\boldsymbol{z})$. This gives us the generative model.</p>

<h2>flow</h2>

<p>We have previously introduced the characteristics and difficulties of flow models. Below, we will detail how the flow model addresses these difficulties. Since this article mainly introduces the work of the first paper, <a href="https://papers.cool/arxiv/1410.8516">"NICE: Non-linear Independent Components Estimation"</a>, we will specifically refer to this model as NICE.</p>

<h3>Coupling Layer</h3>

<p>Relatively speaking, calculating the determinant is more difficult than inverting a function, so we start by thinking from "Requirement 2." Friends familiar with linear algebra will know that the determinant of a triangular matrix is the easiest to calculate: it equals the product of the diagonal elements. Therefore, we should try to make the Jacobian matrix of transformation $\boldsymbol{f}$ a triangular matrix. NICE's approach is very clever: it divides the $D$-dimensional $\boldsymbol{x}$ into two parts, $\boldsymbol{x}_1, \boldsymbol{x}_2$, and then takes the following transformation:</p>

$$\begin{aligned}&\boldsymbol{h}_{1} = \boldsymbol{x}_{1}\\
&\boldsymbol{h}_{2} = \boldsymbol{x}_{2} + \boldsymbol{m}(\boldsymbol{x}_{1})\end{aligned} \tag{7}$$

<p>Where $\boldsymbol{x}_1, \boldsymbol{x}_2$ is some partition of $\boldsymbol{x}$, and $\boldsymbol{m}$ is any function of $\boldsymbol{x}_1$. That is, $\boldsymbol{x}$ is split into two parts, and transformed according to the above formula to obtain new variables $\boldsymbol{h}$. We call this an "Additive Coupling Layer." Without loss of generality, the dimensions of $\boldsymbol{x}$ can be rearranged so that $\boldsymbol{x}_1 = \boldsymbol{x}_{1:d}$ represents the first $d$ elements, and $\boldsymbol{x}_2=\boldsymbol{x}_{d+1:D}$ represents elements $d+1 \sim D$.</p>

<p>It is not hard to see that the Jacobian matrix of this transformation $\left[\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{x}}\right]$ is a triangular matrix, and the diagonal elements are all 1. Represented as a block matrix:</p>

$$\left[\frac{\partial \boldsymbol{h}}{\partial \boldsymbol{x}}\right]=\begin{pmatrix}\mathbb{I}_{1:d} & \mathbb{O} \\
\left[\frac{\partial \boldsymbol{m}}{\partial \boldsymbol{x}_1}\right] & \mathbb{I}_{d+1:D}\end{pmatrix} \tag{8}$$

<p>As a result, the Jacobian determinant of this transformation is 1, its logarithm is 0, thus solving the problem of determinant calculation.</p>

<p>At the same time, the transformation in (7) is invertible, and its inverse is:</p>

$$\begin{aligned}&\boldsymbol{x}_{1} = \boldsymbol{h}_{1}\\
&\boldsymbol{x}_{2} = \boldsymbol{h}_{2} - \boldsymbol{m}(\boldsymbol{h}_{1})\end{aligned} \tag{9}$$

<h3>Steady Streams of Flow</h3>

<p>The above transformation is quite surprising: it is invertible, and the inverse transformation is very simple, adding no extra computational cost. Nevertheless, we can note that the first part of transformation (7) is trivial (an identity transformation). Therefore, a single transformation cannot achieve very strong non-linearity. We need to compose multiple simple transformations to achieve strong non-linearity and enhance fitting capability.</p>

$$\boldsymbol{x} = \boldsymbol{h}^{(0)} \leftrightarrow \boldsymbol{h}^{(1)} \leftrightarrow \boldsymbol{h}^{(2)} \leftrightarrow \dots \leftrightarrow \boldsymbol{h}^{(n-1)} \leftrightarrow \boldsymbol{h}^{(n)} = \boldsymbol{z} \tag{10}$$

<p>where each transformation is an additive coupling layer. This is like water flowing—accumulating a lot from a little, a steady stream flowing far. Thus, such a process is called a "flow." In other words, a flow is the coupling of multiple additive coupling layers.</p>

<p>By the chain rule:</p>

$$\left[\frac{\partial \boldsymbol{z}}{\partial \boldsymbol{x}}\right]=\left[\frac{\partial \boldsymbol{h}^{(n)}}{\partial \boldsymbol{h}^{(0)}}\right]=\left[\frac{\partial \boldsymbol{h}^{(n)}}{\partial \boldsymbol{h}^{(n-1)}}\right]\left[\frac{\partial \boldsymbol{h}^{(n-1)}}{\partial \boldsymbol{h}^{(n-2)}}\right]\dots \left[\frac{\partial \boldsymbol{h}^{(1)}}{\partial \boldsymbol{h}^{(0)}}\right] \tag{11}$$

<p>Because "the determinant of a product of matrices equals the product of the matrices' determinants," and each layer is an additive coupling layer, the determinant of each layer is 1. Therefore, the result is:</p>

$$\det \left[\frac{\partial \boldsymbol{z}}{\partial \boldsymbol{x}}\right]=\det\left[\frac{\partial \boldsymbol{h}^{(n)}}{\partial \boldsymbol{h}^{(n-1)}}\right]\det\left[\frac{\partial \boldsymbol{h}^{(n-1)}}{\partial \boldsymbol{h}^{(n-2)}}\right]\dots \det\left[\frac{\partial \boldsymbol{h}^{(1)}}{\partial \boldsymbol{h}^{(0)}}\right]=1$$

<p>(Considering the staggering below, the determinant might become -1, but the absolute value remains 1), so we still don't need to consider the determinant.</p>

<h3>Advancing Through Interleaving</h3>

<p>Note that if the order of coupling remains unchanged, i.e.,</p>

$$\begin{array}{ll}\begin{aligned}&\boldsymbol{h}^{(1)}_{1} = \boldsymbol{x}_{1}\\
&\boldsymbol{h}^{(1)}_{2} = \boldsymbol{x}_{2} + \boldsymbol{m}_1(\boldsymbol{x}_{1})\end{aligned} & \begin{aligned}&\boldsymbol{h}^{(2)}_{1} = \boldsymbol{h}^{(1)}_{1}\\
&\boldsymbol{h}^{(2)}_{2} = \boldsymbol{h}^{(1)}_{2} + \boldsymbol{m}_2\big(\boldsymbol{h}^{(1)}_{1}\big)\end{aligned} & \\
& \\
\begin{aligned}&\boldsymbol{h}^{(3)}_{1} = \boldsymbol{h}^{(2)}_{1}\\
&\boldsymbol{h}^{(3)}_{2} = \boldsymbol{h}^{(2)}_{2} + \boldsymbol{m}_3\big(\boldsymbol{h}^{(2)}_{1}\big)\end{aligned} & \begin{aligned}&\boldsymbol{h}^{(4)}_{1} = \boldsymbol{h}^{(3)}_{1}\\
&\boldsymbol{h}^{(4)}_{2} = \boldsymbol{h}^{(3)}_{2} + \boldsymbol{m}_4\big(\boldsymbol{h}^{(3)}_{1}\big)\end{aligned} & \quad\dots
\end{array} \tag{12}$$

<p>Then ultimately $\boldsymbol{z}_1 = \boldsymbol{x}_1$, and the first part remains trivial, as shown below:</p>

<figure>
  <img src="https://kexue.fm/usr/uploads/2018/08/21981440.png" alt="Simple coupling keeps part of the input identical, information is not fully mixed">
  <figcaption>Simple coupling keeps part of the input identical; information is not fully mixed</figcaption>
</figure>

<p>To obtain non-trivial transformations, we can consider shuffling or reversing the order of input dimensions before each additive coupling, or simply swapping the positions of these two parts so that information can mix thoroughly, for example:</p>

$$\begin{array}{ll}\begin{aligned}&\boldsymbol{h}^{(1)}_{1} = \boldsymbol{x}_{1}\\
&\boldsymbol{h}^{(1)}_{2} = \boldsymbol{x}_{2} + \boldsymbol{m}_1(\boldsymbol{x}_{1})\end{aligned} & \begin{aligned}&\boldsymbol{h}^{(2)}_{1} = \boldsymbol{h}^{(1)}_{1} + \boldsymbol{m}_2\big(\boldsymbol{h}^{(1)}_{2}\big)\\
&\boldsymbol{h}^{(2)}_{2} = \boldsymbol{h}^{(1)}_{2}\end{aligned} & \\
& \\
\begin{aligned}&\boldsymbol{h}^{(3)}_{1} = \boldsymbol{h}^{(2)}_{1}\\
&\boldsymbol{h}^{(3)}_{2} = \boldsymbol{h}^{(2)}_{2} + \boldsymbol{m}_3\big(\boldsymbol{h}^{(2)}_{1}\big)\end{aligned} & \begin{aligned}&\boldsymbol{h}^{(4)}_{1} = \boldsymbol{h}^{(3)}_{1} + \boldsymbol{m}_4\big(\boldsymbol{h}^{(3)}_{2}\big)\\
&\boldsymbol{h}^{(4)}_{2} = \boldsymbol{h}^{(3)}_{2} \end{aligned} & \quad\dots
\end{array} \tag{13}$$

<p>As shown below:</p>

<figure>
  <img src="https://kexue.fm/usr/uploads/2018/08/3305596417.png" alt="Mixing information through cross-coupling to achieve stronger nonlinearity">
  <figcaption>Mixing information through cross-coupling to achieve stronger nonlinearity</figcaption>
</figure>

<h3>Scaling Transformation Layer</h3>

<p>In the first half of the article, we pointed out that flow is based on invertible transformations. Therefore, when the model is trained, we simultaneously obtain a generative model and an encoding model. However, because of the invertible transformation, the random variable $\boldsymbol{z}$ and the input sample $\boldsymbol{x}$ have the same size. When we specify $\boldsymbol{z}$ as a Gaussian distribution, it is spread across the entire $D$-dimensional space, where $D$ is the size of the input $\boldsymbol{x}$. But although $\boldsymbol{x}$ has $D$ dimensions, it might not truly fill the entire $D$-dimensional space. For example, an MNIST image has 784 pixels, but some pixels stay at 0 across both training and test sets, indicating the data doesn't truly occupy all 784 dimensions.</p>

<p>In other words, flow, a model based on invertible transformations, inherently faces a serious problem of dimensional wastage: input data clearly doesn't reside on a $D$-dimensional manifold, yet it must be encoded as a $D$-dimensional manifold. Is this feasible?</p>

<p>To address this, NICE introduces a scaling transformation layer. It applies a scale transformation to each dimension of the encoded features, namely $\boldsymbol{z} = \boldsymbol{s}\otimes \boldsymbol{h}^{(n)}$, where $\boldsymbol{s} = (\boldsymbol{s}_1,\boldsymbol{s}_2,\dots,\boldsymbol{s}_D)$ is a vector of parameters to be optimized (each element is non-negative). This vector $\boldsymbol{s}$ can identify the importance of each dimension (the smaller it is, the more important; the larger it is, the less important the dimension, becoming negligible as it increases), serving to compress the manifold. Note that the Jacobian determinant of this scaling layer is no longer 1. The Jacobian matrix is diagonal:</p>

$$\left[\frac{\partial \boldsymbol{z}}{\partial \boldsymbol{h}^{(n)}}\right] = \text{diag}\, (\boldsymbol{s}) \tag{14}$$

<p>So its determinant is $\prod_i \boldsymbol{s}_i$. Thus, according to equation (6), we have the log-likelihood:</p>

$$\log q(\boldsymbol{x}) \sim -\frac{1}{2}\big\Vert \boldsymbol{s}\otimes \boldsymbol{f} (\boldsymbol{x})\big\Vert^2 + \sum_i \log \boldsymbol{s}_i \tag{15}$$

<p>Why can this scaling transformation identify the importance of features? In fact, this scaling layer can be described in a clearer way: initially, we set the prior distribution of $\boldsymbol{z}$ to be a standard normal distribution, meaning all variances are 1. Actually, we can also treat the variance of the prior distribution as a training parameter. This way, after training, variances will vary. A smaller variance indicates smaller "dispersion" for that feature. If the variance is 0, the feature is always 0 (equal to the mean 0), and the distribution for that dimension collapses to a point. This means the manifold's dimensionality is reduced by one.</p>

<p>Different from equation (4), we write the normal distribution with variance:</p>

$$q(\boldsymbol{z}) = \frac{1}{(2\pi)^{D/2}\prod\limits_{i=1}^D \boldsymbol{\sigma}_i}\exp\left(-\frac{1}{2}\sum_{i=1}^D \frac{\boldsymbol{z}_i^2}{\boldsymbol{\sigma}_i^2}\right) \tag{16}$$

<p>Substituting the flow model $\boldsymbol{z}=\boldsymbol{f}(\boldsymbol{x})$ into the equation above and taking the logarithm, similar to equation (6), we get:</p>

$$\log q(\boldsymbol{x}) \sim -\frac{1}{2}\sum_{i=1}^D \frac{\boldsymbol{f}_i^2(\boldsymbol{x})}{\boldsymbol{\sigma}_i^2} - \sum_{i=1}^D \log \boldsymbol{\sigma}_i \tag{17}$$

<p>Comparing with equation (15), we have $\boldsymbol{s}_i=1/\boldsymbol{\sigma}_i$. Thus, the scaling transformation layer is equivalent to making the prior distribution's variance (standard deviation) a training parameter. If the variance is small enough, we can consider the manifold represented by that dimension as collapsed to a point, reducing the overall dimensionality of the manifold and implying the possibility of dimensionality reduction.</p>

<h3>Feature Decoupling</h3>

<p>When we choose a prior distribution with independent Gaussian components, besides the convenience of sampling, what other benefits are there?</p>

<p>In a flow model, $\boldsymbol{f}^{-1}$ is the generative model for sampling, while $\boldsymbol{f}$ is the encoder. But unlike autoencoders in traditional neural networks that "force low-dimensional reconstruction of high-dimensional data to extract effective information," flow models are completely invertible, so there's no information loss. Then what is the value of this encoder?</p>

<p>This relates to the question: "What are good features?" In real life, we often abstract dimensions to describe things, such as "height," "weight," "beauty," "wealth," etc. The characteristic of these dimensions is: "When we say someone is tall, they aren't necessarily fat or thin, nor are they necessarily rich or poor." In other words, there are few necessary connections between these features. Otherwise, these features would be redundant. Thus, for good features, ideally, each dimension should be independent of the others, achieving feature decoupling so that each dimension has its own independent meaning.</p>

<p>Thus, we can understand the advantage of "the prior distribution being a Gaussian distribution with independent components." Due to the independence of the components, we have reason to say that when we use $\boldsymbol{f}$ to encode original features, the various dimensions of the output encoded features $\boldsymbol{z}=\boldsymbol{f}(\boldsymbol{x})$ are decoupled. The full name of NICE is Non-linear Independent Components Estimation, which carries this meaning. Conversely, due to the independence of each dimension of $\boldsymbol{z}$, theoretically, when we change a single dimension, we can see how the generated image changes with that dimension, thereby discovering the meaning of that dimension.</p>

<p>Similarly, we can perform interpolation (weighted average) on the encodings of two images to obtain a naturally transitioning generated sample, which is fully embodied in the later-developed Glow model. However, since we only performed MNIST experiments, we won't specifically demonstrate this point here.</p>

<h2>Experiments</h2>

<p>Here we reproduce the MNIST experiment from the NICE paper using Keras.</p>

<h3>Model Details</h3>

<p>Let's summarize the various parts of the NICE model. The NICE model is a type of flow model composed of multiple additive coupling layers, each as in (7) with its inverse as in (9). Before coupling, the input dimensions need to be reversed to mix the information thoroughly. The final layer needs a scaling transformation layer, and the final loss is the negative of equation (15).</p>

<p>The additive coupling layer needs to divide the input into two parts. NICE uses interleaved partitioning: even indices are the first part, and odd indices are the second part. Each $\boldsymbol{m}(\boldsymbol{x})$ is simply implemented using multi-layer fully connected layers (5 hidden layers, each with 1000 nodes, ReLU activation). In NICE, 4 additive coupling layers are coupled in total.</p>

<p>For input, we compress the original 0-255 image pixels to the 0-1 range (dividing by 255) and then add uniform noise from the range $[-0.01, 0]$. Adding noise effectively prevents overfitting and improves generated image quality. It can also be seen as a measure to mitigate the dimensional wastage problem, because technically MNIST images can't fill 784 dimensions, but adding noise increases the dimensionality.</p>

<p>Readers might wonder why the noise interval is $[-0.01, 0]$ instead of $[0, 0.01]$ or $[-0.005, 0.005]$? In fact, from the loss perspective, various noises are similar (including changing the uniform distribution to a Gaussian distribution). However, after adding noise, theoretically, the generated images will also have noise, which is not what we want. Adding negative noise makes the final generated pixels slightly biased towards the negative range, so I can use a clip operation to remove some of the noise. This is just a small (though not particularly critical) trick specifically for MNIST.</p>

<h3>Reference Code</h3>

<p>Here is my reference implementation using Keras: <br>
<a href="https://github.com/bojone/flow/blob/master/nice.py">https://github.com/bojone/flow/blob/master/nice.py</a> <br>
In my experiments, it reaches optimal performance within 20 epochs, with one epoch taking 11s (GTX1070 environment). The final loss is approximately -2200.</p>

<p>Compared to the original paper's implementation, some changes were made here. For the additive coupling layer, I used equation (9) for the forward pass and (7) for its inverse. Since $\boldsymbol{m}(\boldsymbol{x})$ uses ReLU activation, and we know ReLU is non-negative, there's a difference between these two choices. Because the forward pass is the encoder and the inverse pass is the generator, choosing (7) as the inverse makes the generative model more likely to produce positive numbers, which aligns with the image we want to generate, as we need pixels in the 0-1 range.</p>

<figure>
  <img src="https://kexue.fm/usr/uploads/2018/08/4260905445.png" alt="Digit samples generated by NICE (trained without noise)">
  <figcaption>Digit samples generated by the NICE model (trained without noise)</figcaption>
</figure>

<figure>
  <img src="https://kexue.fm/usr/uploads/2018/08/33742461.png" alt="Digit samples generated by NICE (trained with negative noise)">
  <figcaption>Digit samples generated by the NICE model (trained with negative noise)</figcaption>
</figure>

<h3>Annealing Parameters</h3>

<p>Although we ultimately hope to sample random numbers from a standard normal distribution to generate samples, in reality, for a trained model, the ideal sampling variance isn't necessarily 1, but fluctuates around 1—generally a bit smaller than 1. The standard deviation of the final sampled normal distribution is called the annealing parameter. For example, in the reference implementation above, we chose 0.75 as the annealing parameter, which visually yields the best generation quality.</p>

<h2>Summary</h2>

<p>The NICE model is quite huge. According to the above model, the number of parameters is approximately $4 \times 5 \times 1000^2 = 2 \times 10^7$. Twenty million parameters just to train an MNIST generative model is quite exaggerated~</p>

<p>NICE as a whole is quite simple and brute-force. First, additive coupling itself is relatively simple. Second, the $\boldsymbol{m}$ part of the model simply uses huge fully connected layers without integrating tricks like convolution. Therefore, there is still much room for exploration. Real NVP and Glow are two improved versions, and we will talk about their stories later.</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="translation_5776.html" style="color: #005fcc;">https://kexue.fm/archives/5776</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
