
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    tags: 'ams',
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    packages: {'[+]': ['ams']}
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
    <nav style="margin-bottom: 1.5em;">
    <a href="../index.html" style="display: inline-flex; align-items: center; color: #555; text-decoration: none; font-size: 0.95em;">
        <span style="margin-right: 0.3em;">&larr;</span> Back to Index
    </a>
</nav>

    <h1><a href="https://kexue.fm/archives/8295">P-tuning: Automatically Constructing Templates to Release the Potential of Language Models</a></h1>
    <p>By 苏剑林 | April 03, 2021</p>

    <p>In a previous article, <a href="translation_7764.html">"Is GPT-3 Necessary? No, BERT's MLM Model Can Also Do Small-Shot Learning,"</a> we introduced a method called Pattern-Exploiting Training (PET). By combining manually constructed templates with BERT's MLM (Masked Language Model), it can achieve excellent results in zero-shot, small-shot, and even semi-supervised learning. This approach is elegant because it unifies the pre-training task with downstream tasks. However, manually constructing these templates can sometimes be difficult, and the effectiveness of different templates varies greatly. If templates could be automatically constructed using a small number of samples, it would be highly valuable.</p>

    <p>A recent paper on Arxiv, <a href="https://papers.cool/arxiv/2103.10385">"GPT Understands, Too,"</a> proposed a method called P-tuning, which successfully realizes the automatic construction of templates. Not only that, but with the help of P-tuning, GPT's performance on SuperGLUE exceeded that of BERT models of the same class for the first time. This overturns the long-held conclusion that "GPT is not good at NLU" (Natural Language Understanding), which is the reason for the paper's title.</p>

    <h2>What is a Template</h2>

    <p>The main idea of PET is to use templates (often called Patterns or Prompts) composed of natural language to transform a downstream task into a cloze task. This allows a BERT MLM model to be used for prediction. For example, the image below shows sentiment classification and topic classification using conditional prefixes:</p>

    <p>
        <a href="https://kexue.fm/usr/uploads/2021/04/957788384.png">
            <img src="https://kexue.fm/usr/uploads/2021/04/957788384.png" alt="Translating sentiment classification to MLM task via specific templates" />
        </a>
        <br>
        <em>Translating sentiment classification to an MLM task via specific templates</em>
    </p>

    <p>
        <a href="https://kexue.fm/usr/uploads/2021/04/2064695169.png">
            <img src="https://kexue.fm/usr/uploads/2021/04/2064695169.png" alt="Translating news classification to MLM task via specific templates" />
        </a>
        <br>
        <em>Translating news classification to an MLM task via specific templates</em>
    </p>

    <p>Of course, this scheme is not only limited to MLM models; using unidirectional language models (LM) like GPT is also straightforward:</p>

    <p>
        <a href="https://kexue.fm/usr/uploads/2021/04/2581387139.png">
            <img src="https://kexue.fm/usr/uploads/2021/04/2581387139.png" alt="Translating sentiment classification to LM task via specific templates" />
        </a>
        <br>
        <em>Translating sentiment classification to an LM task via specific templates</em>
    </p>

    <p>
        <a href="https://kexue.fm/usr/uploads/2021/04/3605052854.png">
            <img src="https://kexue.fm/usr/uploads/2021/04/3605052854.png" alt="Translating news classification to LM task via specific templates" />
        </a>
        <br>
        <em>Translating news classification to an LM task via specific templates</em>
    </p>

    <p>However, since language models decode from left to right, the prediction part must be placed at the end of the sentence (although categorical prefixes can be added, the predicted portion remains at the end).</p>

    <p>In a sense, these templates act as "probes" for the language model. We can extract specific knowledge from the language model through these templates, achieving good zero-shot effects. Combined with a small number of labeled samples, the performance can be further improved, as discussed in detail in <a href="translation_7764.html">"Is GPT-3 Necessary? No, BERT's MLM Model Can Also Do Small-Shot Learning."</a></p>

    <p>However, as mentioned, for some tasks, constructing templates manually is not easy. We cannot easily determine the quality of a template, and the difference in performance between different models can be massive. In such cases, manually labeling a few samples might be easier than constructing a template. Therefore, how to automatically build a template based on existing labeled samples has become a problem worth studying.</p>

    <h2>P-tuning</h2>

    <p>P-tuning re-examines the definition of a template and abandons the conventional requirement that "templates must consist of natural language." It converts the construction of templates into a continuous parameter optimization problem, which is simple yet effective.</p>

    <h3>Rethinking Templates</h3>

    <p>First, let's think about "what a template is." Intuitively, a template is a prefix/suffix composed of natural language. Through these templates, we align the downstream task with the pre-training task, allowing more full utilization of the original pre-trained model and resulting in better zero-shot and small-shot learning.</p>

    <p>But wait, do we really care if the template is made of "natural language"?</p>

    <p>Not really. Essentially, we don't care what the template looks like; we only need to know which tokens it consists of, where to insert them, whether they help complete our downstream task after insertion, and what the candidate space for the output is. Whether the template is natural language or not has no impact on us. The "natural language" requirement is only to better achieve "consistency," but it is not mandatory. Thus, P-tuning considers templates of the following form:</p>

    <p>
        <a href="https://kexue.fm/usr/uploads/2021/04/2868831073.png">
            <img src="https://kexue.fm/usr/uploads/2021/04/2868831073.png" alt="P-tuning uses [unused*] tokens directly to build templates" />
        </a>
        <br>
        <em>P-tuning directly uses [unused*] tokens to build templates, ignoring the natural language aspect of the template.</em>
    </p>

    <p>Here, [u1] to [u6] represent the <code>[unused1]</code> to <code>[unused6]</code> tokens in the BERT vocabulary. That is, several tokens never seen before are used to form the template. The number of tokens is a hyperparameter, and whether they are placed at the beginning or the end can also be adjusted. Then, to make the "template" work, we use labeled data to solve for this template.</p>

    <h3>How to Optimize</h3>

    <p>At this point, depending on the amount of labeled data, we discuss two scenarios.</p>

    <p><strong>First, the labeled data is scarce.</strong> In this case, we fix the weights of the entire model and only optimize the Embeddings of the [u1] to [u6] tokens. In other words, we are essentially learning six new Embeddings that act as a template. Since the model weights are almost entirely fixed, training is very fast. Because there are so few parameters to learn, even with very few labeled samples, the template can be learned without easy overfitting.</p>

    <p><strong>Second, the labeled data is sufficient.</strong> In this case, if we still followed the first scenario, underfitting would occur because the six tokens provide too few optimizable parameters. Therefore, we can open all weights for fine-tuning. The experiments in the original paper on SuperGLUE were done this way. Readers might think: What is the difference between this and directly adding a full connection layer for fine-tuning? The original paper's results show that this approach works better, likely because it is more consistent with the pre-training task.</p>

    <p>
        <a href="https://kexue.fm/usr/uploads/2021/04/2403854480.png">
            <img src="https://kexue.fm/usr/uploads/2021/04/2403854480.png" alt="Performance of P-tuning on SuperGLUE" />
        </a>
        <br>
        <em>Performance of P-tuning on SuperGLUE</em>
    </p>

    <p>Furthermore, in the example above, target tokens such as "Very" or "Sports" are manually selected. Can they also be replaced by [unused*] tokens? The answer is yes, but it also falls into two cases: 1. When labeled data is scarce, manually selecting appropriate target tokens often works better; 2. When labeled data is sufficient, using [unused*] for target tokens works better because the model's optimization space is larger.</p>

    <h3>Enhancing Correlation</h3>

    <p>In the original paper, P-tuning doesn't just randomly initialize several new tokens and train them directly. Instead, these Embeddings are calculated through a small LSTM model, and this LSTM model is made learnable. What's the benefit of this extra step? The original paper suggests that token representations appearing in an LSTM have stronger correlations, which to some extent makes them more like "natural language" (since natural language tokens are not independent). Additionally, it prevents falling into local optima. I confirmed with the author on GitHub (refer <a href="https://github.com/THUDM/P-tuning/issues/5">here</a>) that the difference in effect is that the LSTM approach allows the model to converge faster and achieve better results.</p>

    <p>However, adding an LSTM feels a bit awkward and slightly complicates implementation. According to the author, the LSTM helps the template tokens become (to some extent) closer to natural language. But this doesn't necessarily require an LSTM, and even if an LSTM is used, it might not achieve this. I believe a more natural method is that while training for the downstream task, we should not only predict the target token (e.g., "Very" or "News") but also predict other tokens simultaneously.</p>

    <p>For example, if it's an MLM model, randomly mask other tokens for prediction as well. If it's an LM model, predict the complete sequence rather than just the target word. The reasoning is: since our MLM/LM are pre-trained on natural language, we (perhaps overconfidently) believe that sequences that can be reconstructed well must be close to natural language. Therefore, adding such auxiliary training objectives can also make the model closer to natural language. My testing shows that adding such auxiliary objectives does improve performance compared to only optimizing the downstream task objective.</p>

    <h2>Experiments and Effects</h2>

    <p>As the saying goes, "talk is cheap, show me the code." It's time for the experiments. Here, I'll share the experimental results of P-tuning, including my implementation logic and experimental results on Chinese tasks.</p>

    <h3>Stopped Gradients</h3>

    <p>What is the best way to implement the P-tuning algorithm? If all weights are released for training, it is simple and no different from ordinary BERT fine-tuning. The key is how to implement "optimizing only a few tokens" in a small-shot scenario.</p>

    <p>There are several methods, such as re-constructing an Embedding layer for the tokens to be optimized, concatenating it with the BERT Embedding layer, and then only releasing weights for the new Embedding layer during training. But this requires significant changes to the original code. The best way is to minimize code changes so that it is almost transparent to the user. To this end, I devised a scheme to modify the <code>Embedding</code> layer using <code>stop_gradient</code>, roughly as follows:</p>

<pre><code>class PtuningEmbedding(Embedding):
    """New Embedding layer that optimizes only specific Tokens"""
    def call(self, inputs, mode='embedding'):
        embeddings = self.embeddings
        embeddings_sg = K.stop_gradient(embeddings)
        mask = np.zeros((K.int_shape(embeddings)[0], 1))
        mask[1:9] += 1  # Only optimize tokens with ids 1 to 8
        self.embeddings = embeddings * mask + embeddings_sg * (1 - mask)
        return super(PtuningEmbedding, self).call(inputs, mode)
</code></pre>

    <p>After a variable passes through the <code>stop_gradient</code> operator, its gradient is zero during backpropagation, but forward propagation remains unchanged. Therefore, in the code above, the forward propagation results won't change, but when calculating gradients during backpropagation, the gradients of the tokens controlled by the <code>mask</code> will be non-zero, while the gradients of all other tokens will be zero. This achieves updating only specific tokens.</p>

    <p>The complete code is available at:</p>
    <blockquote><strong>GitHub: <a href="https://github.com/bojone/P-tuning">https://github.com/bojone/P-tuning</a></strong></blockquote>

    <p>By the way, the original paper also released code:</p>
    <blockquote><strong>GitHub: <a href="https://github.com/THUDM/P-tuning">https://github.com/THUDM/P-tuning</a></strong></blockquote>

    <h3>Testing and Effects</h3>

    <p>I previously shared the original author's experimental results on SuperGLUE, which showed that with P-tuning: 1. The performance of GPT and BERT improved significantly compared to direct fine-tuning; 2. GPT's performance could even exceed BERT's. This indicates that GPT not only has NLG (Natural Language Generation) capabilities but also NLU capabilities, essentially "squeezing" out GPT's potential. Of course, BERT also improved with P-tuning, indicating that P-tuning's release of language model potential is relatively universal.</p>

    <p>The original paper has rich experiments, and I recommend readers read it carefully; it is very rewarding. Notably, in Table 2 of the final column, when the pre-trained model is large enough, our devices might not be able to fine-tune the entire model. P-tuning can choose to optimize only a few token parameters, which significantly reduces the memory and computing power required for optimization. Thus, <strong>P-tuning actually gives us a way to utilize large-scale pre-trained models within limited computing power.</strong></p>

    <p>
        <a href="https://kexue.fm/usr/uploads/2021/04/301304097.png">
            <img src="https://kexue.fm/usr/uploads/2021/04/301304097.png" alt="Effect of P-tuning across various language model sizes" />
        </a>
        <br>
        <em>Effect of P-tuning across various language model sizes</em>
    </p>

    <p>Of course, my consistent view is that "an algorithm not tested on Chinese has no soul." Therefore, I also briefly tested it on Chinese tasks. The test task is consistent with <a href="translation_7764.html">"Is GPT-3 Necessary? No, BERT's MLM Model Can Also Do Small-Shot Learning,"</a> involving small-shot sentiment classification. The test models included BERT and GPT, with their respective candidate templates shown below:</p>

    <p>
        <a href="https://kexue.fm/usr/uploads/2021/04/3167211277.png">
            <img src="https://kexue.fm/usr/uploads/2021/04/3167211277.png" alt="BERT+P-tuning template for Chinese sentiment classification" />
        </a>
        <br>
        <em>The "BERT + P-tuning" template I used for Chinese sentiment classification</em>
    </p>

    <p>
        <a href="https://kexue.fm/usr/uploads/2021/04/455411321.png">
            <img src="https://kexue.fm/usr/uploads/2021/04/455411321.png" alt="GPT+P-tuning template for Chinese sentiment classification" />
        </a>
        <br>
        <em>The "GPT + P-tuning" template I used for Chinese sentiment classification</em>
    </p>

    <p>Note that for LM models, introducing a prefix is very important; the effect is significantly worse when only a suffix is introduced. For MLM models, the prefix effect is also generally better than the suffix. The overall results are in the table below:</p>

    <p>
        \[
        \begin{array}{c|cc}
        \hline
        & \text{Validation Set} & \text{Test Set} \\
        \hline
        \text{Small-shot Direct Fine-tuning} & 88.93\% & 89.34\% \\
        \text{VAT Semi-supervised Learning} & 89.83\% & 90.37\% \\
        \hline
        \text{PET Zero-shot} & 85.17\% & 84.27\% \\
        \text{PET Unsupervised} & 88.05\% & 87.53\% \\
        \text{PET Small-shot} & 89.29\% & 89.18\% \\
        \text{PET Semi-supervised} & 90.09\% & 89.76\% \\
        \hline
        \text{BERT + P-tuning} & 89.81\% & 89.75\% \\
        \text{GPT + P-tuning} & 89.30\% & 88.51\% \\
        \hline
        \end{array}
        \]
    </p>

    <p>Among these, "Small-shot" uses only a "small number of labeled samples," "Unsupervised" uses "a large amount of unlabeled samples," "Semi-supervised" uses "a small number of labeled samples + a large amount of unlabeled samples," and "P-tuning" are all small-shot experiments. PET tasks report the best results from manual templates, although there were worse ones. From a small-shot perspective, P-tuning indeed achieved the best results. From a template construction perspective, P-tuning is indeed much better than manually constructed templates. From the model perspective, P-tuning can indeed bring GPT's classification performance close to BERT, revealing the fact that GPT also has strong NLU capabilities.</p>

    <h2>Further Understanding</h2>

    <p>This section introduces my further thoughts on P-tuning, aiming to understand it from multiple dimensions.</p>

    <h3>Discrete vs. Continuous</h3>

    <p>Before P-tuning, there were already some efforts in automatic template construction, such as <a href="https://papers.cool/arxiv/1911.12543">"How Can We Know What Language Models Know?"</a> and <a href="https://papers.cool/arxiv/2010.15980">"AutoPrompt: Eliciting Knowledge from Language Models with Automatically Generated Prompts."</a> However, they searched for natural language templates in a discrete space, so their effectiveness was limited and did not yield particularly prominent results.</p>

    <p>In contrast, P-tuning abandoned the requirement of "natural language," turning it into a continuous parameter problem that can be solved by simple gradient descent. The result is better. At the same time, this change means P-tuning highlights the essence of a template—that the key lies in how it's used, not what it consists of—giving a sense of "extracting the essence" that is indeed commendable.</p>

    <p>(Note: As pointed out by reader <a href="https://kexue.fm/archives/8295/comment-page-1#comment-16015">@brotherb</a>, the paper <a href="https://papers.cool/arxiv/2101.00190">"Prefix-Tuning: Optimizing Continuous Prompts for Generation"</a> published at the beginning of the year is quite close to P-tuning. Both designed non-natural language templates, though Prefix-Tuning mainly focuses on NLG applications while P-tuning focuses more on NLU.)</p>

    <h3>Adapter</h3>

    <p>We can also understand P-tuning from the perspective of an Adapter. Shortly after BERT was released, Google proposed a fine-tuning method called Adapter in the paper <a href="https://papers.cool/arxiv/1902.00751">"Parameter-Efficient Transfer Learning for NLP."</a> It doesn't fine-tune the entire model directly. Instead, it fixes the original BERT weights and adds some residual modules on top of BERT, optimizing only these residual modules. Since these modules have fewer parameters, the fine-tuning cost is lower. The idea of the Adapter actually originates from CV's <a href="https://papers.cool/arxiv/1705.08045">"Learning multiple visual domains with residual adapters."</a> However, it hasn't been seen much in the last two years, perhaps because while it improves training speed, it decreases prediction speed and often results in some loss of accuracy.</p>

    <p>In P-tuning, if we don't treat the new tokens as "templates" but as part of the model, then P-tuning is actually a type of Adapter approach. It also fixes the original model weights and inserts new optimizable parameters, updating only these new parameters. The difference is that the new parameters are inserted into the Embedding layer. Therefore, from this perspective, P-tuning and Adapters share many similarities.</p>

    <h3>Why is it Effective?</h3>

    <p>Now, there's another question worth considering: Why is P-tuning better? For example, with full data, everyone opens all weights, yet P-tuning is still better than direct fine-tuning. Why?</p>

    <p>In fact, readers who ask this question are likely "used to" the practice of adding a full connection layer on top of BERT for fine-tuning. Obviously, whether it is PET or P-tuning, they are closer to the pre-training task, while the practice of adding a full connection layer is not as close. So in a sense, the effectiveness of P-tuning is more "obvious," and it is the effectiveness of adding a full connection layer that should be questioned.</p>

    <p>Last year, the paper <a href="https://papers.cool/arxiv/2010.03648">"A Mathematical Exploration of Why Language Models Help Solve Downstream Tasks"</a> attempted to answer this. The general line of reasoning is:</p>

    <ol>
        <li>The pre-trained model is a certain type of language model task;</li>
        <li>Downstream tasks can be expressed as a special case of this language model;</li>
        <li>When the output space is finite, it approximates adding a full connection layer;</li>
        <li>Therefore, fine-tuning with an added full connection layer is effective.</li>
    </ol>

    <p>As can be seen, the paper's main assumption is point 2, which effectively assumes that downstream tasks can be expressed in a format similar to PET and then proceeds to prove it. This further illustrates that PET and P-tuning are more natural ways to use pre-trained models. Fine-tuning by adding a full connection layer is just a corollary of them. In other words, PET and P-tuning are schemes that return to the essence, which is why they are more effective.</p>

    <h2>Simple Summary</h2>

    <p>This article introduced P-tuning, an automatic template construction method. Through templates, we can extract knowledge from language models and complete tasks such as zero-shot and small-shot learning with often superior effects. With P-tuning, GPT can achieve excellent NLU results, even surpassing BERT on SuperGLUE. Additionally, P-tuning provides an effective solution for utilizing large pre-trained models under limited computing resources.</p>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/8295" style="color: #005fcc;">https://kexue.fm/archives/8295</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
