
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    tags: 'ams',
    packages: {'[+]': ['ams']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/6671">Lightweight Information Extraction Model Based on DGCNN and Probabilistic Graphs</a></h1>

<p>By 苏剑林 | June 03, 2019</p>

<p><strong>Background:</strong> A few months ago, Baidu held the "<a href="http://lic2019.ccf.org.cn/">2019 Language and Intelligence Technology Competition</a>," which consisted of three tracks. I was quite interested in the "Information Extraction" track, so I signed up. After two months of intense work, the competition has finally concluded, and the final results have been announced. Starting from a total lack of knowledge about Information Extraction, I explored some experiences in supervised learning for information extraction through study and research during this competition, which I would like to share here.</p>

<p><img src="https://kexue.fm/usr/uploads/2019/06/248359504.png" alt="Information Extraction Track: 'Scientific Spaces Team' ranked 7th in the final test results" title="Scientific Spaces Team Ranking" /></p>

<p>I ranked 7th on the final test set, with an F1 score of 0.8807 (Precision 0.8939, Recall 0.8679), about 0.01 behind the first place. From a competition perspective, this result is not exceptionally outstanding, but I believe the model has several innovative features, such as a self-designed extraction structure, CNN+Attention (making it fast enough), and the absence of pre-trained models like BERT. I believe this has certain reference value for both academic research and engineering applications of information extraction.</p>

<h2>Basic Analysis</h2>

<blockquote>
<p>Information Extraction (IE) is a text processing technology that extracts factual information such as entities, attributes, relations, and events from natural language text. It is an important foundation for AI applications such as information retrieval, intelligent question answering, and intelligent dialogue, and has long received extensive attention from the industry. ... This competition will provide the industry's largest schema-based Chinese information extraction dataset (SKE), aiming to provide an academic exchange platform for researchers, further enhance the research level of Chinese information extraction technology, and promote the development of related AI applications.
<br />—— From the official competition website</p>
</blockquote>

<h3>Task Description</h3>

<p>The information extraction task this time is, more accurately, a "triplet" extraction task. Sample data is as follows:</p>

<blockquote>
<p>{
<br />&emsp;&emsp;"text": "Jiuxuanzhu is a novel serialized on the Zongheng Chinese website, authored by Longma",
<br />&emsp;&emsp;"spo_list": [
<br />&emsp;&emsp;&emsp;&emsp;["Jiuxuanzhu", "Serialization Website", "Zongheng Chinese Website"],
<br />&emsp;&emsp;&emsp;&emsp;["Jiuxuanzhu", "Author", "Longma"]
<br />&emsp;&emsp;]
<br />}
</p>
</blockquote>

<p>The goal is to input a sentence and output all triplets contained in that sentence. A triplet is in the form of $(s, p, o)$, where $s$ is the subject (main entity), a fragment of the query; $o$ is the object (target entity), also a fragment of the query; and $p$ is the predicate, the relationship between the two entities. The competition pre-defined all candidate predicates (schema, a total of 50 candidates). In general, $(s, p, o)$ can be understood as "$s$'s $p$ is $o$".</p>

<p>Baidu provided nearly 200,000 labeled data points with high annotation quality. (Please do not ask me for data; I am not responsible for sharing the dataset. It is said the dataset will be publicly released later at <a href="http://ai.baidu.com/broad/download">http://ai.baidu.com/broad/download</a>.)</p>

<h3>Sample Characteristics</h3>

<p>Clearly, this is a "<strong>one-to-many</strong>" extraction + classification task. Through manual observation of the samples, the characteristics are as follows:</p>

<blockquote>
<p>1. $s$ and $o$ are not necessarily words identified by word segmentation tools. Therefore, the query must be labeled at the character level to extract the correct $s$ and $o$. Considering that word segmentation might cut boundaries incorrectly, character-based input should be used for labeling;<br />
2. In most samples, the extraction result is in the form of "one $s$, multiple $(p, o)$". For example, "The stars of 'Wolf Warrior' include Wu Jing and Yu Nan," then extract "(Wolf Warrior, Starring, Wu Jing)" and "(Wolf Warrior, Starring, Yu Nan)";<br />
3. Samples with "multiple $s$, one $(p, o)$" or even "multiple $s$, multiple $(p, o)$" also account for a certain proportion. For example, "The stars of 'Wolf Warrior' and 'Wolf Warrior 2' are both Wu Jing," then extract "(Wolf Warrior, Starring, Wu Jing)" and "(Wolf Warrior 2, Starring, Wu Jing)";<br />
4. The same pair $(s, o)$ might correspond to multiple $p$. For example, "Wu Jing is both the star and director of 'Wolf Warrior'," then extract "(Wolf Warrior, Starring, Wu Jing)" and "(Wolf Warrior, Director, Wu Jing)";<br />
5. In extreme cases, $s$ and $o$ might overlap. For example, "'Autobiography of Lu Xun' was published by Jiangsu Literature and Art Publishing House." Strictly speaking, besides extracting "(Autobiography of Lu Xun, Publisher, Jiangsu Literature and Art Publishing House)", one should also extract "(Autobiography of Lu Xun, Author, Lu Xun)".</p>
</blockquote>

<h2>Model Design</h2>

<p>In the "<a href="#Sample Characteristics">Sample Characteristics</a>" section, we listed 5 basic observations. Except for the 5th point, which is somewhat extreme, the other 4 points are common characteristics of information extraction tasks. Before starting, I briefly surveyed current mainstream information extraction models and found that no single model could handle all these 5 characteristics well. Therefore, I abandoned existing extraction approaches and designed a new extraction scheme based on probabilistic graph ideas, utilizing CNN+Attention for efficiency.</p>

<h3>Probabilistic Graph Thinking</h3>

<p>For example, a baseline approach is to first perform entity recognition and then classify relations between the recognized entities. However, this approach does not handle cases where the same $(s, o)$ corresponds to multiple $p$ well, and suffers from sampling efficiency issues. Another approach is to treat it as a holistic sequence labeling task, referring to the paper <a href="http://arxiv.org/abs/1706.05075">"Joint Extraction of Entities and Relations Based on a Novel Tagging Scheme"</a>. However, this design doesn't handle multiple $s$ and multiple $o$ effectively, requiring an ugly "proximity principle." There are also Reinforcement Learning methods... but without exception, none of these methods solve the problem of overlapping $s$ and $o$.</p>

<p>It seems incredible to me that these basic problems in Information Extraction haven't been resolved after so many years. My principle is: discard inelegant designs. So, I decided to abandon all extraction ideas I knew and design a new scheme. For this, I considered a probabilistic graph approach similar to Seq2Seq.</p>

<p>Anyone who has worked with Seq2Seq knows that the decoder actually models:
\begin{equation}P(y_1,y_2,\dots,y_n|x)=P(y_1|x)P(y_2|x,y_1)\dots P(y_n|x,y_1,y_2,\dots,y_{n-1})\end{equation}
During prediction, it first predicts the first word via $x$, then predicts the second word assuming the first is known, and so on, until an end token appears. Why not apply this logic to triplet extraction? We consider:
\begin{equation}P(s, p, o) = P(s) P(o|s)P(p|s,o)\end{equation}
That is, we can first predict $s$, then pass $s$ in to predict the corresponding $o$ for that $s$, and then pass $s$ and $o$ in to predict relation $p$. In practice, the prediction of $o$ and $p$ can be combined into one step. So the total process takes only two steps: <strong>first predict $s$, then pass $s$ in to predict all corresponding $o$ and $p$</strong>.</p>

<p>Theoretically, the above model only extracts a single triplet. To handle cases with multiple $s$, multiple $o$, or even multiple $p$, we use a "semi-pointer-semi-annotation" structure (essentially replacing Softmax with Sigmoid, also introduced in <a href="translation_5409.html">"DGCNN: A CNN-based Reading Comprehension QA Model"</a>). We also use Sigmoid instead of Softmax for relation classification.</p>

<p>With this design, the final model can decode very simply and efficiently, completely covering the 5 characteristics listed in "<a href="#Sample Characteristics">Sample Characteristics</a>."</p>

<blockquote>
<p><strong>Note 1:</strong><br />
Why not predict $o$ first and then $s$ and its corresponding $p$?<br />
This is because in the second step, we need to sample and pass the result of the first step (and only sample one). As previously analyzed, in most samples, the number of $o$ is greater than the number of $s$. If we predict $s$ first, sampling $s$ for the second step is more likely to be sufficient (because $s$ is scarce). Conversely, sampling $o$ would be harder to cover fully (because $o$ can be numerous). Readers will realize this more clearly as they continue reading.</p>
</blockquote>

<blockquote>
<p><strong>Note 2:</strong><br />
Looking at recent arXiv papers, I found that conceptually, this extraction design is similar to the article:<br />
<a href="https://papers.cool/arxiv/1905.05529">"Entity-Relation Extraction as Multi-Turn Question Answering"</a>.</p>
</blockquote>

<h3>Overall Structure</h3>

<p>Now that we've explained the extraction logic—recognizing $s$ first, then passing $s$ to recognize $p$ and $o$ simultaneously—let's introduce the overall model structure.</p>

<p>To ensure efficiency, the model uses a CNN+Attention structure (plus a short-sequence LSTM; since the sequence is short, it doesn't hurt efficiency). It avoids slow pre-trained models like BERT. The CNN follows the previously introduced <a href="translation_5409.html">DGCNN</a>, and the Attention used is the <a href="translation_4765.html">Self Attention</a> promoted by Google. The overall structure is shown in the figure below.</p>

<p><img src="https://kexue.fm/usr/uploads/2019/06/2836282741.png" alt="Schematic of this IE model. The input sentence is 'Wu Jing, the star of Wolf Warrior 2, was born in 1974', and the extracted triplets are '(Wolf Warrior 2, Starring, Wu Jing)' and '(Wu Jing, Birth Date, 1974)'." title="Model Structure" /></p>

<p>Specifically, the processing flow of the model is:</p>
<blockquote>
<p>1. Input character ID sequence, get corresponding character vectors via character-word mixed Embedding (detailed later), and add Position Embedding;<br />
2. Input the "character-word-position Embedding" into 12 layers of DGCNN for encoding, obtaining an encoded sequence (denoted as $\boldsymbol{H}$);<br />
3. Pass $\boldsymbol{H}$ through one layer of Self-Attention, then concatenate the output with prior features (optional, detailed later);<br />
4. Pass the concatenated result through CNN and Dense layers, using a "semi-pointer-semi-annotation" structure to predict the start and end positions of $s$;<br />
5. During training, randomly sample one labeled $s$ (during prediction, iterate through all predicted $s$). Pass the sub-sequence of $\boldsymbol{H}$ corresponding to this $s$ into a BiLSTM to get an encoding vector for $s$. Then add relative Position Embeddings to get a vector sequence of the same length as the input sequence;<br />
6. Pass $\boldsymbol{H}$ through another layer of Self-Attention, then concatenate the result with the output of step 5 and prior features;<br />
7. Pass the concatenated result through CNN and Dense layers. For each predicate $p$, construct a "semi-pointer-semi-annotation" structure to predict the start and end positions of the corresponding $o$. This predicts $o$ and $p$ simultaneously.</p>
</blockquote>

<p>This model differs significantly from an early baseline model I open-sourced (<a href="https://github.com/bojone/kg-2019-baseline">https://github.com/bojone/kg-2019-baseline</a>).</p>

<p>Additionally, regarding two possible doubts: first, "Why only sample one $s$ in step 5?" The answer is simple: one is enough (sampling multiple is equivalent to increasing batch size), and sampling one is easier to implement. Second, "Why not use BERT?" This question is actually quite boring; I simply didn't feel like using it. I have never been very fond of BERT and hadn't explored its fine-tuning until recently. Fine-tuning BERT is less interesting, less efficient, and doesn't reflect individual value as much. (I did try a BERT approach a few days before the deadline, which I might share in a later article.)</p>

<h2>Model Details</h2>

<p>Having introduced the design thinking and overall structure, let's look at implementation details.</p>

<h3>Word-Character Mixed Embedding</h3>

<p>As mentioned, to minimize boundary errors, we use character-level labeling. However, pure character embeddings struggle to capture semantic information. A more effective way to incorporate semantics is "word-character mixed Embedding."</p>

<p>In this model, I used a <strong>self-designed word-character mixing method</strong>. First, the text sequence is input at the character level, and a character Embedding layer produces character vectors. Then, the text is segmented, and word vectors are extracted using a pre-trained Word2Vec model. To align word vectors with the character sequence, we repeat the word vector for each character in that word (number of repetitions = number of characters in the word). After obtaining the aligned word vector sequence, we transform the word vectors to the same dimension as the character vectors via a matrix and add them together. The process is illustrated below:</p>

<p><img src="https://kexue.fm/usr/uploads/2019/06/2509401649.png" alt="Illustration of the mixed word-character embedding used in this model" title="Mixed Embedding" /></p>

<p>In practice, I used pyhanlp for segmentation and trained a Word2Vec model (Skip-Gram + Negative Sampling) on 10 million Baidu Baike entries. Character vectors were randomly initialized. During training, the Word2Vec vectors remained fixed, and only the transformation matrix and character vectors were optimized. From another perspective, this fine-tunes the Word2Vec vectors using character vectors and the transformation matrix. This way, we integrate prior semantic information from pre-trained word vectors while retaining character-level flexibility.</p>

<p>In my observation, this mixed approach improves the final result by about 1% to 2% compared to pure character vectors. This improvement is consistent across other tasks I've experimented with. Different pre-trained word vector models have some impact, but it's usually less than 0.5%. I also tried <a href="https://ai.tencent.com/ailab/nlp/embedding.html">Tencent AI Lab word vectors</a> (using the first 1 million words), with similar results.</p>

<h3>Position Embedding</h3>

<p>Since the model mainly uses CNN+Attention, the encoded vector sequence lacks a strong "sense of position." For this competition's data, position information is valuable (e.g., $s$ often appears at the beginning, $o$ is often near $s$). An effective way to add position information is Position Embedding. Unlike <a href="translation_4765.html">formula-calculated Position Embeddings</a>, this model uses optimizable Position Embeddings.</p>

<p>Specifically, I set a maximum length of 512, initialized a new all-zero Embedding layer (same dimension as character vectors). Position IDs are passed in to output Position Embeddings, which are added to the mixed word-character embeddings before being passed to the DGCNN.</p>

<p>Position Embedding is also used when encoding $s$. The sampled $s$ is encoded by BiLSTM into a fixed-size vector, which is then concatenated with the original encoded sequence as a condition for predicting $o$ and $p$. However, since $o$ is more likely to be near $s$, I didn't simply copy the vector; I added a "relative position vector" indicating the current position relative to $s$ (refer to the source code for details). This relative position vector shares the same Embedding layer as the input position embedding.</p>

<h3>DGCNN</h3>

<p>DGCNN was introduced in <a href="translation_5409.html">"DGCNN: A CNN-based Reading Comprehension QA Model"</a>. It is essentially "Dilated Gated Convolution." The concept of Gated Convolution comes from <a href="https://papers.cool/arxiv/1705.03122">"Convolutional Sequence to Sequence Learning"</a>, where it's called GLU (Gated Linear Units). I replaced standard convolutions with dilated convolutions to increase the receptive field. Similar approaches appear in <a href="https://papers.cool/arxiv/1711.04352">"Fast Reading Comprehension with ConvNets"</a>.</p>

<p><img src="https://kexue.fm/usr/uploads/2018/04/1361573455.png" alt="Combining Residuals with Gated Convolutions to achieve multi-channel transmission" title="DGCNN" /></p>

<p>When input and output dimensions are the same, DGCNN can include residuals. I previously proved that DGCNN with residuals is mathematically equivalent to a dilated convolution in Highway form:
\begin{equation}\begin{aligned}\boldsymbol{Y}=&\boldsymbol{X}\otimes \Big(1-\boldsymbol{\sigma}\Big) + \text{Conv1D}_1(\boldsymbol{X}) \otimes \boldsymbol{\sigma}\\
\boldsymbol{\sigma} =& \sigma\Big(\text{Conv1D}_2(\boldsymbol{X})\Big)
\end{aligned}\end{equation}
This model uses this form of DGCNN, representing selective multi-channel information transmission.</p>

<p>The final model used 12 layers of DGCNN, with dilation rates sequence $[1, 2, 5, 1, 2, 5, 1, 2, 5, 1, 1, 1]$. That is, $[1, 2, 5]$ is repeated three times (repeatedly learning from fine to coarse granularity), followed by three layers of $[1, 1, 1]$ (fine granularity fine-tuning).</p>

<h3>Prior Features from Distant Supervision</h3>

<p>External triplet knowledge bases were not allowed in the competition. However, we can integrate all triplets from the training set into a knowledge base. For a new sentence, we can perform distant supervision searches in this knowledge base to get candidate triplets. If two entities in a sentence happen to be the $s$ and $o$ of a triplet in the knowledge base, we extract that triplet as a candidate. This way, any sentence's candidate triplets can be extracted via pure retrieval. Note that these are only candidate triplets and could all be incorrect.</p>

<p>I used these distant supervision results as features. All $s$ obtained via distant supervision are formed into a 0/1 vector (similar to the labeling structure) and concatenated to the encoding sequence before predicting $s$. Similarly, all $o$ and corresponding $p$ from distant supervision are formed into a 0/1 vector and concatenated before predicting $o$ and $p$. In training, when constructing distant supervision features, the triplets of the current sample must be excluded (simulating test set conditions).</p>

<p>In terms of effect, adding distant supervision features improved the offline validation F1 by over 2%! This was checked carefully for "data leakage." However, surprisingly, there was almost no improvement on the online test set. Since the results with and without these features differed significantly, I eventually fused the results of both types of models.</p>

<h3>Other Supplementary Modules</h3>

<p>The implementation includes additional auxiliary modules (represented by variables `pn1`, `pn2`, `pc`, `po` in the code). Theoretically, these provide "global information." `pn1` and `pn2` can be seen as global entity recognition modules, `pc` as a global relation detection module, and `po` as a global relation existence judgment. These modules are not trained separately but multiplied into the $s$ and $o$ prediction results.</p>

<p>These modules don't significantly affect the final F1 but help speed up training and feel more "reasonable" intuitively. Furthermore, when encoding $s$ after random sampling, $s$ is encoded via BiLSTM. In implementation, I uniformly interpolated the start and end IDs of $s$ to extract a fixed number (6) of vectors for the BiLSTM, avoiding the issue of variable-length $s$.</p>

<h2>Experimental Alchemy</h2>

<p>Finally, some details about the training process. Model code: <a href="https://github.com/bojone/kg-2019">https://github.com/bojone/kg-2019</a>.</p>

<p>Test environment: Python 2.7 + Keras 2.2.4 + Tensorflow 1.8.</p>

<p>If this model helps your work, please cite it (not that I expect much):</p>
<blockquote>
<p>@misc{
<br />&emsp;&emsp;jianlin2019bdkgf,
<br />&emsp;&emsp;title={A Hierarchical Relation Extraction Model with Pointer-Tagging Hybrid Structure},
<br />&emsp;&emsp;author={Jianlin Su},
<br />&emsp;&emsp;year={2019},
<br />&emsp;&emsp;publisher={GitHub},
<br />&emsp;&emsp;howpublished={\url{https://github.com/bojone/kg-2019}},
<br />}
</p>
</blockquote>

<h3>Basic Training Process</h3>

<p>For the loss function, since the "semi-pointer-semi-annotation" consists of binary classifications, I used binary cross-entropy. Note that $s$ prediction has two binary classifications, while $o$ prediction (predicting $p$ as well) has $100 = 50 \times 2$ binary classifications. Their losses are still added in a 1:1 ratio. In other words, the absolute value of $o$'s loss is 50 times $s$'s loss. This might seem counter-intuitive (one might think $s$'s weight should be larger since if $s$ is wrong, the triple is wrong), but experiments showed $s$ and $o$ are equally important. Variants like Focal Loss did not help.</p>

<p>The model used the Adam optimizer. I first trained with a learning rate of $10^{-3}$ for up to 50 epochs, loaded the best result, and continued with $10^{-4}$ until convergence. The first epoch was used for WarmUp; otherwise, it might not converge.</p>

<p>To ensure stable improvement, EMA (<a href="https://kexue.fm/archives/6575#%E6%9D%83%E9%87%8D%E6%BB%91%E5%8A%A8%E5%B9%B3%E5%9D%87">Exponential Moving Average</a>) was used with a decay rate of 0.9999.</p>

<h3>Decoding Optimization</h3>

<p>The decoding process has significant room for tuning. The "semi-pointer-semi-annotation" structure uses two Sigmoid-activated outputs for the start and end of entities. A threshold is needed to identify an entity. Generally, 0.5 is used. However, I found that setting the "start" threshold to 0.5 and the "end" threshold to 0.4 yielded the best F1.</p>

<p>Furthermore, the test set for this competition was very high quality (very clean and standardized results). In contrast, the training set had more omissions. Thus, post-processing rules were used to standardize predictions according to official specifications. In the final days, many teams improved significantly, likely by finding rules to fix predictions. This added nearly 1% F1 for me, though it's more of a competition trick than academic research.</p>

<h3>Model Averaging and Fusion</h3>

<p>Ensembling is a powerful method. For this task, I used a <strong>layered ensemble</strong> scheme.</p>

<p>As mentioned, online results with and without distant supervision features were similar, but the prediction files varied. I took the union of the two types of models. Before taking the union, I used model averaging to improve single-model accuracy. Specifically, for models without distant supervision, I performed 8-fold cross-validation (shuffling and splitting data into 8 parts) to get 8 models. I did the same for models with distant supervision.</p>

<p>After getting these 16 models, I averaged the 8 models without distant supervision (averaging the output probabilities before decoding), and did the same for the 8 models with distant supervision. This resulted in two files, each with high precision due to <strong>averaging</strong>. Finally, I took the <strong>union</strong> of these two results.</p>

<p><img src="https://kexue.fm/usr/uploads/2018/04/2421906653.png" alt="Single model fusion based on cross-validation" title="Ensemble" /></p>

<h3>Knowledge Distillation</h3>

<p>Since the test set was perfect but the training set had omissions, I used a form of knowledge distillation to reorganize the training set. First, I used the 8 models (without distant supervision) obtained from cross-validation on the original training set to predict the training set itself. If a triplet appeared in all 8 predictions but not in the original training labels, it was added. If a triplet was in the training labels but didn't appear in any of the 8 predictions, it was removed.</p>

<p>After this cleaning, the training set was much more consistent. Re-training models on this corrected set yielded nearly 1% online improvement. While this might remove some difficult training samples, it focused the model on the primary "contradictions" (knowledge distillation).</p>

<h3>Strategies for Efficiency</h3>

<p>"Efficiency" is a hallmark of this model. Even with the ensemble of 16 models, predicting the entire test set (~100k samples) took only 4 hours (could be reduced to 2 hours with a better CPU). In the competition groups, I heard many teams spent over ten hours or even several days for the final prediction.</p>

<p>Efficiency can be further improved by sacrificing a bit of precision. For example, the 12-layer DGCNN could be reduced to 6 layers with dilation sequence $[1, 2, 5, 1, 2, 5]$. Also, instead of BiLSTM, the vectors for the start and end of $s$ could be concatenated directly. Furthermore, reducing the Word2Vec vocabulary or using pure character embeddings could save more time.</p>

<p>With these changes, speed could increase by over 5 times, with a performance drop of only about 2% to 4%, depending on the trade-offs.</p>

<h2>Conclusion</h2>

<p>This article records my model design and "alchemy" experience in this competition. Before this, I knew almost nothing about Information Extraction or Knowledge Graphs, so I relied purely on intuition for model design and tuning (partly because mainstream models didn't satisfy me). I am quite satisfied with the final result and ranking. Of course, parts of the model were developed in isolation; if you find anything inappropriate, feel free to criticize. Even after this competition, I am still a novice in IE and KG, and I hope for guidance from seniors in the field.</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/6671" style="color: #005fcc;">https://kexue.fm/archives/6671</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
