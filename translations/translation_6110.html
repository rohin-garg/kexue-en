
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    tags: 'ams',
    processEscapes: true,
    packages: {'[+]': ['ams']}
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<article>
    <h1><a href="https://kexue.fm/archives/6110">RSGAN: The "Turing Test" Thought in Adversarial Models</a></h1>

    <p>By 苏剑林 | October 22, 2018</p>

    <p>Recently, I came across a very meaningful piece of work called "Relativistic GAN," abbreviated as RSGAN, from the paper <a href="https://papers.cool/arxiv/1807.00734">"The relativistic discriminator: a key element missing from standard GAN."</a> It is said that this paper even received a "like" from the GAN founder, Ian Goodfellow. This article proposes using a relative discriminator to replace the original discriminator in standard GANs, making the generator converge faster and the training more stable.</p>

    <p>Unfortunately, the original paper primarily discusses the results from training and experimental perspectives without a more in-depth analysis, leading many to feel that it is just another GAN training trick. However, in my view, RSGAN possesses a more profound meaning; it could even be seen as having pioneered a new school of GANs. Therefore, I decided to provide a basic introduction to the RSGAN model and the connotations behind it. It should be noted that, although the results are the same, the introduction process in this article has almost no overlap with the original paper.</p>

    <h2>The "Turing Test" Thought</h2>

    <h3>SGAN</h3>
    <p>SGAN is the Standard GAN. Even readers who have not researched GANs likely understand the general principle from various sources: a "counterfeiter" continuously creates fakes, attempting to fool an "appraiser"; the "appraiser" continuously improves their appraisal techniques to distinguish between real products and counterfeits. The two compete and progress together until the "appraiser" can no longer distinguish between them, at which point the "counterfeiter" retires successfully.</p>

    <p>In modeling, this process is achieved through alternating training: fix the generator and train a discriminator (a binary classification model) to output 1 for real samples and 0 for forged samples; then fix the discriminator and train the generator to make the forged samples output 1 as much as possible. This second step does not require the participation of real samples.</p>

    <h3>The Problem</h3>
    <p>However, this modeling process seems excessively demanding for the discriminator because the discriminator operates in isolation: when training the generator, real samples are not involved. Thus, the discriminator must "remember" all the attributes of real samples to guide the generator in creating more realistic ones.</p>

    <p>In actual life, we don't do it this way. As the saying goes, "there is no harm without comparison, and no progress without harm." Most of the time, we distinguish between genuine and counterfeit goods through comparison. For example, to identify a counterfeit bill, you might need to compare it with a genuine one; to identify a knock-off phone, you just need to compare it with the original; and so on. Similarly, if you want to make a counterfeit product more realistic, you need to keep the genuine product aside for continuous comparative improvement, rather than relying solely on the genuine product in your "memory."</p>

    <p>Comparison makes it easier for us to identify genuine/fake items, thereby allowing us to produce better counterfeits. In the field of Artificial Intelligence, we know the famous "Turing Test," which refers to a situation where a tester communicates with a robot and a human simultaneously without knowing which is which. If the tester cannot successfully distinguish between the human and the robot, it indicates that the robot has attained human intelligence (in a particular aspect). The "Turing Test" also emphasizes the importance of comparison: if the robot and the human are indistinguishable when mixed together, the robot has succeeded.</p>

    <p>Next, we will see that RSGAN is based on the thought of the "Turing Test": if the discriminator cannot distinguish between mixed real and fake images, then the generator has succeeded; and to generate better images, the generator also needs to rely directly on real images.</p>

    <h2>RSGAN Basic Framework</h2>

    <h3>SGAN Analysis</h3>
    <p>First, let's review the standard GAN process. Let the distribution of real samples be $\tilde{p}(x)$ and the distribution of forged samples be $q(x)$. After fixing the generator, we optimize the discriminator $T(x)$:</p>

    \begin{equation}\min_{T}-\mathbb{E}_{x\sim \tilde{p}(x)}[\log \sigma(T(x))] - \mathbb{E}_{x\sim q(x)}[\log(1-\sigma(T(x)))]\label{eq:sgan-d}\end{equation}

    <p>where $\sigma$ is the sigmoid activation function. Then, fixing the discriminator, we optimize the generator $G(z)$:</p>

    \begin{equation}\min_{G}\mathbb{E}_{x=G(z),z\sim q(z)}[h(T(x))]\label{eq:sgan-g}\end{equation}

    <p>Note that we have an undetermined function $h$ here, which we will analyze shortly.</p>

    <p>From \eqref{eq:sgan-d}, we can solve for the optimal solution of the discriminator (supplementary proof provided later):</p>

    \begin{equation}\frac{\tilde{p}(x)}{q(x)}=\frac{\sigma(T(x))}{1 - \sigma(T(x))} = e^{T(x)}\end{equation}

    <p>Substituting this into \eqref{eq:sgan-g}, we find the result to be:</p>

    \begin{equation}\min_{G}\mathbb{E}_{x=G(z),z\sim q(z)}\left[h\left(\log\frac{\tilde{p}(x)}{q(x)}\right)\right]=\min_{G}\int q(x)\left[h\left(\log\frac{\tilde{p}(x)}{q(x)}\right)\right]dx\end{equation}

    <p>Written in the form of the last equality, we can simply let $f(t)=h(\log(t))$ to see that it has the form of an $f$-divergence. That is to say, minimizing \eqref{eq:sgan-g} is equivalent to minimizing the corresponding $f$-divergence. Regarding $f$-divergences, you can refer to my previous article <a href="translation_6016.html">"Introduction to f-GAN: The Production Workshop of GAN Models."</a> The essential requirement for $f$ in $f$-divergence is that it must be a convex function, so we only need to choose $h$ such that $h(\log(t))$ is convex. The simplest case is $h(t)=-t$, corresponding to $h(\log(t))=-\log t$ being a convex function. In this case, \eqref{eq:sgan-g} becomes:</p>

    \begin{equation}\min_{G}\mathbb{E}_{x=G(z),z\sim q(z)}[-T(x)]\end{equation}

    <p>There are many similar choices. For example, when $h(t)=-\log \sigma(t)$, then $h(\log(t))=\log(1+\frac{1}{t})$ is also a convex function (for $t > 0$), so</p>

    \begin{equation}\min_{G}\mathbb{E}_{x=G(z),z\sim q(z)}[-\log\sigma(T(x))]\end{equation}

    <p>is also a reasonable choice, which is one of the commonly used generator losses in GANs. Similarly, there is $h(t)=\log(1-\sigma(t))$, and so on.</p>

    <h3>RSGAN Objectives</h3>
    <p>Here, we directly give the optimization objectives of RSGAN. After fixing the generator, we optimize the discriminator $T(x)$:</p>

    \begin{equation}\min_{T}-\mathbb{E}_{x_r\sim \tilde{p}(x), x_f\sim q(x)}[\log \sigma(T(x_r)-T(x_f))]\label{eq:rsgan-d}\end{equation}

    <p>where $\sigma$ is the sigmoid activation function. Then, fixing the discriminator, we optimize the generator $G(z)$:</p>

    \begin{equation}\min_{G}\mathbb{E}_{x_r\sim \tilde{p}(x), x_f=G(z),z\sim q(z)}[h(T(x_f) - T(x_r))]\label{eq:rsgan-g}\end{equation}

    <p>Just like SGAN, we retain a general $h$ here, and the requirements for $h$ are consistent with the previous discussion on SGAN. The choice in the original RSGAN paper is:</p>

    \begin{equation}\min_{G}-\mathbb{E}_{x_r\sim \tilde{p}(x), x_f=G(z),z\sim q(z)}[\log\sigma(T(x_f) - T(x_r))]\end{equation}

    <p>It looks like <strong>the two terms of the SGAN discriminator were replaced with a single relative discriminator</strong>. How do the analytical results change?</p>

    <h3>Theoretical Results</h3>
    <p>Using the variational method (supplementary proof provided later), we can obtain the optimal solution for \eqref{eq:rsgan-d} as:</p>

    \begin{equation}\frac{\tilde{p}(x_r)q(x_f)}{\tilde{p}(x_f)q(x_r)}=\frac{\sigma(T(x_r)-T(x_f))}{\sigma(T(x_f)-T(x_r))}=e^{T(x_r)-T(x_f)}\end{equation}

    <p>Substituting this into \eqref{eq:rsgan-g}, the result is:</p>

    \begin{equation}\begin{aligned}&\min_{G}\mathbb{E}_{x_r\sim \tilde{p}(x), x_f=G(z),z\sim q(z)}\left[h\left(\log\frac{\tilde{p}(x_f)q(x_r)}{\tilde{p}(x_r)q(x_f)}\right)\right]\\
    =&\min_{G}\iint \tilde{p}(x_r)q(x_f)\left[h\left(\log\frac{\tilde{p}(x_f)q(x_r)}{\tilde{p}(x_r)q(x_f)}\right)\right] dx_r dx_f\end{aligned}\label{eq:rsgan-gg}\end{equation}

    <p>This result is the essence of the entire RSGAN: it <strong>optimizes the $f$-divergence between $\tilde{p}(x_r)q(x_f)$ and $\tilde{p}(x_f)q(x_r)$</strong>!</p>

    <p>What does this mean? It means if I sample a real sample $x_r$ and a forged sample $x_f$, and then swap them—treating the fake as real and the real as fake—can they still be distinguished? In other words, is there a significant difference between $\tilde{p}(x_r)q(x_f)$ and $\tilde{p}(x_f)q(x_r)$?</p>

    <p>If there is no difference, it means real and fake samples are indistinguishable, training is successful. If they can still be distinguished, it means real samples are still needed to improve the forged samples. Therefore, equation \eqref{eq:rsgan-gg} is the embodiment of the "Turing Test" thought in RSGAN: once the data is shuffled, can they still be distinguished?</p>

    <h3>Model Performance Analysis</h3>
    <p>The author of the original paper also proposed RaSGAN, where 'a' stands for average, which uses the mean of the entire batch to replace a single real/fake sample. However, I don't find this to be a particularly elegant approach, and the paper also shows that the effect of RaSGAN is not always better than RSGAN, so I will not introduce it here. Interested readers can view the original paper.</p>

    <p>As for effectiveness, the results listed in the paper show that RSGAN improves generation quality in quite a few tasks, though not universally; on average, there is a slight improvement. The author specifically pointed out that RSGAN can speed up the training of the generator. I personally experimented with it, and it is somewhat faster than SGAN and SNGAN.</p>

    <p>My reference code: <a href="https://github.com/bojone/gan/blob/master/keras/rsgan_sn_celeba.py">https://github.com/bojone/gan/blob/master/keras/rsgan_sn_celeba.py</a></p>

    <p>Borrowing a chart from <a href="https://github.com/MingtaoGuo/DCGAN_WGAN_WGAN-GP_LSGAN_SNGAN_RSGAN_RaSGAN_TensorFlow">MingtaoGuo</a> to compare RSGAN's convergence speed:</p>

    <p style="text-align:center;"><img src="https://kexue.fm/usr/uploads/2018/10/2687059029.jpg" alt="RSGAN convergence speed comparison" title="RSGAN Convergence Speed Comparison" /></p>

    <p>From an intuitive perspective, RSGAN is faster because information from real samples is also used when training the generator, rather than relying solely on the "memory" of the discriminator. From a theoretical perspective, by taking the difference of $T(x_r)$ and $T(x_f)$, the discriminator only depends on their relative values, which simply improves the potential bias situation in the discriminator $T$, making gradients more stable. I even think that introducing real samples into the generator training might (though I haven't proven it carefully) improve the diversity of forged samples. Because there are various real samples for comparison, it is difficult for the model to satisfy the discriminator's relative judgment criteria if it only generates a single type of sample.</p>

    <h2>Related Discussion</h2>

    <h3>Simple Summary</h3>
    <p>Overall, I believe RSGAN's improvement to GANs represents a change in thought—something even the authors of RSGAN might not have noticed.</p>

    <p>We often say that WGAN was a major breakthrough after GAN. This is true, but that breakthrough was theoretical, whereas the thought remained the same: both were reducing the distance between two distributions. It's just that JS divergence previously had various issues, so WGAN switched to Wasserstein distance. I feel RSGAN is more of a breakthrough in thought—transforming the task into discrimination after shuffling real and fake samples—even if the results are not significantly better. (Of course, if you say that everyone ultimately pulls distributions closer, then I have nothing to say ^_^)</p>

    <p>Some of RSGAN's improvements are easy to reproduce. However, since there isn't an improvement in every single task, some critics argue it is merely another GAN training trick. These comments are a matter of opinion, but they don't hinder my appreciation and research of this paper.</p>

    <p>By the way, the author <a href="https://scholar.google.com/citations?user=0qytQ1oAAAAJ&hl=en">Alexia Jolicoeur-Martineau</a> is a female biostatistician at Jewish General Hospital. The results in the paper were run by her using only a single GTX 1060 (<a href="https://www.reddit.com/r/MachineLearning/comments/8vr9am/r_the_relativistic_discriminator_a_key_element/e1ru76p">source here</a>). Suddenly, I feel proud of only having a 1060 as well... (though I have a 1060 but no papers~)</p>

    <h3>Extended Discussion</h3>
    <p>Finally, some random thoughts.</p>

    <p>First, note that the WGAN discriminator loss itself is in the form of the difference between two terms. That is to say, the WGAN discriminator is essentially a relative discriminator, which the author believes is an important reason for WGAN's good performance.</p>

    <p>This makes it look like WGAN and RSGAN share some common ground. But I have a further thought: can the comparison between $\tilde{p}(x_r)q(x_f)$ and $\tilde{p}(x_f)q(x_r)$ be completely switched to using Wasserstein distance? We know that WGAN's generator training target also has nothing to do with real samples. How can we better introduce real sample information into WGAN's generator?</p>

    <p>Another question is, currently, the difference is only taken at the scalar level of the discriminator's final output. Could it be a difference at some hidden layer of the discriminator, followed by calculating an MSE or adding a few more neural network layers? In short, I think there is more to be done with this model...</p>

    <h3>Supplementary Proof</h3>

    <blockquote>
        <strong>1. Optimal solution for \eqref{eq:sgan-d}</strong>
        \begin{equation}\begin{aligned}&-\mathbb{E}_{x\sim \tilde{p}(x)}[\log \sigma(T(x))] - \mathbb{E}_{x\sim q(x)}[\log(1-\sigma(T(x)))]\\
        =&-\int \Big(\tilde{p}(x) \log \sigma(T(x)) + q(x) \log(1-\sigma(T(x))) \Big)dx\end{aligned}\end{equation}

        Using $\delta$ for variations, which is basically the same as differentiation:
        \begin{equation}\begin{aligned}&\delta \int \Big(\tilde{p}(x) \log \sigma(T(x)) + q(x) \log(1-\sigma(T(x))) \Big)dx\\
        =& \int \left(\tilde{p}(x) \frac{\delta \sigma(T(x))}{\sigma(T(x))} + q(x) \frac{-\delta \sigma(T(x))}{1-\sigma(T(x))} \right)dx\\
        =& \int \left(\tilde{p}(x) \frac{1}{\sigma(T(x))} - q(x) \frac{1}{1-\sigma(T(x))} \right)\delta \sigma(T(x)) dx
        \end{aligned}\end{equation}

        The extremum is reached when the variation is zero. Since $\delta \sigma(T(x))$ represents an arbitrary increment, for the above equation to be identically zero, the part inside the parentheses must be identically zero:
        \begin{equation}\tilde{p}(x) \frac{1}{\sigma(T(x))} = q(x) \frac{1}{1-\sigma(T(x))}\end{equation}

        <strong>2. Optimal solution for \eqref{eq:rsgan-d}</strong>
        \begin{equation}\begin{aligned}&-\mathbb{E}_{x_r\sim \tilde{p}(x), x_f\sim q(x)}[\log \sigma(T(x_r)-T(x_f))]\\
        =&-\iint \tilde{p}(x_r)q(x_f)\log \sigma(T(x_r)-T(x_f)) dx_r dx_f\end{aligned}\end{equation}

        Taking the variation:
        \begin{equation}\begin{aligned}&\delta \iint \tilde{p}(x_r)q(x_f)\log \sigma(T(x_r)-T(x_f)) dx_r dx_f\\
        =& \iint \tilde{p}(x_r)q(x_f)\frac{\delta \sigma(T(x_r)-T(x_f))}{\sigma(T(x_r)-T(x_f))} dx_r dx_f\quad[\text{Next, use }\sigma'(x)=\sigma(x)\sigma(-x)]\\
        =& \iint \tilde{p}(x_r)q(x_f)\sigma(T(x_f)-T(x_r)) \times (\delta T(x_r)-\delta T(x_f)) dx_r dx_f\\
        =& \iint \tilde{p}(x_r)q(x_f)\sigma(T(x_f)-T(x_r)) \delta T(x_r) dx_r dx_f \quad[\text{Next, swap }x_r, x_f\text{ in the second part}]\\
        & \qquad - \iint \tilde{p}(x_r)q(x_f)\sigma(T(x_f)-T(x_r)) \delta T(x_f) dx_r dx_f\\
        =& \iint \tilde{p}(x_r)q(x_f)\sigma(T(x_f)-T(x_r)) \delta T(x_r) dx_r dx_f \\
        & \qquad - \iint \tilde{p}(x_f)q(x_r)\sigma(T(x_r)-T(x_f)) \delta T(x_r) dx_f dx_r\\
        =& \iint \Big[\tilde{p}(x_r)q(x_f)\sigma(T(x_f)-T(x_r)) \\
        & \qquad\qquad - \tilde{p}(x_f)q(x_r)\sigma(T(x_r)-T(x_f))\Big] \delta T(x_r) dx_r dx_f
        \end{aligned}\end{equation}

        The extremum is reached when the variation is zero, so the part within the square brackets must be zero:
        \begin{equation}\tilde{p}(x_r)q(x_f)\sigma(T(x_f)-T(x_r))=\tilde{p}(x_f)q(x_r)\sigma(T(x_r)-T(x_f))\end{equation}
    </blockquote>
</article>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/6110" style="color: #005fcc;">https://kexue.fm/archives/6110</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
