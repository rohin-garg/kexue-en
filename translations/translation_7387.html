
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    packages: {'[+]': ['ams']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<h1><a href="https://kexue.fm/archives/7387">Analysis of the AdaX Optimizer (with Open-Source Implementation)</a></h1>

<p>By 苏剑林 | May 11, 2020</p>

<p>This article briefly introduces an optimizer called AdaX, from the paper <a href="https://papers.cool/arxiv/2004.09740">"AdaX: Adaptive Gradient Descent with Exponential Long Term Memory"</a>. The reason for introducing this optimizer is that it once again confirms a conclusion mentioned in my previous post <a href="translation_7302.html">"Analysis of the AdaFactor Optimizer (with Open-Source Implementation)"</a>; the two articles can be read in comparison.</p>

<h2>Adam & AdaX <a id="Adam & AdaX" href="#Adam & AdaX">#</a></h2>

<p>The update format of AdaX is:</p>

\begin{equation}\left\{\begin{aligned}&g_t = \nabla_{\theta} L(\theta_t)\\
&m_t = \beta_1 m_{t-1} + \left(1 - \beta_1\right) g_t\\
&v_t = (1 + \beta_2) v_{t-1} + \beta_2 g_t^2\\
&\hat{v}_t = v_t\left/\left(\left(1 + \beta_2\right)^t - 1\right)\right.\\
&\theta_t = \theta_{t-1} - \alpha_t m_t\left/\sqrt{\hat{v}_t + \epsilon}\right.
\end{aligned}\right.\end{equation}

<p>Where the default value of $\beta_2$ is $0.0001$. By the way, here is my Keras implementation: <a href="https://github.com/bojone/adax">https://github.com/bojone/adax</a></p>

<p>For comparison, the update format of Adam is:</p>

\begin{equation}\left\{\begin{aligned}&g_t = \nabla_{\theta} L(\theta_t)\\
&m_t = \beta_1 m_{t-1} + \left(1 - \beta_1\right) g_t\\
&v_t = \beta_2 v_{t-1} + \left(1 - \beta_2\right) g_t^2\\
&\hat{m}_t = m_t\left/\left(1 - \beta_1^t\right)\right.\\
&\hat{v}_t = v_t\left/\left(1 - \beta_2^t\right)\right.\\
&\theta_t = \theta_{t-1} - \alpha_t \hat{m}_t\left/\sqrt{\hat{v}_t + \epsilon}\right.
\end{aligned}\right.\end{equation}

<p>Where the default value of $\beta_2$ is $0.999$.</p>

<h2>Equivalent Form Transformation <a id="Equivalent Form Transformation" href="#Equivalent Form Transformation">#</a></h2>

<p>As can be seen, the first difference is that AdaX removes the bias correction for momentum (the step $\hat{m}_t = m_t\left/\left(1 - \beta_1^t\right)\right.$), but this actually has little impact. The biggest modification in AdaX is at $v_t$. Originally, $v_t = \beta_2 v_{t-1} + \left(1 - \beta_2\right) g_t^2$ is a moving average format, whereas $v_t = (1 + \beta_2) v_{t-1} + \beta_2 g_t^2$ does not look like a moving average, and since $1 + \beta_2 > 1$, there seems to be a risk of exponential explosion. The original paper calls this "with Exponential Long Term Memory," referring to the fact that $1 + \beta_2 > 1$ causes the weight of historical accumulated gradients not to decrease, but rather to increase; this is its long-term memory property.</p>

<p>In fact, the learning rate correction uses $\hat{v}_t$, so to see whether it explodes, we should observe $\hat{v}_t$. For Adam, we have:</p>

\begin{equation}\begin{aligned}
\hat{v}_t =& v_t\left/\left(1 - \beta_2^t\right)\right.\\
=&\frac{\beta_2 v_{t-1} + (1-\beta_2) g_t^2}{1 - \beta_2^t}\\
=&\frac{\beta_2 \hat{v}_{t-1}\left(1 - \beta_2^{t-1}\right) + (1-\beta_2) g_t^2}{1 - \beta_2^t}\\
=&\beta_2\frac{1 - \beta_2^{t-1}}{1 - \beta_2^t}\hat{v}_{t-1} + \left(1 - \beta_2\frac{1 - \beta_2^{t-1}}{1 - \beta_2^t}\right)g_t^2
\end{aligned}\end{equation}

<p>So if we set $\hat{\beta}_{2,t}=\beta_2\frac{1 - \beta_2^{t-1}}{1 - \beta_2^t}$, then the update formula is:</p>

\begin{equation}\hat{v}_t =\hat{\beta}_{2,t}\hat{v}_{t-1} + \left(1 - \hat{\beta}_{2,t}\right)g_t^2\end{equation}

<p>Based on the same logic, if we set $\hat{\beta}_{2,t}=1 - \frac{\beta_2}{(1 + \beta_2)^t - 1}$, then the update formula for AdaX's $\hat{v}_t$ can also be written in the above form.</p>

<h2>Comparison of Decay Strategies <a id="Comparison of Decay Strategies" href="#Comparison of Decay Strategies">#</a></h2>

<p>Therefore, looking at $\hat{v}_t$, which is actually used to correct the gradients, whether it is Adam or AdaX, the update formulas are both in the moving average format, only the corresponding decay coefficients $\hat{\beta}_{2,t}$ are different.</p>

<p>For Adam, when $t=1$, $\hat{\beta}_{2,t}=0$. At this time, $\hat{v}_t$ is $g_t^2$, meaning the real-time gradient is used to correct the learning rate, providing the strongest correction. When $t\to\infty$, $\hat{\beta}_{2,t}\to \beta_2$. At this point, $v_t$ is a weighted average of the accumulated squared gradients and the current squared gradient. Since $\beta_2 < 1$, the weight of the current gradient $1 - \beta_2$ is not zero. This might lead to training instability because, in the later stages of training, gradients become smaller and the training itself tends toward stability, so the significance of learning rate correction decreases. Consequently, the intensity of learning rate correction should become smaller, and as $t\to\infty$, the learning rate should ideally become constant (effectively degrading to SGD), which requires that when $t\to\infty$, $\hat{\beta}_{2,t}\to 1$.</p>

<p>For AdaX, when $t=1$, $\hat{\beta}_{2,t}=0$, and when $t\to\infty$, $\hat{\beta}_{2,t}\to 1$, satisfying the ideal property mentioned above. Therefore, from this perspective, AdaX is indeed an improvement over Adam. AdaFactor uses $\hat{\beta}_{2,t} = 1 - \frac{1}{t^c}$, which was also designed from this perspective. As for whether the strategy of AdaX or AdaFactor is superior, I believe it is hard to explain clearly from a theoretical standpoint and can probably only be determined through experiments.</p>

<h2>Conclusion <a id="Conclusion" href="#Conclusion">#</a></h2>

<p>Well, the article ends here. As stated at the beginning, this post is just a simple introduction to AdaX, as it once again confirms a previous conclusion—$\hat{\beta}_{2,t}$ should satisfy the condition "$\hat{\beta}_{2,1}=0, \hat{\beta}_{2,\infty}=1$". This may become one of the basic conditions for the improvement of optimizers in the future.</p>

<p><strong>Original Address:</strong> <a href="https://kexue.fm/archives/7387">https://kexue.fm/archives/7387</a></p>

<p>Su Jianlin. (May. 11, 2020). "Analysis of the AdaX Optimizer (with Open-Source Implementation)" [Blog post]. Retrieved from <a href="https://kexue.fm/archives/7387">https://kexue.fm/archives/7387</a></p>

<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/7387" style="color: #005fcc;">https://kexue.fm/archives/7387</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
