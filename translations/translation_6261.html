
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    tags: 'ams',
    packages: {'[+]': ['ams']}
  },
  options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<nav style="margin-bottom: 1.5em;">
    <a href="../index.html" style="display: inline-flex; align-items: center; color: #555; text-decoration: none; font-size: 0.95em;">
        <span style="margin-right: 0.3em;">&larr;</span> Back to Index
    </a>
</nav>

<h1><a href="https://kexue.fm/archives/6261">Optimization Algorithms from the Perspective of Dynamics (III): A More Holistic View</a></h1>

    <p>By 苏剑林 | January 08, 2019</p>


<p>Lately, I've been increasingly excited about combining optimization algorithms with dynamics. This is the third installment in the series on optimization algorithms and dynamics, and I have a premonition there will be a fourth—stay tuned! A brief recap of the story so far: In the <a href="translation_6024.html">first article</a>, we pointed out that SGD is essentially a numerical method for solving ordinary differential equations (ODEs): the Euler method. In the <a href="translation_6081.html">second article</a>, from the perspective of error analysis in numerical methods, we analyzed why the gradient can be used to adjust the learning rate, thereby explaining the principle behind using gradients to regulate learning rates in algorithms like RMSprop and Adam.</p>

<p>This article will provide a more unified viewpoint on these two matters and attempt to answer a more fundamental question: Why gradient descent?</p>

<p>(Note: The discussion in this article does not involve the momentum acceleration component.)</p>

<h3>Gradient Descent Revisited</h3>

<p>The previous two articles discussed the viewpoint that "gradient descent is equivalent to solving an ODE," but we haven't yet addressed why we use gradient descent in the first place. Where does it come from? That is to say, previously we were only explaining gradient descent after it was already given; we haven't yet faced the problem of the <i>origin</i> of gradient descent.</p>

<h3>The Direction of Steepest Descent</h3>

<p>The basic explanation is this: the direction opposite to the gradient is the direction in which the loss decreases fastest, so we use gradient descent. People often draw diagrams like contour maps to explain why the negative gradient is the direction of steepest descent. Consequently, many critics of adaptive learning rate optimizers like RMSprop cite a simple reason: these optimizers change the direction of parameter descent, meaning the optimization no longer follows the gradient direction, which allegedly leads to poorer results.</p>

<p>But is this explanation sufficiently reasonable?</p>

<h3>Redefining the Problem</h3>

<p>Before the formal discussion, let's define the problem simply:</p>
<ol>
    <li>We have a scalar function $L(\boldsymbol{\theta})\geq 0$, where the parameter $\boldsymbol{\theta}$ can be a multivariate vector;</li>
    <li>There exists at least one point $\boldsymbol{\theta}^*$ such that $L(\boldsymbol{\theta}^*)=0$, meaning the minimum value of $L(\boldsymbol{\theta})$ is 0.</li>
    <li>Given the specific form of $L(\boldsymbol{\theta})$, we naturally want to find a $\boldsymbol{\theta}$ that makes $L(\boldsymbol{\theta})=0$, or if that's not possible, a $\boldsymbol{\theta}$ that makes $L(\boldsymbol{\theta})$ as small as possible.</li>
</ol>
<p>It's worth mentioning that point 2 is not strictly necessary, but it helps with the descriptions we'll explore later. In other words, <u>point 2 is actually just an assumption</u>. Keep in mind that for an arbitrary function, we don't generally know its minimum value beforehand. However, in deep learning, this is basically true because we usually set the loss to be non-negative, and thanks to the powerful fitting capabilities of neural networks, the loss can largely get close enough to 0.</p>

<h3>Considering the Rate of Change of the Loss</h3>

<p>Now, to the main point. Suppose that during the optimization process, the parameter $\boldsymbol{\theta}$ changes according to some trajectory $\boldsymbol{\theta}(t)$, making $L(\boldsymbol{\theta})$ a function of $t$, $L(\boldsymbol{\theta}(t))$. Note that $t$ here is not real time; it is a parameter used to describe change, equivalent to the number of iterations.</p>

<p>Let's consider the rate of change of $L(\boldsymbol{\theta}(t))$:</p>

\begin{equation}\frac{d}{dt}L(\boldsymbol{\theta}(t))=\left\langle\nabla_{\boldsymbol{\theta}}L,\, \dot{\boldsymbol{\theta}}\right\rangle\label{eq:ld}\end{equation}

<p>Here $\dot{\boldsymbol{\theta}}$ is $d\boldsymbol{\theta}/dt$, and $\langle\cdot\rangle$ denotes the standard inner product. We want $L$ to be as small as possible, so we naturally want the right side of the equation to be negative, and for its absolute value to be as large as possible. If we fix the magnitude of $\dot{\boldsymbol{\theta}}$, then to minimize the right side, the angle between $\nabla_{\boldsymbol{\theta}}L$ and $\dot{\boldsymbol{\theta}}$ should be 180 degrees, which means:</p>

\begin{equation}\dot{\boldsymbol{\theta}} = -\lambda \nabla_{\boldsymbol{\theta}}L\quad (\lambda > 0)\label{eq:gd}\end{equation}

<p>This demonstrates that the direction opposite to the gradient is indeed the direction in which the loss falls fastest. According to the <a href="translation_6024.html">first article</a>, isn't this equation exactly gradient descent? Thus, we have directly derived gradient descent. Substituting $\eqref{eq:gd}$ into $\eqref{eq:ld}$, we get:</p>

\begin{equation}\frac{d}{dt}L(\boldsymbol{\theta}(t))=-\lambda\left\Vert\nabla_{\boldsymbol{\theta}}L\right\Vert^2\label{eq:ld-1}\end{equation}

<p>This shows that as long as the learning rate is small enough (the ODE simulation is accurate enough) and $\nabla_{\boldsymbol{\theta}}L\neq \boldsymbol{0}$, then $L$ will definitely decrease until $\nabla_{\boldsymbol{\theta}}L = 0$. The position where it stops is a local minimum or a saddle point; theoretically, it cannot be a local maximum.</p>

<p>Furthermore, we often use stochastic gradient descent. The mini-batch approach introduces a certain amount of noise, and noise can reduce the probability of getting stuck at a saddle point (as saddle points may not be robust to perturbations). Therefore, stochastic gradient descent usually performs better than full-batch gradient descent.</p>

<h3>RMSprop Revisited</h3>

<p>In fact, if one truly understands the above derivation process, they can "cook up" many different optimization algorithms themselves.</p>

<h3>More Than One Direction</h3>

<p>For instance, although we've proven that the negative gradient is the direction of steepest descent, why must we always go in the direction of steepest descent? Although the negative gradient is the "righteous path," one can also "take an unconventional path." Theoretically, as long as I can guarantee a decrease, it's fine. For example, I could choose:</p>

\begin{equation}\dot{\boldsymbol{\theta}} = -\text{sign}\left(\nabla_{\boldsymbol{\theta}}L\right)\label{eq:rmsprop-1}\end{equation}

<p>Note that $\nabla_{\boldsymbol{\theta}}L$ is a vector, and $\text{sign}\left(\nabla_{\boldsymbol{\theta}}L\right)$ refers to taking the sign function of each component, resulting in a vector with elements that are -1, 0, or 1. Consequently, equation $\eqref{eq:ld}$ becomes:</p>

\begin{equation}\frac{d}{dt}L(\boldsymbol{\theta}(t))=-\lambda\left\Vert\nabla_{\boldsymbol{\theta}}L\right\Vert_1\label{eq:ld-2}\end{equation}

<p>where $\Vert\boldsymbol{x}\Vert_1=\sum\limits_{i=1}^n |x_i|$ represents the L1 norm of the vector. This selection also guarantees that the loss is decreasing, and theoretically, it converges where $\nabla_{\boldsymbol{\theta}}L = 0$.</p>

<p>Furthermore, we also have (assuming non-zero gradient components):</p>

\begin{equation}\text{sign}\left(\nabla_{\boldsymbol{\theta}}L\right)=\frac{\nabla_{\boldsymbol{\theta}}L}{\sqrt{\nabla_{\boldsymbol{\theta}}L\otimes \nabla_{\boldsymbol{\theta}}L}}\label{eq:rmsprop-2}\end{equation}

<p>Combining $\eqref{eq:rmsprop-1}$ and the <a href="translation_6081.html">second article</a>, and incorporating a moving average, we find that this section is describing the RMSprop algorithm.</p>

<p>In other words, the fact that in adaptive learning rate optimizers "the learning rate becomes a vector, making the optimization direction no longer the gradient direction" is not a flaw and should not be a point for which adaptive learning rate optimizers are criticized.</p>

<h3>What Happens When You Don't Take the Shortest Path?</h3>

<p>However, the reality is that with careful tuning, the final performance of SGD is usually better than that of adaptive learning rate optimizers, which suggests they do have some issues. That is, if you take an unconventional path, even if you start faster than others, you might not do as well in the later stages.</p>

<p>What is the problem? Actually, for Adagrad, the problem is obviously that it <u>"stops too early"</u> because it sums historical gradients (rather than averaging them), causing the learning rate to approach 0 too quickly. For the RMSprop mentioned above, the problem is—<u>"it simply cannot stop."</u></p>

<p>Combining $\eqref{eq:rmsprop-1}$ and $\eqref{eq:rmsprop-2}$, we get:</p>

\begin{equation}\dot{\boldsymbol{\theta}} = -\frac{\nabla_{\boldsymbol{\theta}}L}{\sqrt{\nabla_{\boldsymbol{\theta}}L\otimes \nabla_{\boldsymbol{\theta}}L}}\label{eq:rmsprop-3}\end{equation}

<p>When does this algorithm stop? In fact, it won't stop, because as long as a gradient component is non-zero, the corresponding component of $\frac{\nabla_{\boldsymbol{\theta}}L}{\sqrt{\nabla_{\boldsymbol{\theta}}L\otimes \nabla_{\boldsymbol{\theta}}L}}$ is also non-zero (either 1 or -1). Theoretically, this algorithm has no fixed point, so it will never stop. To mitigate this, practical RMSprop implementations use two tricks: taking a moving average of the denominator and adding an epsilon (to prevent division by zero).</p>

<p>But these can only be considered mitigations. In ODE terms, <u>"this ODE is not asymptotically stable,"</u> so it will inevitably keep passing by the local minimum. This is the real problem with adaptive learning rate algorithms.</p>

<h3>A Little Tinkering</h3>

<p>As mentioned before, if you really understand this process, you can tinker with some "original" optimization algorithms yourself and analyze their convergence. Below, I'll introduce my own tinkering process, which <i>mistakenly</i> led me to believe I had found an optimizer that could absolutely find the global optimum~</p>

<p>(Before reading the following content, please ensure you have understood the previous material; otherwise, it may be misleading~)</p>

<h3>Guided by the Global Optimum</h3>

<p>The starting point of this tinkering is that whether it is $\eqref{eq:gd}$ (with the corresponding convergence rate $\eqref{eq:ld-1}$) or $\eqref{eq:rmsprop-3}$ (with the corresponding convergence rate $\eqref{eq:ld-2}$), even if they converge, they only guarantee $\nabla_{\boldsymbol{\theta}}L = 0$; they cannot guarantee a global minimum (i.e., they don't necessarily achieve $L(\boldsymbol{\theta})=0$). So, a simple idea is: since we already know the minimum value is zero, why not include this information?</p>

<p>Analogous to our previous thinking, we can consider:</p>

\begin{equation}\dot{\boldsymbol{\theta}} = -\frac{\nabla_{\boldsymbol{\theta}}L}{\left\Vert\nabla_{\boldsymbol{\theta}}L\right\Vert^2}L\label{eq:me-gd}\end{equation}

<p>In this case, equation $\eqref{eq:ld}$ becomes very simple:</p>

\begin{equation}\frac{d}{dt}L=-L\end{equation}

<p>This is just a simple linear differential equation, and the solution is $L(t)=e^{-t}$. As $t\to+\infty$, $L(t)\to 0$, meaning the loss is guaranteed to converge to zero.</p>

<h3>Is It Really That Good?</h3>

<p>Of course not~ Let's look at equation $\eqref{eq:me-gd}$. If we reach a local minimum where $\nabla_{\boldsymbol{\theta}}L=\boldsymbol{0}$ and $L > 0$, the right side of $\eqref{eq:me-gd}$ becomes negative infinity. Theoretically, this is not an issue, but numerically it is impossible to implement. Initially, I thought this could be easily solved by adding an epsilon to the denominator. But further analysis revealed that the problem is fatal.</p>

<p>To see why, let's rewrite $\eqref{eq:me-gd}$ as:</p>

\begin{equation}\dot{\boldsymbol{\theta}} = -\frac{\nabla_{\boldsymbol{\theta}}L}{\left\Vert\nabla_{\boldsymbol{\theta}}L\right\Vert}L\times\frac{1}{\left\Vert\nabla_{\boldsymbol{\theta}}L\right\Vert}\label{eq:me-gd-2}\end{equation}

<p>The problem is that $1/\left\Vert\nabla_{\boldsymbol{\theta}}L\right\Vert$ will become infinitely large (a singularity appears). Can we use a truncation? For example, consider:</p>

\begin{equation}\dot{\boldsymbol{\theta}} = -\frac{\nabla_{\boldsymbol{\theta}}L}{\left\Vert\nabla_{\boldsymbol{\theta}}L\right\Vert}L\times\min\left(\frac{1}{\left\Vert\nabla_{\boldsymbol{\theta}}L\right\Vert},M\right)\label{eq:me-gd-3}\end{equation}

<p>where $M \gg 0$ is a constant, bypassing the singularity. Doing this does indeed allow it to bypass some local minima, like in the following example:</p>

<p><img src="https://kexue.fm/usr/uploads/2019/01/552683935.png" alt="A univariate function with two local minima" /></p>

<p>This function has a global minimum around $x=0.41$ where the function value can reach 0, but it also has a sub-optimal minimum at $x=3$. If we start with an initial value of $x_0=4$, standard gradient descent would basically always converge to $x=3$. However, using $\eqref{eq:me-gd-3}$, starting from $x_0=4$, after some oscillation, it eventually converges near $x=0.41$:</p>

<p><img src="https://kexue.fm/usr/uploads/2019/01/2402179830.png" alt="Simulating the 'unique version' gradient descent trajectory" /></p>

<p>We can see that it initially lingers near $x=3$, and after oscillating for a while, it jumps out and arrives near $x=0.41$. The plotting code:</p>

<pre><code>import numpy as np
import matplotlib.pyplot as plt

def f(x):
    return x * (x - 1) * (x - 3) * (x - 3) + 1.62276

def g(x):
    return -9 + 30 * x - 21 * x**2 + 4 * x**3

ts = [0]
xs = [4]
h = 0.01
H = 2500

for i in range(H):
    x = xs[-1]
    delta = -np.sign(g(x)) * min(abs(g(x)) / g(x)**2, 1000) * f(x)
    x += delta * h
    xs.append(x)
    ts.append(ts[-1] + h)

print f(xs[-1])
plt.figure()
plt.clf()
plt.plot(ts, xs, 'g')
plt.xlabel('$t$')
plt.ylabel('$\\theta(t)$')
plt.show()</code></pre>

<p>However, while it looks beautiful, it has little practical value. To guarantee jumping out of all local minima, $M$ must be sufficiently large (to stay close to the original $\eqref{eq:me-gd-2}$), and the number of iterations must be high. If these conditions could be met, it would actually be better to add Gaussian noise to gradient descent. As we showed in the first article, if we assume the gradient noise is Gaussian, from a probabilistic standpoint, it will always eventually reach the global minimum (also requiring many iterations). So, this pretty-looking thing doesn't have much practical utility.</p>

<p>(Note: I later learned that Polyak had studied step sizes of the form $\eqref{eq:me-gd}$ much earlier. Searching for "Polyak step size" will yield many related works, such as <a href="https://arxiv.org/abs/1712.03190">"Revisiting the Polyak step size"</a> and <a href="https://arxiv.org/abs/1802.04261">"Generalized Polyak Step Size for First Order Optimization with Momentum"</a>.)</p>

<h3>Summary</h3>

<p>Well, after quite a bit of rambling and tinkering, I've managed to put together another article. Personally, I feel that analyzing optimization algorithms from a dynamic perspective is a very interesting endeavor. it allows you to understand the charm of optimization algorithms from a relatively relaxed angle, and it can even connect many different fields of knowledge.</p>

<p>The general approach to understanding optimization algorithms starts with convex optimization and then non-rigorously applies the results to non-convex situations. We study convex optimization because "convexity" is a powerful condition for many theoretical proofs. However, deep learning is almost entirely non-convex. Since it's already non-convex, meaning the advantage of complete proofs from convex optimization no longer applies, I think it's better to look at things from a more relaxed angle. This more relaxed angle is dynamical systems, or systems of ordinary differential equations.</p>

<p>In fact, this perspective has great potential, including the convergence analysis of GANs and the popular "Neural ODEs," both of which eventually fall into this framework. But those are topics for another time~</p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="https://kexue.fm/archives/6261" style="color: #005fcc;">https://kexue.fm/archives/6261</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
