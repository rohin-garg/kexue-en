
    <style type="text/css">

    body {
    margin: 48px auto;
    max-width: 68ch;              /* character-based width reads better */
    padding: 0 16px;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    line-height: 1.65;
    color: #333;
    background: #fafafa;
    }

    h1, h2, h3, h4 {
    line-height: 1.25;
    margin-top: 2.2em;
    margin-bottom: 0.6em;
    font-weight: 600;
    }

    h1 {
    font-size: 2.1em;
    margin-top: 0;
    }

    h2 {
    font-size: 1.6em;
    border-bottom: 1px solid #e5e5e5;
    padding-bottom: 0.3em;
    }

    h3 {
    font-size: 1.25em;
    }

    h4 {
    font-size: 1.05em;
    color: #555;
    }

    /* Paragraphs and lists */
    p {
    margin: 1em 0;
    }

    ul, ol {
    margin: 1em 0 1em 1.5em;
    }

    li {
    margin: 0.4em 0;
    }

    a {
    color: #005fcc;
    text-decoration: none;
    }

    a:hover {
    text-decoration: underline;
    }

    code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.95em;
    background: #f2f2f2;
    padding: 0.15em 0.35em;
    border-radius: 4px;
    }

    pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 0.9em;
    background: #f5f5f5;
    padding: 1em 1.2em;
    overflow-x: auto;
    border-radius: 6px;
    line-height: 1.45;
    }

    pre code {
    background: none;
    padding: 0;
    }

    blockquote {
    margin: 1.5em 0;
    padding-left: 1em;
    border-left: 4px solid #ddd;
    color: #555;
    }

    hr {
    border: none;
    border-top: 1px solid #e0e0e0;
    margin: 3em 0;
    }

    table {
    border-collapse: collapse;
    margin: 1.5em 0;
    width: 100%;
    font-size: 0.95em;
    }

    th, td {
    padding: 0.5em 0.7em;
    border-bottom: 1px solid #e5e5e5;
    text-align: left;
    }

    th {
    font-weight: 600;
    }

    img {
    max-width: 100%;
    display: block;
    margin: 1.5em auto;
    }

    small {
    color: #666;
    }

    mjx-container {
    margin: 1em 0;
    }

    ::selection {
    background: #cce2ff;
    }

    </style>
    

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    packages: {'[+]': ['ams']},
    tags: 'ams'
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script" async></script>

<h1><a href="https://kexue.fm/archives/3873">From Boosting Learning to Neural Networks: Seeing Mountains as Mountains?</a></h1>

<p>By 苏剑林 | July 01, 2016</p>

<p>A while ago, while teaching text mining to students at Hanshan Normal University in Chaozhou, I delved into Boosting learning algorithms and engaged in some brainstorming. Eventually, I clarified some essential characteristics of Boosting learning algorithms and obtained some unexpected results. For instance, some theoretical proofs of the AdaBoost algorithm can also be used to explain why neural network models are so powerful.</p>

<h3>AdaBoost Algorithm</h3>

<p>Boosting learning belongs to the category of ensemble models. Of course, rather than calling it an algorithm, it is better to describe it as a problem-solving strategy. Taking supervised classification as an example, it suggests that weak classifiers (as long as their accuracy is strictly greater than a random classifier) can be combined in a certain way to obtain an excellent classifier (theoretically, the accuracy can reach 100%).</p>

<p>The AdaBoost algorithm is an example of a Boosting algorithm, proposed by Schapire in 1996. It constructed an explicit scheme for Boosting learning and provided a theoretical proof regarding the error rate.</p>

<p>Taking a binary classification problem as an example, let us assume we have a set of samples $\{x_i, y_i\}, i=1, 2, \dots, n$, where $x_i$ is the sample data (possibly multi-dimensional input) and $y_i \in \{1, -1\}$ is the sample label. We use 1 and -1 to describe the labels instead of the usual 1 and 0 merely for the convenience of the subsequent proof, without any special underlying meaning. Next, assume we already have a weak classifier $G(x)$, such as Logistic Regression, SVM, or decision trees. The only requirement for the classifier is that its accuracy must be strictly greater than random (in a binary classification problem, it must be strictly greater than 0.5). "Strictly greater" means there exists a constant $\epsilon > 0$ such that the accuracy each time is no lower than $\frac{1}{2} + \epsilon$.</p>

<p>The core idea of the AdaBoost algorithm is: before each training session with the weak classifier $G(x)$, it sets different weights $w_{k,1}, w_{k,2}, \dots, w_{k,n}$ for the samples (increasing the weights of previously mispredicted samples). In this way, different model parameters $G_1(x), G_2(x), \dots, G_m(x)$ are obtained each time (this could be the same model with different parameters or a combination of several different models). They are then combined in the following manner:</p>

$$y = \bar{G}(x) = \text{sign}[f(x)] = \text{sign}\left[\sum_{k=1}^m \alpha_k G_k(x)\right]$$

<p>Here $f(x) = \sum_{k=1}^m \alpha_k G_k(x)$. Ultimately, it can be proven that the classifier $\bar{G}(x)$ is an excellent analytical tool. Since the AdaBoost algorithm is not the primary focus of this article, I have placed the specific mathematical details at the end to avoid deviating from the main topic.</p>

<h3>Seeing Mountains as Mountains, Water as Water</h3>

<p>Putting mathematical details aside, let us reflect: what exactly did the AdaBoost algorithm do? Or more broadly, what is the essence of so-called ensemble models?</p>

<p>When we build a classification model, the typical process is as follows:<br>
1. Find a set of labeled data, such as emotional comments in a text sentiment classification model;<br>
2. Construct features;<br>
3. Choose an appropriate model, such as Logistic Regression, SVM, Neural Networks, etc.;<br>
4. Input the model for training;<br>
5. Test results and optimize improvement.</p>

<p>Beginners often focus their energy on Step 3, becoming obsessed with high-precision non-linear models. In fact, models with very high precision often involve a strong internal process of feature construction. If the features are constructed well, even simple linear models (like Logistic Regression) will have relatively high precision. In other words, <strong>the most important step in modeling should be the second step—the construction of features.</strong></p>

<p>Of course, constructing good features is also the most difficult step. Constructing good features requires a thorough understanding of the data and sometimes professional background knowledge. There is no unified method for how to combine existing features to form better ones.</p>

<p>At this stage, we are often troubled by feature construction and look forward to surprises in prediction results. This is the stage of "seeing mountains as mountains, water as water" (seeing features as features, results as results).</p>

<h3>Seeing Mountains Not as Mountains, Water Not as Water</h3>

<p>However, why not be a bit more imaginative? Again, assume we have a binary classification task, such as text sentiment classification. We use existing data to train a model, say Logistic Regression, obtain the model's parameters, and output some prediction results. The accuracy of the results is higher than 50%.</p>

<p>Are these prediction results merely results?</p>

<p>From a mathematical perspective, these results are obtained through a linear combination of original data, followed by a non-linear transformation with a logistic function. Put simply, they are derived from the original features through certain calculations. Looking at this sentence alone—why not view this as a way of constructing features?</p>

<p>Exactly! <strong>It is a result, but it is also a feature!</strong> You use one set of weights to train a Logistic Regression model and get a batch of prediction results; you change the weights to train another Logistic Regression model with different parameters and get a new batch of prediction results; and so on. Why not treat these results as features and put them into yet another Logistic Regression model? This model, at the very least, will not be less accurate than any single original model, right? Thus, we arrive at a magical conclusion—<strong>models can be used to predict results, and they can also be used to construct features—results are features.</strong> At this point, we reach the realm of "seeing mountains not as mountains, water not as water"—the boundary between features and results has blurred.</p>

<p>At this point, we might have a sudden realization—the essence of Boosting learning is nothing more than treating model results as features and then building a model on top of them once more. Since the results of models are generally good features already, the final stage can significantly enhance the effectiveness of the classifier—when features are good, precision naturally follows.</p>

<p>At this point, I really want to sigh and quote Laozi: "The Tao that can be told is not the eternal Tao; The name that can be named is not the eternal name."</p>

<h3>Seeing Mountains Still as Mountains, Water Still as Water</h3>

<p>This is a new perspective: viewing model results as a constructed feature. However, have we not used this method before?</p>

<p>In fact, we have, though it might not be obvious. Suppose there is a binary classification problem (e.g., predicting whether someone smokes), where one of the features is gender, with values Male/Female. How do we quantify this and put it into the model? We can use 1 to represent male and the vector 0 to represent female. Can this not be seen as constructing the following model?</p>

$$G(x) = \left\{\begin{aligned}&1, \quad x = \text{Male} \\ &0, \quad x = \text{Female}\end{aligned}\right.$$

<p>Clearly, it can be viewed as a model (the input is gender, the output is whether they smoke, where 1 indicates smoking) to predict whether an individual smokes. This was originally just a way of representing a feature, but now it has become a prediction result of a model, and we then input this model result into a new model for prediction. Reviewing this process, is it not also treating a result as a feature to be input into a model?</p>

<p>It turns out we used this idea long ago; it was just not obvious enough. Thinking back now, its shadow can be found in many aspects of data mining. Perhaps we have returned to simplicity and have the feeling of "seeing mountains still as mountains, water still as water." Boosting learning algorithms (AdaBoost) can be said to have carried this idea forward. And after reading the description of the neural network section below, this feeling becomes even stronger.</p>

<h3>Neural Networks</h3>

<p>However, the one that has truly taken this idea to the extreme is the neural network model.</p>

<p>Do neural network models also have a relationship with Boosting learning? Yes, a neural network can be seen as an enhanced version of a special case of AdaBoost. From this, we can also use the theoretical proofs of AdaBoost to explain why neural networks are so powerful.</p>

<p>What do I mean by this? Let's review the paragraph we just discussed:</p>

<blockquote>It is a result, but it is also a feature! You use one set of weights to train a Logistic Regression model and get a batch of prediction results; you change the weights to train another Logistic Regression model with different parameters and get a new batch of prediction results; and so on. Why not treat these results as features and put them into yet another Logistic Regression model? This model, at the very least, will not be less accurate than any single original model, right?</blockquote>

<p>Representing this with a diagram, what kind of process is it? As shown below:</p>

<p>
<img src="https://kexue.fm/usr/uploads/2016/07/2627405232.png" alt="AdaBoost Learning Process" />
<br />
AdaBoost Learning Process
</p>

<p>At first glance, isn't this just a three-layer network model?</p>

<p>Exactly, this is a three-layer neural network model! By choosing Logistic Regression as the weak classifier and combining them using the AdaBoost algorithm, the result is equivalent to a three-layer neural network model!</p>

<p>However, neural networks are even more sophisticated. The AdaBoost algorithm is trained step-by-step, similar to a greedy algorithm, and the result is very likely only a local optimum. In contrast, neural networks leave all parameters to be determined and use a loss function to find the global optimum. As long as the optimization algorithm is good enough, an optimal solution can be obtained. From this perspective, neural networks are superior. Furthermore, neural networks can nest more layers on this basis (which can be viewed as using AdaBoost as a weak classifier and combining it multiple times to obtain an even more excellent classifier), making the effect even better. Therefore, in today's era of Deep Learning, the significance of the AdaBoost algorithm has been diminished. What remains unchanged is that its core idea still holds very important heuristic value.</p>

<p>Not only that, from the perspective of "treating prediction results as features," we can also derive the structure of RNNs (Recurrent Neural Networks)! We find that the current AdaBoost algorithm, in the final step of model construction, only uses the output results of the previous models as features. <strong>Why not use both the previous output results and the original data together as features to build the model?</strong></p>

<p>If we actually do this, we form the prototype of an RNN—adding the previous output to the current input.</p>

<p>By this point, <strong>neural networks have become a special case of the AdaBoost algorithm, but simultaneously its enhanced version. One might say that neural networks have pushed the idea of ensemble models to their pinnacle.</strong></p>

<p>At this moment, it is as if Boosting is everywhere, truly a case of "seeing mountains as mountains, water as water"! Because Boosting has never been just an independent model; it is a profound problem-solving philosophy—profound thoughts have far-reaching impacts~</p>

<h3>Supplement: Derivations for the AdaBoost Algorithm</h3>

<p>The AdaBoost algorithm is not difficult to understand, but the current challenge is how to select the values for $w$ and $\alpha$? Schapire provided a selection scheme:</p>

<p>1. At the beginning, initialize $w_{1,1} = w_{1,2} = \dots = w_{1,n} = \frac{1}{n}$, and use these weights to train the classifier $G_1(x)$;<br>
2. In each subsequent step, update $w$ and $\alpha$ in the following way:</p>

\begin{align}
&\alpha_k = \frac{1}{2} \log \frac{1-\varepsilon_k}{\varepsilon_k} \\
&w_{k+1,i} = \frac{1}{Z_k} w_{k,i} \exp(-\alpha_k y_i G_k(x_i))
\end{align}

<p>Where $\varepsilon_k$ is the error rate, i.e., the number of mispredicted samples divided by $n$ when using the model $G_k(x)$ for prediction. Written as a mathematical formula, it is:</p>

$$\varepsilon_k = \sum_{i=1}^n w_{k,i} I(-y_i G_k(x_i))$$

<p>Here $I(x)$ is the indicator function:</p>

$$I(x) = \left\{\begin{aligned}&1, \quad x > 0 \\ &0, \quad x \leq 0\end{aligned}\right.$$

<p>When the prediction is correct, $-y_i G_k(x_i) = -1$, so $I(-y_i G_k(x_i)) = 0$. Conversely, $I(-y_i G_k(x_i)) = 1$. Thus, $\sum_{i=1}^n I(-y_i G_k(x_i))$ counts the number of errors. And $Z_k = \sum_{i=1}^n w_{k,i} \exp(-\alpha_k y_i G_k(x_i))$ is the normalization factor.</p>

<p>The biggest question is certainly: why choose them this way? I don't know how Schapire came up with it, but perhaps we can find some clues from the error rate analysis. The error rate $\varepsilon$ of the final classifier $\bar{G}(x)$ is estimated as:</p>

\begin{align}
\varepsilon &= \frac{1}{n} \sum_{i=1}^n I(-y_i \bar{G}(x_i)) \\
&= \frac{1}{n} \sum_{i=1}^n I(-y_i f(x_i)) \\
&< \frac{1}{n} \sum_{i=1}^n \exp(-y_i f(x_i))
\end{align}

<p>Here we use $I(x) \leq \max(0, 1+x) < \max(0, e^x) = e^x$. At this point, we can substitute the expression for $f$:</p>

\begin{align}
&\frac{1}{n} \sum_{i=1}^n \exp(-y_i f(x_i)) \\
&= \frac{1}{n} \sum_{i=1}^n \exp\left(-y_i \sum_{k=1}^m \alpha_k G_k(x_i)\right) \\
&= \frac{1}{n} \sum_{i=1}^n \prod_{k=1}^m \exp(-y_i \alpha_k G_k(x_i)) \\
&= \sum_{i=1}^n w_{1,i} \prod_{k=1}^m \exp(-y_i \alpha_k G_k(x_i)) \\
&= \sum_{i=1}^n w_{1,i} \exp(-y_i \alpha_1 G_1(x_i)) \prod_{k=2}^m \exp(-y_i \alpha_k G_k(x_i)) \\
&= Z_1 \sum_{i=1}^n w_{2,i} \prod_{k=2}^m \exp(-y_i \alpha_k G_k(x_i)) \\
&= \dots \\
&= Z_1 Z_2 \dots Z_m
\end{align}

<p>Reviewing the expression for $Z_k$:</p>

$$Z_k = \sum_{i=1}^n w_{k,i} \exp(-\alpha_k y_i G_k(x_i))$$

<p>It is worth noting that while the term $\exp(-\alpha_k y_i G_k(x_i))$ looks complex, it actually has only two possibilities: $e^{-\alpha_k}$ if the prediction is correct, and $e^{\alpha_k}$ if the prediction is incorrect. Therefore:</p>

\begin{align}
Z_k &= \sum_{i=1}^n w_{k,i} \exp(-\alpha_k y_i G_k(x_i)) \\
&= \sum_{\text{correct}} w_{k,i} e^{-\alpha_k} + \sum_{\text{incorrect}} w_{k,i} e^{\alpha_k} \\
&= e^{-\alpha_k} \sum_{\text{correct}} w_{k,i} + e^{\alpha_k} \sum_{\text{incorrect}} w_{k,i} \\
&= e^{-\alpha_k}(1-\varepsilon_k) + e^{\alpha_k} \varepsilon_k \\
&= 2\sqrt{(1-\varepsilon_k)\varepsilon_k} \quad (\text{substituting } \alpha_k = \frac{1}{2} \log \frac{1-\varepsilon_k}{\varepsilon_k}) \\
&= \sqrt{1-4\gamma_k^2} \quad (\text{let } \gamma_k = \frac{1}{2}-\varepsilon_k) \\
&\leq \exp(-2\gamma_k^2)
\end{align}

<p>So:</p>

$$\varepsilon < Z_1 Z_2 \dots Z_m < \exp\left(-2 \sum_{k=1}^m \gamma_k^2\right)$$

<p>If $\gamma_k$ has a positive lower bound (which is why the weak classifier's accuracy must be strictly greater than random), then the error rate will tend toward 0 and decrease exponentially. This is very ideal. Of course, even if such a model results in 100% accuracy, it usually can only be used on the training data; in other words, overfitting is likely to occur. However, this is an extreme case; in practice, AdaBoost’s overfitting phenomenon is not severe.</p>

<p>Regarding Boosting algorithms, I won't provide further examples. More content can be found at: <a href="http://www.52caml.com/head_first_ml/ml-chapter6-boosting-family/">http://www.52caml.com/head_first_ml/ml-chapter6-boosting-family/</a></p>
<hr>
<footer style="margin-top: 3em; padding: 1.5em; background: #f5f5f5; border-radius: 8px; font-size: 0.9em; color: #555;">
    <p style="margin: 0 0 0.5em 0;"><strong>Citation</strong></p>
    <p style="margin: 0 0 0.5em 0;">
        This is a machine translation of the original Chinese article:<br>
        <a href="translation_3873.html" style="color: #005fcc;">https://kexue.fm/archives/3873</a>
    </p>
    <p style="margin: 0 0 0.5em 0;">
        Original author: 苏剑林 (Su Jianlin)<br>
        Original publication: <a href="https://kexue.fm" style="color: #005fcc;">科学空间 (Scientific Spaces)</a>
    </p>
    <p style="margin: 0; font-style: italic;">
        Translated using Gemini 3 Flash. Please refer to the original for authoritative content.
    </p>
</footer>
